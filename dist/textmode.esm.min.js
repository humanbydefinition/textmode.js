var X = Object.defineProperty;
var W = (s, e, t) => e in s ? X(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t;
var l = (s, e, t) => W(s, typeof e != "symbol" ? e + "" : e, t);
class b extends Error {
  constructor(t, r, i = {}) {
    const a = b.createFormattedMessage(t, i);
    super(a);
    l(this, "originalError");
    l(this, "context");
    this.name = "TextmodeError", this.originalError = r, this.context = i;
  }
  /**
   * Create a formatted error message that includes context
   */
  static createFormattedMessage(t, r) {
    let i = t;
    if (r && Object.keys(r).length > 0) {
      i += `

ðŸ“‹ Context:`;
      for (const [a, n] of Object.entries(r)) {
        const o = b.formatValue(n);
        i += `
  - ${a}: ${o}`;
      }
    }
    return i += `

`, i += "â†“".repeat(24) + `
`, i;
  }
  /**
   * Format values for better display in error messages
   */
  static formatValue(t) {
    if (t === null) return "null";
    if (t === void 0) return "undefined";
    if (typeof t == "string") return `"${t}"`;
    if (typeof t == "number" || typeof t == "boolean") return String(t);
    if (Array.isArray(t))
      return t.length === 0 ? "[]" : t.length <= 5 ? `[${t.map((r) => b.formatValue(r)).join(", ")}]` : `[${t.slice(0, 3).map((r) => b.formatValue(r)).join(", ")}, ... +${t.length - 3} more]`;
    if (typeof t == "object") {
      const r = Object.keys(t);
      return r.length === 0 ? "{}" : r.length <= 3 ? `{ ${r.map((n) => `${n}: ${b.formatValue(t[n])}`).join(", ")} }` : `{ ${r.slice(0, 2).map((a) => `${a}: ${b.formatValue(t[a])}`).join(", ")}, ... +${r.length - 2} more }`;
    }
    return String(t);
  }
}
var Y = /* @__PURE__ */ ((s) => (s[s.SILENT = 0] = "SILENT", s[s.WARNING = 1] = "WARNING", s[s.ERROR = 2] = "ERROR", s[s.THROW = 3] = "THROW", s))(Y || {});
const R = class R {
  constructor() {
    l(this, "_options", {
      globalLevel: 3
      /* THROW */
    });
  }
  static getInstance() {
    return R._instance || (R._instance = new R()), R._instance;
  }
  /**
   * Handle an error based on the configured settings
   * @returns true if execution should continue, false if error was handled
   */
  _handle(e, t, r) {
    const i = "[textmode.js]";
    switch (this._options.globalLevel) {
      case 0:
        return !1;
      // Validation failed, handled silently
      case 1:
        return console.group(
          `%c${i} Oops! (â•¯Â°â–¡Â°)â•¯ï¸µ Something went wrong in your code.`,
          "color: #f44336; font-weight: bold; background: #ffebee; padding: 2px 6px; border-radius: 3px;"
        ), console.warn(b.createFormattedMessage(e, t)), console.groupEnd(), !1;
      case 2:
        return console.group(
          `%c${i} Oops! (â•¯Â°â–¡Â°)â•¯ï¸µ Something went wrong in your code.`,
          "color: #f44336; font-weight: bold; background: #ffebee; padding: 2px 6px; border-radius: 3px;"
        ), console.error(b.createFormattedMessage(e, t)), console.groupEnd(), !1;
      case 3:
      default:
        const a = new b(e, r, t);
        throw console.group(
          `%c${i} Oops! (â•¯Â°â–¡Â°)â•¯ï¸µ Something went wrong in your code.`,
          "color: #d32f2f; font-weight: bold; background: #ffcdd2; padding: 2px 6px; border-radius: 3px;"
        ), a;
    }
  }
  /**
   * Validate a condition and handle errors if validation fails
   * @param condition The condition to validate
   * @param message Error message if validation fails
   * @param context Additional context for debugging
   * @returns true if validation passed, false if validation failed and was handled
   */
  validate(e, t, r) {
    return e ? !0 : (this._handle(t, r), !1);
  }
  /**
   * Set global error level
   */
  setGlobalLevel(e) {
    this._options.globalLevel = e;
  }
};
l(R, "_instance", null);
let B = R;
const p = B.getInstance();
class j {
  constructor(e, t, r = t, i = {}) {
    l(this, "gl");
    l(this, "_framebuffer");
    l(this, "_texture");
    l(this, "_width");
    l(this, "_height");
    l(this, "options");
    l(this, "previousState", null);
    l(this, "_pixels", null);
    this.gl = e, this._width = t, this._height = r, this.options = {
      filter: "nearest",
      wrap: "clamp",
      format: "rgba",
      type: "unsigned_byte",
      ...i
    }, this._texture = this.createTexture(), this._framebuffer = e.createFramebuffer(), this.attachTexture();
  }
  createTexture() {
    const { gl: e } = this, t = e.createTexture();
    e.bindTexture(e.TEXTURE_2D, t);
    const r = this.options.filter === "linear" ? e.LINEAR : e.NEAREST, i = this.options.wrap === "repeat" ? e.REPEAT : e.CLAMP_TO_EDGE;
    return e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, r), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, r), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, i), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, i), this.updateTextureSize(), t;
  }
  updateTextureSize() {
    const { gl: e } = this, t = e.RGBA, r = e.RGBA, i = this.options.type === "float" ? e.FLOAT : e.UNSIGNED_BYTE;
    e.texImage2D(e.TEXTURE_2D, 0, t, this._width, this._height, 0, r, i, null);
  }
  attachTexture() {
    const { gl: e } = this;
    e.bindFramebuffer(e.FRAMEBUFFER, this._framebuffer), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, this._texture, 0), e.bindFramebuffer(e.FRAMEBUFFER, null);
  }
  /**
   * Update the framebuffer texture with canvas or video content
   */
  update(e) {
    const { gl: t } = this;
    e instanceof HTMLVideoElement && e.readyState < 2 || (t.bindTexture(t.TEXTURE_2D, this._texture), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, e), t.bindTexture(t.TEXTURE_2D, null));
  }
  /**
   * Update the framebuffer texture with pixel data
   */
  updatePixels(e, t, r) {
    const { gl: i } = this;
    i.bindTexture(i.TEXTURE_2D, this._texture), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, t, r, 0, i.RGBA, i.UNSIGNED_BYTE, e), i.bindTexture(i.TEXTURE_2D, null);
  }
  /**
   * Resize the framebuffer
   */
  resize(e, t) {
    this._width = e, this._height = t, this.gl.bindTexture(this.gl.TEXTURE_2D, this._texture), this.updateTextureSize(), this.gl.bindTexture(this.gl.TEXTURE_2D, null);
  }
  /**
   * Begin rendering to this framebuffer
   */
  begin() {
    const { gl: e } = this;
    this.previousState = {
      framebuffer: e.getParameter(e.FRAMEBUFFER_BINDING),
      viewport: e.getParameter(e.VIEWPORT)
    }, e.bindFramebuffer(e.FRAMEBUFFER, this._framebuffer), e.viewport(0, 0, this._width, this._height);
  }
  /**
   * End rendering to this framebuffer and restore previous state
   */
  end() {
    if (!this.previousState) return;
    const { gl: e } = this;
    e.bindFramebuffer(e.FRAMEBUFFER, this.previousState.framebuffer), e.viewport(...this.previousState.viewport), this.previousState = null;
  }
  /**
   * Load pixel data from the framebuffer into the pixels array
   */
  loadPixels() {
    const { gl: e } = this;
    this._pixels || (this._pixels = new Uint8Array(this._width * this._height * 4));
    const t = e.getParameter(e.FRAMEBUFFER_BINDING);
    e.bindFramebuffer(e.FRAMEBUFFER, this._framebuffer), e.readPixels(0, 0, this._width, this._height, e.RGBA, e.UNSIGNED_BYTE, this._pixels), e.bindFramebuffer(e.FRAMEBUFFER, t);
  }
  get(e, t, r, i) {
    const { gl: a } = this;
    if (e === void 0 && t === void 0) {
      const n = new Uint8Array(this._width * this._height * 4), o = a.getParameter(a.FRAMEBUFFER_BINDING);
      return a.bindFramebuffer(a.FRAMEBUFFER, this._framebuffer), a.readPixels(0, 0, this._width, this._height, a.RGBA, a.UNSIGNED_BYTE, n), a.bindFramebuffer(a.FRAMEBUFFER, o), n;
    } else if (r === void 0 && i === void 0) {
      (e < 0 || t < 0 || e >= this._width || t >= this._height) && (console.warn("The x and y values passed to Framebuffer.get are outside of its range and will be clamped."), e = Math.max(0, Math.min(e, this._width - 1)), t = Math.max(0, Math.min(t, this._height - 1)));
      const n = new Uint8Array(4), o = a.getParameter(a.FRAMEBUFFER_BINDING);
      return a.bindFramebuffer(a.FRAMEBUFFER, this._framebuffer), a.readPixels(e, t, 1, 1, a.RGBA, a.UNSIGNED_BYTE, n), a.bindFramebuffer(a.FRAMEBUFFER, o), [n[0], n[1], n[2], n[3]];
    } else {
      e = Math.max(0, Math.min(e, this._width - 1)), t = Math.max(0, Math.min(t, this._height - 1)), r = Math.max(1, Math.min(r, this._width - e)), i = Math.max(1, Math.min(i, this._height - t));
      const n = new Uint8Array(r * i * 4), o = a.getParameter(a.FRAMEBUFFER_BINDING);
      return a.bindFramebuffer(a.FRAMEBUFFER, this._framebuffer), a.readPixels(e, t, r, i, a.RGBA, a.UNSIGNED_BYTE, n), a.bindFramebuffer(a.FRAMEBUFFER, o), n;
    }
  }
  // Getters
  get framebuffer() {
    return this._framebuffer;
  }
  get texture() {
    return this._texture;
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get pixels() {
    return this._pixels;
  }
}
class z {
  constructor(e, t, r, i, a, n = {}) {
    /** The WebGL rendering context */
    l(this, "gl");
    /** The vertex buffer containing position and optional texture coordinates */
    l(this, "vertexBuffer");
    /** The number of vertices in this geometry (always 6 for two triangles) */
    l(this, "vertexCount", 6);
    /** The rendering mode: textured or solid color */
    l(this, "renderMode");
    /** Bytes per vertex: 8 for position-only, 16 for position+texture */
    l(this, "bytesPerVertex");
    this.gl = e;
    const o = n.textured ?? !0;
    this.renderMode = o ? "textured" : "solid", this.bytesPerVertex = o ? 16 : 8;
    const h = e.getParameter(e.VIEWPORT), c = h[2], u = h[3], f = e.getParameter(e.FRAMEBUFFER_BINDING) !== null, m = t / c * 2 - 1, _ = (t + i) / c * 2 - 1;
    let x, g;
    f ? (x = r / u * 2 - 1, g = (r + a) / u * 2 - 1) : (x = 1 - r / u * 2, g = 1 - (r + a) / u * 2);
    const v = this.generateVertices(m, x, _, g, o);
    this.vertexBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.vertexBuffer), e.bufferData(e.ARRAY_BUFFER, v, e.STATIC_DRAW);
  }
  /**
   * Generate vertex data for the rectangle
   * @private
   */
  generateVertices(e, t, r, i, a) {
    return a ? new Float32Array([
      e,
      i,
      0,
      1,
      // bottom-left
      r,
      i,
      1,
      1,
      // bottom-right
      e,
      t,
      0,
      0,
      // top-left
      e,
      t,
      0,
      0,
      // top-left
      r,
      i,
      1,
      1,
      // bottom-right
      r,
      t,
      1,
      0
      // top-right
    ]) : new Float32Array([
      e,
      i,
      // bottom-left
      r,
      i,
      // bottom-right
      e,
      t,
      // top-left
      e,
      t,
      // top-left
      r,
      i,
      // bottom-right
      r,
      t
      // top-right
    ]);
  }
  /**
   * Render the rectangle using the appropriate vertex attributes
   */
  render() {
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);
    const e = 0, t = 1;
    this.gl.enableVertexAttribArray(e), this.gl.vertexAttribPointer(e, 2, this.gl.FLOAT, !1, this.bytesPerVertex, 0), this.renderMode === "textured" && (this.gl.enableVertexAttribArray(t), this.gl.vertexAttribPointer(t, 2, this.gl.FLOAT, !1, this.bytesPerVertex, 8)), this.gl.drawArrays(this.gl.TRIANGLES, 0, this.vertexCount), this.gl.disableVertexAttribArray(e), this.renderMode === "textured" && this.gl.disableVertexAttribArray(t);
  }
}
class y {
  constructor(e, t, r) {
    l(this, "gl");
    l(this, "program");
    l(this, "uniformLocations", /* @__PURE__ */ new Map());
    l(this, "attributeLocations", /* @__PURE__ */ new Map());
    l(this, "textureUnitCounter", 0);
    this.gl = e, this.program = this.createProgram(t, r), this.cacheLocations();
  }
  createProgram(e, t) {
    const r = this.createShader(this.gl.VERTEX_SHADER, e), i = this.createShader(this.gl.FRAGMENT_SHADER, t), a = this.gl.createProgram();
    if (this.gl.attachShader(a, r), this.gl.attachShader(a, i), this.gl.linkProgram(a), !this.gl.getProgramParameter(a, this.gl.LINK_STATUS)) {
      const n = this.gl.getProgramInfoLog(a);
      throw new Error(`Shader program link error: ${n}`);
    }
    return this.gl.deleteShader(r), this.gl.deleteShader(i), a;
  }
  createShader(e, t) {
    const r = this.gl.createShader(e);
    if (this.gl.shaderSource(r, t), this.gl.compileShader(r), !this.gl.getShaderParameter(r, this.gl.COMPILE_STATUS)) {
      const i = this.gl.getShaderInfoLog(r);
      throw this.gl.deleteShader(r), new Error(`Shader compilation error: ${i}`);
    }
    return r;
  }
  cacheLocations() {
    const e = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_UNIFORMS);
    for (let r = 0; r < e; r++) {
      const i = this.gl.getActiveUniform(this.program, r);
      if (i) {
        const a = this.gl.getUniformLocation(this.program, i.name);
        a && this.uniformLocations.set(i.name, a);
      }
    }
    const t = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_ATTRIBUTES);
    for (let r = 0; r < t; r++) {
      const i = this.gl.getActiveAttrib(this.program, r);
      if (i) {
        const a = this.gl.getAttribLocation(this.program, i.name);
        this.attributeLocations.set(i.name, a);
      }
    }
  }
  /**
   * Use this shader program
   */
  use() {
    this.gl.useProgram(this.program), this.resetTextureUnits();
  }
  /**
   * Set a single uniform value with automatic texture unit management
   */
  setUniform(e, t) {
    const r = this.uniformLocations.get(e);
    if (!r) {
      console.warn(`Uniform '${e}' not found in shader`);
      return;
    }
    const i = this.getUniformInfo(e);
    if (typeof t == "number")
      i && i.type === this.gl.INT ? this.gl.uniform1i(r, Math.floor(t)) : this.gl.uniform1f(r, t);
    else if (typeof t == "boolean")
      this.gl.uniform1i(r, t ? 1 : 0);
    else if (Array.isArray(t))
      if (i && (i.type === this.gl.INT_VEC2 || i.type === this.gl.INT_VEC3 || i.type === this.gl.INT_VEC4)) {
        const a = t.map((n) => Math.floor(n));
        switch (a.length) {
          case 2:
            this.gl.uniform2iv(r, a);
            break;
          case 3:
            this.gl.uniform3iv(r, a);
            break;
          case 4:
            this.gl.uniform4iv(r, a);
            break;
          default:
            console.warn(`Unsupported array length ${a.length} for uniform '${e}'`);
        }
      } else
        switch (t.length) {
          case 2:
            this.gl.uniform2f(r, t[0], t[1]);
            break;
          case 3:
            this.gl.uniform3f(r, t[0], t[1], t[2]);
            break;
          case 4:
            this.gl.uniform4f(r, t[0], t[1], t[2], t[3]);
            break;
          default:
            console.warn(`Unsupported array length ${t.length} for uniform '${e}'`);
        }
    else if (t instanceof WebGLTexture) {
      const a = this.getNextTextureUnit();
      this.gl.uniform1i(r, a), this.gl.activeTexture(this.gl.TEXTURE0 + a), this.gl.bindTexture(this.gl.TEXTURE_2D, t);
    } else if (t && typeof t == "object" && "texture" in t) {
      const a = this.getNextTextureUnit();
      this.gl.uniform1i(r, a), this.gl.activeTexture(this.gl.TEXTURE0 + a), this.gl.bindTexture(this.gl.TEXTURE_2D, t.texture);
    } else
      console.warn(`Unsupported uniform type for '${e}':`, typeof t);
  }
  /**
   * Get uniform info to determine the correct WebGL type
   */
  getUniformInfo(e) {
    const t = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_UNIFORMS);
    for (let r = 0; r < t; r++) {
      const i = this.gl.getActiveUniform(this.program, r);
      if (i && i.name === e)
        return i;
    }
    return null;
  }
  getNextTextureUnit() {
    return this.textureUnitCounter++;
  }
  /**
   * Reset texture unit counter (useful when starting a new frame)
   */
  resetTextureUnits() {
    this.textureUnitCounter = 0;
  }
}
var T = "attribute vec2 a_position;attribute vec2 a_texCoord;varying vec2 v_uv;void main(){v_uv=a_texCoord;gl_Position=vec4(a_position,0.0,1.0);}", q = "precision lowp float;uniform sampler2D u_texture;varying vec2 v_uv;void main(){gl_FragColor=texture2D(u_texture,v_uv);}", Q = "precision lowp float;uniform vec4 u_color;void main(){gl_FragColor=u_color;}";
class Z {
  constructor(e) {
    l(this, "gl");
    l(this, "imageShader");
    l(this, "solidColorShader");
    l(this, "currentShader", null);
    l(this, "currentBlendMode", "normal");
    // Fill state management
    l(this, "currentFillColor", [1, 1, 1, 1]);
    l(this, "fillMode", !1);
    this.gl = e, this.imageShader = new y(this.gl, T, q), this.solidColorShader = new y(this.gl, T, Q), this.gl.enable(this.gl.BLEND), this.gl.blendEquation(this.gl.FUNC_ADD), this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
  }
  /**
   * Set the current shader (p5.js-like API)
   */
  shader(e) {
    this.currentShader = e, e.use();
  }
  /**
   * Sets the fill color for subsequent rendering operations
   * @param r Red component (0-255)
   * @param g Green component (0-255, optional)
   * @param b Blue component (0-255, optional)
   * @param a Alpha component (0-255, optional)
   */
  fill(e, t, r, i) {
    if (this.fillMode = !0, t === void 0 && r === void 0 && i === void 0) {
      const a = e / 255;
      this.currentFillColor = [a, a, a, 1];
    } else if (r !== void 0 && i === void 0)
      this.currentFillColor = [e / 255, t / 255, r / 255, 1];
    else if (r !== void 0 && i !== void 0)
      this.currentFillColor = [e / 255, t / 255, r / 255, i / 255];
    else
      throw new Error("Invalid fill parameters. Use fill(gray), fill(r,g,b), or fill(r,g,b,a)");
  }
  /**
   * Reset fill mode - called automatically after each frame
   */
  reset() {
    this.fillMode = !1;
  }
  createShader(e, t) {
    return new y(this.gl, e, t);
  }
  /**
   * Set a uniform value for the current shader (p5.js-like API)
   */
  setUniform(e, t) {
    this.currentShader.setUniform(e, t);
  }
  /**
   * Draw a rectangle with the current shader or fill color (p5.js-like API)
   */
  rect(e, t, r, i) {
    if (this.fillMode && this.currentShader === null) {
      const a = this.currentBlendMode;
      this.setBlendMode(
        "premultiplied"
        /* PREMULTIPLIED */
      ), this.shader(this.solidColorShader), this.setUniform("u_color", this.currentFillColor), new z(this.gl, e, t, r, i, { textured: !1 }).render(), this.setBlendMode(a);
    } else
      new z(this.gl, e, t, r, i, { textured: !0 }).render();
    this.currentShader = null;
  }
  /**
   * Create a new framebuffer
   */
  createFramebuffer(e, t, r = {}) {
    return new j(this.gl, e, t, r);
  }
  /**
   * Fill the current framebuffer with a solid color (p5.js-like API)
   */
  background(e, t = e, r = e, i = 255) {
    this.clear(e / 255, t / 255, r / 255, i / 255);
  }
  /**
   * Clear the current framebuffer
   */
  clear(e = 0, t = 0, r = 0, i = 0) {
    this.gl.clearColor(e, t, r, i), this.gl.clear(this.gl.COLOR_BUFFER_BIT);
  }
  /**
   * Ensure viewport matches canvas dimensions
   */
  resetViewport() {
    this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
  }
  /**
   * Get the WebGL context
   */
  get context() {
    return this.gl;
  }
  /**
   * Set the blend mode for different rendering contexts
   */
  setBlendMode(e) {
    if (this.currentBlendMode !== e)
      switch (this.currentBlendMode = e, e) {
        case "normal":
          this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
          break;
        case "premultiplied":
          this.gl.blendFunc(this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA);
          break;
      }
  }
  /**
   * Render a framebuffer at a specific position with optional scaling
   */
  image(e, t, r, i, a) {
    const n = this.currentBlendMode;
    this.setBlendMode(
      "premultiplied"
      /* PREMULTIPLIED */
    ), this.shader(this.imageShader), this.setUniform("u_texture", e.texture), this.rect(t, r, i ?? e.width, a ?? e.height), this.setBlendMode(n);
  }
}
var d = {};
d.parse = function(s) {
  var e = d.B, t = function(m, _, x, g) {
    var v = d.T, w = {
      cmap: v.cmap,
      head: v.head,
      hhea: v.hhea,
      maxp: v.maxp,
      hmtx: v.hmtx,
      loca: v.loca,
      glyf: v.glyf
    }, F = { _data: m, _index: _, _offset: x };
    for (var C in w) {
      var M = d.findTable(m, C, x);
      if (M) {
        var S = M[0], E = g[S];
        E == null && (E = w[C].parseTab(m, S, M[1], F)), F[C] = g[S] = E;
      }
    }
    return F;
  }, r = new Uint8Array(s), i = {}, a = e.readASCII(r, 0, 4);
  if (a == "ttcf") {
    var n = 4;
    e.readUshort(r, n), n += 2, e.readUshort(r, n), n += 2;
    var o = e.readUint(r, n);
    n += 4;
    for (var h = [], c = 0; c < o; c++) {
      var u = e.readUint(r, n);
      n += 4, h.push(t(r, c, u, i));
    }
    return h;
  }
  var f = t(r, 0, 0, i);
  return [f];
};
d.findTable = function(s, e, t) {
  for (var r = d.B, i = r.readUshort(s, t + 4), a = t + 12, n = 0; n < i; n++) {
    var o = r.readASCII(s, a, 4);
    r.readUint(s, a + 4);
    var h = r.readUint(s, a + 8), c = r.readUint(s, a + 12);
    if (o == e) return [h, c];
    a += 16;
  }
  return null;
};
d.T = {};
d.B = {
  readFixed: function(s, e) {
    return (s[e] << 8 | s[e + 1]) + (s[e + 2] << 8 | s[e + 3]) / (256 * 256 + 4);
  },
  readF2dot14: function(s, e) {
    var t = d.B.readShort(s, e);
    return t / 16384;
  },
  readInt: function(s, e) {
    var t = d.B.t.uint8;
    return t[0] = s[e + 3], t[1] = s[e + 2], t[2] = s[e + 1], t[3] = s[e], d.B.t.int32[0];
  },
  readInt8: function(s, e) {
    var t = d.B.t.uint8;
    return t[0] = s[e], d.B.t.int8[0];
  },
  readShort: function(s, e) {
    var t = d.B.t.uint16;
    return t[0] = s[e] << 8 | s[e + 1], d.B.t.int16[0];
  },
  readUshort: function(s, e) {
    return s[e] << 8 | s[e + 1];
  },
  readUshorts: function(s, e, t) {
    for (var r = [], i = 0; i < t; i++)
      r.push(d.B.readUshort(s, e + i * 2));
    return r;
  },
  readUint: function(s, e) {
    var t = d.B.t.uint8;
    return t[3] = s[e], t[2] = s[e + 1], t[1] = s[e + 2], t[0] = s[e + 3], d.B.t.uint32[0];
  },
  readUint64: function(s, e) {
    return d.B.readUint(s, e) * 4294967296 + d.B.readUint(s, e + 4);
  },
  readASCII: function(s, e, t) {
    for (var r = "", i = 0; i < t; i++) r += String.fromCharCode(s[e + i]);
    return r;
  },
  readBytes: function(s, e, t) {
    for (var r = [], i = 0; i < t; i++) r.push(s[e + i]);
    return r;
  },
  t: function() {
    var s = new ArrayBuffer(8);
    return {
      buff: s,
      int8: new Int8Array(s),
      uint8: new Uint8Array(s),
      int16: new Int16Array(s),
      uint16: new Uint16Array(s),
      int32: new Int32Array(s),
      uint32: new Uint32Array(s)
    };
  }()
};
d.T.cmap = {
  parseTab: function(s, e, t) {
    var r = { tables: [], ids: {}, off: e };
    s = new Uint8Array(s.buffer, e, t), e = 0;
    var i = d.B, a = i.readUshort, n = d.T.cmap;
    a(s, e), e += 2;
    var o = a(s, e);
    e += 2;
    for (var h = [], c = 0; c < o; c++) {
      var u = a(s, e);
      e += 2;
      var f = a(s, e);
      e += 2;
      var m = i.readUint(s, e);
      e += 4;
      var _ = "p" + u + "e" + f, x = h.indexOf(m);
      if (x == -1) {
        x = r.tables.length;
        var g = {};
        h.push(m);
        var v = g.format = a(s, m);
        v == 4 ? g = n.parse4(s, m, g) : v == 12 && (g = n.parse12(s, m, g)), r.tables.push(g);
      }
      r.ids[_] != null && console.log("multiple tables for one platform+encoding: " + _), r.ids[_] = x;
    }
    return r;
  },
  parse4: function(s, e, t) {
    var r = d.B, i = r.readUshort, a = r.readUshorts, n = e;
    e += 2;
    var o = i(s, e);
    e += 2, i(s, e), e += 2;
    var h = i(s, e);
    e += 2;
    var c = h >>> 1;
    t.searchRange = i(s, e), e += 2, t.entrySelector = i(s, e), e += 2, t.rangeShift = i(s, e), e += 2, t.endCount = a(s, e, c), e += c * 2, e += 2, t.startCount = a(s, e, c), e += c * 2, t.idDelta = [];
    for (var u = 0; u < c; u++)
      t.idDelta.push(r.readShort(s, e)), e += 2;
    return t.idRangeOffset = a(s, e, c), e += c * 2, t.glyphIdArray = a(s, e, n + o - e >> 1), t;
  },
  parse12: function(s, e, t) {
    var r = d.B, i = r.readUint;
    e += 4, i(s, e), e += 4, i(s, e), e += 4;
    var a = i(s, e) * 3;
    e += 4;
    for (var n = t.groups = new Uint32Array(a), o = 0; o < a; o += 3)
      n[o] = i(s, e + (o << 2)), n[o + 1] = i(s, e + (o << 2) + 4), n[o + 2] = i(s, e + (o << 2) + 8);
    return t;
  }
};
d.T.head = {
  parseTab: function(s, e, t) {
    var r = d.B, i = {};
    return r.readFixed(s, e), e += 4, i.fontRevision = r.readFixed(s, e), e += 4, r.readUint(s, e), e += 4, r.readUint(s, e), e += 4, i.flags = r.readUshort(s, e), e += 2, i.unitsPerEm = r.readUshort(s, e), e += 2, i.created = r.readUint64(s, e), e += 8, i.modified = r.readUint64(s, e), e += 8, i.xMin = r.readShort(s, e), e += 2, i.yMin = r.readShort(s, e), e += 2, i.xMax = r.readShort(s, e), e += 2, i.yMax = r.readShort(s, e), e += 2, i.macStyle = r.readUshort(s, e), e += 2, i.lowestRecPPEM = r.readUshort(s, e), e += 2, i.fontDirectionHint = r.readShort(s, e), e += 2, i.indexToLocFormat = r.readShort(s, e), e += 2, i.glyphDataFormat = r.readShort(s, e), e += 2, i;
  }
};
d.T.hhea = {
  parseTab: function(s, e, t) {
    var r = d.B, i = {};
    r.readFixed(s, e), e += 4;
    for (var a = [
      "ascender",
      "descender",
      "lineGap",
      "advanceWidthMax",
      "minLeftSideBearing",
      "minRightSideBearing",
      "xMaxExtent",
      "caretSlopeRise",
      "caretSlopeRun",
      "caretOffset",
      "res0",
      "res1",
      "res2",
      "res3",
      "metricDataFormat",
      "numberOfHMetrics"
    ], n = 0; n < a.length; n++) {
      var o = a[n], h = o == "advanceWidthMax" || o == "numberOfHMetrics" ? r.readUshort : r.readShort;
      i[o] = h(s, e + n * 2);
    }
    return i;
  }
};
d.T.hmtx = {
  parseTab: function(s, e, t, r) {
    for (var i = d.B, a = [], n = [], o = r.maxp.numGlyphs, h = r.hhea.numberOfHMetrics, c = 0, u = 0, f = 0; f < h; )
      c = i.readUshort(s, e + (f << 2)), u = i.readShort(s, e + (f << 2) + 2), a.push(c), n.push(u), f++;
    for (; f < o; )
      a.push(c), n.push(u), f++;
    return { aWidth: a, lsBearing: n };
  }
};
d.T.maxp = {
  parseTab: function(s, e, t) {
    var r = d.B, i = r.readUshort, a = {};
    return r.readUint(s, e), e += 4, a.numGlyphs = i(s, e), e += 2, a;
  }
};
d.T.loca = {
  parseTab: function(s, e, t, r) {
    var i = d.B, a = [], n = r.head.indexToLocFormat, o = r.maxp.numGlyphs + 1;
    if (n == 0) for (var h = 0; h < o; h++) a.push(i.readUshort(s, e + (h << 1)) << 1);
    if (n == 1) for (var h = 0; h < o; h++) a.push(i.readUint(s, e + (h << 2)));
    return a;
  }
};
d.T.glyf = {
  parseTab: function(s, e, t, r) {
    for (var i = [], a = r.maxp.numGlyphs, n = 0; n < a; n++) i.push(null);
    return i;
  },
  _parseGlyf: function(s, e) {
    var t = d.B, r = s._data, i = s.loca;
    if (i[e] == i[e + 1]) return null;
    var a = d.findTable(r, "glyf", s._offset)[0] + i[e], n = {};
    if (n.noc = t.readShort(r, a), a += 2, n.xMin = t.readShort(r, a), a += 2, n.yMin = t.readShort(r, a), a += 2, n.xMax = t.readShort(r, a), a += 2, n.yMax = t.readShort(r, a), a += 2, n.xMin >= n.xMax || n.yMin >= n.yMax) return null;
    if (n.noc > 0) {
      n.endPts = [];
      for (var o = 0; o < n.noc; o++)
        n.endPts.push(t.readUshort(r, a)), a += 2;
      var h = t.readUshort(r, a);
      if (a += 2, r.length - a < h) return null;
      n.instructions = t.readBytes(r, a, h), a += h;
      var c = n.endPts[n.noc - 1] + 1;
      n.flags = [];
      for (var o = 0; o < c; o++) {
        var u = r[a];
        if (a++, n.flags.push(u), u & 8) {
          var f = r[a];
          a++;
          for (var m = 0; m < f; m++)
            n.flags.push(u), o++;
        }
      }
      n.xs = [];
      for (var o = 0; o < c; o++) {
        var _ = (n.flags[o] & 2) != 0, x = (n.flags[o] & 16) != 0;
        _ ? (n.xs.push(x ? r[a] : -r[a]), a++) : x ? n.xs.push(0) : (n.xs.push(t.readShort(r, a)), a += 2);
      }
      n.ys = [];
      for (var o = 0; o < c; o++) {
        var _ = (n.flags[o] & 4) != 0, x = (n.flags[o] & 32) != 0;
        _ ? (n.ys.push(x ? r[a] : -r[a]), a++) : x ? n.ys.push(0) : (n.ys.push(t.readShort(r, a)), a += 2);
      }
      for (var g = 0, v = 0, o = 0; o < c; o++)
        g += n.xs[o], v += n.ys[o], n.xs[o] = g, n.ys[o] = v;
    } else
      n.parts = [];
    return n;
  }
};
typeof module < "u" && module.exports ? module.exports = d : typeof window < "u" && (window.Typr = d);
class J {
  /**
   * Extracts all available characters from a font's cmap tables.
   * @param font The parsed font object from Typr
   * @returns Array of unique character strings
   */
  extractCharacters(e) {
    var r;
    const t = [];
    return (r = e == null ? void 0 : e.cmap) != null && r.tables ? (e.cmap.tables.forEach((i) => {
      if (i.format === 4) {
        const a = this._extractCharactersFromFormat4Table(i);
        t.push(...a);
      } else if (i.format === 12) {
        const a = this._extractCharactersFromFormat12Table(i);
        t.push(...a);
      }
    }), [...new Set(t)]) : [];
  }
  /**
   * Extracts characters from a Format 4 cmap table (Basic Multilingual Plane).
   * @param table The Format 4 cmap table
   * @returns Array of character strings
   */
  _extractCharactersFromFormat4Table(e) {
    const t = [];
    if (!e.startCount || !e.endCount || !e.idRangeOffset || !e.idDelta)
      return t;
    for (let r = 0; r < e.startCount.length; r++) {
      const i = e.startCount[r], a = e.endCount[r];
      if (!(i === 65535 && a === 65535)) {
        for (let n = i; n <= a; n++)
          if (this._calculateGlyphIndexFormat4(e, n, r) > 0) {
            const h = String.fromCodePoint(n);
            t.push(h);
          }
      }
    }
    return t;
  }
  /**
   * Extracts characters from a Format 12 cmap table (Extended Unicode ranges).
   * @param table The Format 12 cmap table
   * @returns Array of character strings
   */
  _extractCharactersFromFormat12Table(e) {
    const t = [];
    if (!e.groups)
      return t;
    for (let r = 0; r < e.groups.length; r += 3) {
      const i = e.groups[r], a = e.groups[r + 1], n = e.groups[r + 2];
      for (let o = i; o <= a; o++)
        if (n + (o - i) > 0) {
          const c = String.fromCodePoint(o);
          t.push(c);
        }
    }
    return t;
  }
  /**
   * Calculates the glyph index for a character in a Format 4 cmap table.
   * @param table The Format 4 cmap table
   * @param codePoint The Unicode code point
   * @param rangeIndex The index of the character range
   * @returns The glyph index, or 0 if not found
   */
  _calculateGlyphIndexFormat4(e, t, r) {
    if (e.idRangeOffset[r] === 0)
      return t + e.idDelta[r] & 65535;
    {
      const i = e.idRangeOffset[r] / 2 + (t - e.startCount[r]) - (e.startCount.length - r);
      if (i >= 0 && e.glyphIdArray && i < e.glyphIdArray.length) {
        const a = e.glyphIdArray[i];
        if (a !== 0)
          return a + e.idDelta[r] & 65535;
      }
    }
    return 0;
  }
  /**
   * Filters out problematic characters that might cause rendering issues.
   * @param characters Array of character strings to filter
   * @returns Filtered array of character strings
   */
  filterProblematicCharacters(e) {
    return e.filter((t) => this._isValidCharacter(t));
  }
  /**
   * Checks if a character is valid for rendering.
   * @param char The character to check
   * @returns True if the character is valid, false otherwise
   */
  _isValidCharacter(e) {
    const t = e.codePointAt(0) || 0;
    return !(t >= 0 && t <= 31 && t !== 9 && t !== 10 && t !== 13 || t >= 127 && t <= 159);
  }
}
class K {
  /**
   * Creates a new TextureAtlasCreation instance.
   * @param renderer The WebGL renderer instance
   */
  constructor(e) {
    l(this, "_textureCanvas");
    l(this, "_textureContext");
    l(this, "_renderer");
    this._renderer = e, this._textureCanvas = document.createElement("canvas"), this._textureContext = this._textureCanvas.getContext("2d", { willReadFrequently: !0, alpha: !1 });
  }
  /**
   * Creates a texture atlas from the given characters.
   * @param characters Array of TextmodeCharacter objects
   * @param maxGlyphDimensions Maximum dimensions of glyphs
   * @param fontSize Font size for rendering
   * @param fontFamilyName Font family name to use
   * @returns Object containing framebuffer, columns, and rows
   */
  createTextureAtlas(e, t, r, i) {
    const a = e.length, n = Math.ceil(Math.sqrt(a)), o = Math.ceil(a / n), h = t.width * n, c = t.height * o;
    this._setupCanvas(h, c, r, i), this._renderCharactersToCanvas(e, t, n, r), this._applyBlackWhiteThreshold();
    const u = this._renderer.createFramebuffer(h, c, { filter: "nearest" });
    return u.update(this._textureCanvas), {
      framebuffer: u,
      columns: n,
      rows: o
    };
  }
  /**
   * Sets up the canvas for rendering.
   * @param width Canvas buffer width
   * @param height Canvas buffer height
   * @param fontSize Font size
   * @param fontFamilyName Font family name
   * @param logicalWidth Logical width for scaling context
   * @param logicalHeight Logical height for scaling context
   */
  _setupCanvas(e, t, r, i) {
    this._textureCanvas.width = e, this._textureCanvas.height = t, this._textureCanvas.style.width = e + "px", this._textureCanvas.style.height = e + "px", this._textureContext.imageSmoothingEnabled = !1, this._textureCanvas.style.imageRendering = "pixelated", this._textureContext.fillStyle = "black", this._textureContext.fillRect(0, 0, e, t), this._textureContext.font = `${r}px ${i}`, this._textureContext.textBaseline = "top", this._textureContext.textAlign = "left", this._textureContext.fillStyle = "white";
  }
  /**
   * Renders all characters to the canvas in a grid layout.
   * @param characters Array of characters to render
   * @param maxGlyphDimensions Maximum glyph dimensions
   * @param textureColumns Number of columns in the texture
   * @param fontSize Font size
   */
  _renderCharactersToCanvas(e, t, r, i) {
    for (let a = 0; a < e.length; a++) {
      const n = a % r, o = Math.floor(a / r), h = n * t.width + t.width * 0.5, c = o * t.height + t.height * 0.5, u = Math.round(h - t.width * 0.5), f = Math.round(c - i * 0.5);
      this._textureContext.fillText(e[a].character, u, f);
    }
  }
  /**
   * Applies a black and white threshold filter to the canvas.
   * This converts antialiased grayscale pixels to pure black or white,
   * ensuring crisp text rendering suitable for NEAREST texture filtering.
   * @param threshold Threshold value (0-255) for black/white conversion
   */
  _applyBlackWhiteThreshold(e = 128) {
    const t = this._textureContext.getImageData(0, 0, this._textureCanvas.width, this._textureCanvas.height), r = t.data;
    for (let i = 0; i < r.length; i += 4) {
      const a = 0.299 * r[i] + 0.587 * r[i + 1] + 0.114 * r[i + 2], n = e + 32, o = a > n ? 255 : 0;
      r[i] = o, r[i + 1] = o, r[i + 2] = o;
    }
    this._textureContext.putImageData(t, 0, 0);
  }
}
class ee {
  /**
   * Creates a new MetricsCalculation instance.
   */
  constructor() {
    l(this, "_tempCanvas");
    l(this, "_tempContext");
    this._tempCanvas = document.createElement("canvas"), this._tempContext = this._tempCanvas.getContext("2d");
  }
  /**
   * Calculates the maximum glyph dimensions for a given set of characters.
   * @param characters Array of character strings
   * @param fontSize Font size to use for measurement
   * @param fontFamilyName Font family name
   * @param fontFace FontFace object (optional, for validation)
   * @returns Object containing width and height dimensions
   */
  calculateMaxGlyphDimensions(e, t, r) {
    this._tempContext.font = `${t}px ${r}`;
    let i = 0, a = 0;
    for (const n of e) {
      const o = this._tempContext.measureText(n), h = o.width, c = o.actualBoundingBoxAscent + o.actualBoundingBoxDescent;
      h > 0 && (i = Math.max(i, h), a = Math.max(a, c));
    }
    return {
      width: Math.ceil(i),
      height: Math.ceil(a)
    };
  }
}
class te {
  /**
   * Creates TextmodeCharacter objects with unique color assignments.
   * @param characters Array of character strings
   * @param font The parsed font object from Typr
   * @returns Array of TextmodeCharacter objects with colors
   */
  createCharacterObjects(e, t) {
    return e.map((r, i) => {
      const a = r.codePointAt(0) || 0, n = this._generateCharacterColor(i);
      let o = 0;
      if (t.hmtx && t.hmtx.aWidth) {
        const h = this._getGlyphIndex(t, a);
        h > 0 && t.hmtx.aWidth[h] !== void 0 && (o = t.hmtx.aWidth[h]);
      }
      return {
        character: r,
        unicode: a,
        color: n,
        advanceWidth: o
      };
    });
  }
  /**
   * Gets the glyph index for a given Unicode code point in a Typr.js font
   * This is a simplified version for advance width lookup only
   * @param fontData The Typr.js font data
   * @param codePoint The Unicode code point to look up
   * @returns The glyph index, or 0 if not found
   */
  _getGlyphIndex(e, t) {
    const r = e.cmap;
    if (!r || !r.tables) return 0;
    for (const i of r.tables)
      if (i.format === 4) {
        for (let a = 0; a < i.startCount.length; a++)
          if (t >= i.startCount[a] && t <= i.endCount[a]) {
            if (i.idRangeOffset[a] === 0)
              return t + i.idDelta[a] & 65535;
            {
              const n = i.idRangeOffset[a] / 2 + (t - i.startCount[a]) - (i.startCount.length - a);
              if (n >= 0 && n < i.glyphIdArray.length) {
                const o = i.glyphIdArray[n];
                if (o !== 0)
                  return o + i.idDelta[a] & 65535;
              }
            }
          }
      }
    return 0;
  }
  /**
   * Generates a unique RGB color for a character based on its index.
   * @param index The index of the character
   * @returns RGB color as a tuple [r, g, b]
   */
  _generateCharacterColor(e) {
    const t = e % 256, r = Math.floor(e / 256) % 256, i = Math.floor(e / 65536) % 256;
    return [t, r, i];
  }
  /**
   * Gets the color for a specific character.
   * @param character The character to get the color for
   * @param characters Array of TextmodeCharacter objects
   * @returns RGB color as a tuple [r, g, b], or [0, 0, 0] if not found
   */
  getCharacterColor(e, t) {
    if (!p.validate(
      typeof e == "string" && e.length === 1,
      "Character must be a single character string.",
      { method: "getCharacterColor", providedValue: e }
    ))
      return [0, 0, 0];
    const r = t.find((i) => i.character === e);
    return r ? r.color : [0, 0, 0];
  }
  /**
   * Gets colors for multiple characters.
   * @param characterString String of characters to get colors for
   * @param characters Array of TextmodeCharacter objects
   * @returns Array of RGB colors for each character
   */
  getCharacterColors(e, t) {
    return p.validate(
      typeof e == "string" && e.length > 0,
      "Characters must be a string with at least one character.",
      { method: "getCharacterColors", providedValue: e }
    ) ? e.split("").map((r) => this.getCharacterColor(r, t) || [0, 0, 0]) : [[0, 0, 0]];
  }
}
class re {
  /**
   * Creates a new TextmodeFont instance.
   * @param renderer Renderer instance for texture creation
   * @param fontSize Font size to use for the texture atlas
   * @ignore
   */
  constructor(e, t = 16) {
    l(this, "_font");
    l(this, "_characters", []);
    l(this, "_fontFramebuffer");
    l(this, "_fontSize", 16);
    l(this, "_textureColumns", 0);
    l(this, "_textureRows", 0);
    l(this, "_maxGlyphDimensions", { width: 0, height: 0 });
    l(this, "_fontFace");
    l(this, "_fontFamilyName", "UrsaFont");
    // Component classes
    l(this, "_characterExtractor");
    l(this, "_textureAtlas");
    l(this, "_metricsCalculator");
    l(this, "_characterColorMapper");
    this._fontSize = t, this._characterExtractor = new J(), this._textureAtlas = new K(e), this._metricsCalculator = new ee(), this._characterColorMapper = new te();
  }
  /**
   * Initializes the font manager by loading the font and creating the texture atlas.
   * @param fontSource Optional URL to load a custom font. If not provided, uses embedded font (full builds only).
   * @returns Promise that resolves when initialization is complete
   * @ignore
   */
  async initialize(e) {
    let t;
    if (e) {
      const r = await fetch(e);
      if (!r.ok)
        throw new b(`Failed to load font file: ${r.status} ${r.statusText}`);
      t = await r.arrayBuffer();
    } else
      throw new b("Embedded font not available. This appears to be a minified build - please provide `fontSource`.");
    await this._loadFontFace(t), this._font = d.parse(t)[0], await this._initializeFont();
  }
  /**
   * Sets the font size for rendering.
   * @param size The font size to set. If undefined, returns the current font size.
   * @ignore
   */
  setFontSize(e) {
    if (e === void 0) return this._fontSize;
    this._fontSize = e, this._maxGlyphDimensions = this._metricsCalculator.calculateMaxGlyphDimensions(
      this._characters.map((r) => r.character),
      this._fontSize,
      this._fontFamilyName
    );
    const t = this._textureAtlas.createTextureAtlas(
      this._characters,
      this._maxGlyphDimensions,
      this._fontSize,
      this._fontFamilyName
    );
    this._fontFramebuffer = t.framebuffer, this._textureColumns = t.columns, this._textureRows = t.rows;
  }
  /**
   * Loads a new font from a file path.
   * @param fontPath Path to the .otf or .ttf font file
   * @returns Promise that resolves when font loading is complete
   * @ignore
   */
  async loadFont(e) {
    try {
      const t = await fetch(e);
      if (!t.ok)
        throw new b(`Failed to load font file: ${t.status} ${t.statusText}`);
      const r = await t.arrayBuffer();
      await this._loadFontFace(r);
      const i = d.parse(r);
      if (!i || i.length === 0)
        throw new Error("Failed to parse font file");
      this._font = i[0], await this._initializeFont();
    } catch (t) {
      throw new b(`Failed to load font: ${t instanceof Error ? t.message : "Unknown error"}`, t);
    }
  }
  /**
   * Loads a FontFace from a font buffer.
   * @param fontBuffer ArrayBuffer containing font data
   */
  async _loadFontFace(e) {
    const t = Date.now();
    this._fontFamilyName = this._fontFamilyName === "UrsaFont" ? "UrsaFont" : `CustomFont_${t}`, this._fontFace = new FontFace(this._fontFamilyName, e), await this._fontFace.load(), document.fonts.add(this._fontFace);
  }
  /**
   * Initializes all font-dependent properties using the component classes.
   */
  async _initializeFont() {
    const e = this._characterExtractor.extractCharacters(this._font), t = this._characterExtractor.filterProblematicCharacters(e);
    this._characters = this._characterColorMapper.createCharacterObjects(t, this._font), this._maxGlyphDimensions = this._metricsCalculator.calculateMaxGlyphDimensions(
      t,
      this._fontSize,
      this._fontFamilyName
    );
    const r = this._textureAtlas.createTextureAtlas(
      this._characters,
      this._maxGlyphDimensions,
      this._fontSize,
      this._fontFamilyName
    );
    this._fontFramebuffer = r.framebuffer, this._textureColumns = r.columns, this._textureRows = r.rows;
  }
  /**
   * Get the color associated with a character.
   * @param character The character to get the color for.
   * @returns The RGB color as an array `[r, g, b]`.
   */
  getCharacterColor(e) {
    return this._characterColorMapper.getCharacterColor(e, this._characters);
  }
  /**
   * Get the colors associated with a string of characters.
   * @param characters The string of characters to get colors for.
   * @returns An array of RGB colors for each character in the string.
   * Each color is represented as an array `[r, g, b]`.
   */
  getCharacterColors(e) {
    return this._characterColorMapper.getCharacterColors(e, this._characters);
  }
  /**
   * Checks if all characters in the given string exist in the font.
   * @param str The string to check.
   * @returns `true` if all characters exist in the font, `false` otherwise.
   */
  hasAllCharacters(e) {
    if (typeof e != "string" || e.length === 0) return !1;
    const t = new Set(this._characters.map((r) => r.character));
    for (const r of e)
      if (!t.has(r)) return !1;
    return !0;
  }
  /** 
   * Returns the WebGL framebuffer containing the font texture atlas. 
   * @ignore
   */
  get fontFramebuffer() {
    return this._fontFramebuffer;
  }
  /** Returns the array of {@link TextmodeCharacter} objects in the font. */
  get characters() {
    return this._characters;
  }
  /** Returns the number of columns in the texture atlas. */
  get textureColumns() {
    return this._textureColumns;
  }
  /** Returns the number of rows in the texture atlas. */
  get textureRows() {
    return this._textureRows;
  }
  /** Returns the maximum dimensions of a glyph in the font. */
  get maxGlyphDimensions() {
    return this._maxGlyphDimensions;
  }
  /** Returns the font size used for rendering. */
  get fontSize() {
    return this._fontSize;
  }
  /** Returns the Typr.js font object. @ignore */
  get font() {
    return this._font;
  }
}
class ie {
  /**
   * Create a new grid instance.
   * @param canvas The canvas element used to determine the grid dimensions.
   * @param cellWidth The width of each cell in the grid.
   * @param cellHeight The height of each cell in the grid.
   * @ignore
   */
  constructor(e, t, r) {
    /** The number of columns in the grid. */
    l(this, "_cols");
    /** The number of rows in the grid. */
    l(this, "_rows");
    /** The total width of the grid in pixels. */
    l(this, "_width");
    /** The total height of the grid in pixels. */
    l(this, "_height");
    /** The offset to the outer canvas on the x-axis when centering the grid. */
    l(this, "_offsetX");
    /** The offset to the outer canvas on the y-axis when centering the grid. */
    l(this, "_offsetY");
    /** Whether the grid dimensions are fixed, or responsive based on the canvas dimensions. */
    l(this, "_fixedDimensions", !1);
    /** The canvas element used to determine the grid dimensions. */
    l(this, "_canvas");
    /** The width of each cell in the grid. */
    l(this, "_cellWidth");
    /** The height of each cell in the grid. */
    l(this, "_cellHeight");
    this._canvas = e, this._cellWidth = t, this._cellHeight = r, this.reset();
  }
  /**
   * Reset the grid to the default number of columns and rows based on the current canvas dimensions, and the grid cell dimensions.
   * @ignore
   */
  reset() {
    if (!this._fixedDimensions) {
      const e = this._canvas.getBoundingClientRect();
      let t = Math.round(e.width), r = Math.round(e.height);
      (t === 0 || r === 0) && (t = this._canvas.width, r = this._canvas.height), [this._cols, this._rows] = [Math.floor(t / this._cellWidth), Math.floor(r / this._cellHeight)];
    }
    this._resizeGrid();
  }
  /**
   * Reset the total grid width & height, and the offset to the outer canvas.
   */
  _resizeGrid() {
    const e = this._canvas.getBoundingClientRect();
    let t = Math.round(e.width), r = Math.round(e.height);
    (t === 0 || r === 0) && (t = this._canvas.width, r = this._canvas.height), this._width = this._cols * this._cellWidth, this._height = this._rows * this._cellHeight, this._offsetX = Math.floor((t - this._width) / 2), this._offsetY = Math.floor((r - this._height) / 2);
  }
  /**
   * Re-assign the grid cell dimensions and `reset()` the grid.
   * @param newCellWidth The new cell width.
   * @param newCellHeight The new cell height.
   * @ignore
   */
  resizeCellPixelDimensions(e, t) {
    [this._cellWidth, this._cellHeight] = [e, t], this.reset();
  }
  /**
   * Re-assign the grid dimensions and resize the grid. 
   * 
   * Calling this method makes the grid dimensions fixed, meaning they will not automatically resize based on the canvas dimensions.
   * @param newCols The new number of columns.
   * @param newRows The new number of rows.
   * @ignore
   */
  resizeGridDimensions(e, t) {
    this._fixedDimensions = !0, [this._cols, this._rows] = [e, t], this._resizeGrid();
  }
  /**
   * Make the grid dimensions flexible again, and `reset()` the grid.
   * @ignore
   */
  resetGridDimensions() {
    this._fixedDimensions = !1, this.reset();
  }
  /**
   * Update the canvas used by the grid, and reset the grid dimensions.
   * @param canvas The new canvas element to use for the grid.
   * @ignore
   */
  resize() {
    this._fixedDimensions ? this._resizeGrid() : this.reset();
  }
  /**
   * Gets or sets whether the grid dimensions *(columns and rows)* are fixed or responsive based on the canvas dimensions.
   * @param value Optional. `true` to make the grid dimensions fixed, or `false` to make them responsive. If not provided, returns the current state.
   * @returns If no parameter is provided, returns `true` if the grid dimensions are fixed, or `false` if they are responsive.
   * @ignore
   */
  fixedDimensions(e) {
    if (e === void 0)
      return this._fixedDimensions;
    this._fixedDimensions = e;
  }
  /** Returns the width of each cell in the grid. */
  get cellWidth() {
    return this._cellWidth;
  }
  /** Returns the height of each cell in the grid. */
  get cellHeight() {
    return this._cellHeight;
  }
  /** Returns the number of columns in the grid. */
  get cols() {
    return this._cols;
  }
  /** Returns the number of rows in the grid. */
  get rows() {
    return this._rows;
  }
  /** Returns the total width of the grid. */
  get width() {
    return this._width;
  }
  /** Returns the total height of the grid. */
  get height() {
    return this._height;
  }
  /** Returns the offset to the outer canvas borders on the x-axis when centering the grid. */
  get offsetX() {
    return this._offsetX;
  }
  /** Returns the offset to the outer canvas borders on the y-axis when centering the grid. */
  get offsetY() {
    return this._offsetY;
  }
}
class ae {
  constructor(e, t = !1, r = {}) {
    l(this, "_canvas");
    l(this, "captureSource");
    l(this, "_isStandalone");
    this.captureSource = e, this._isStandalone = t, this._canvas = this.createCanvas(r.width, r.height);
  }
  createCanvas(e, t) {
    var i;
    const r = document.createElement("canvas");
    if (r.className = "textmodeCanvas", this._isStandalone)
      r.width = e || 800, r.height = t || 600, r.style.width = e + "px", r.style.height = t + "px", document.body.appendChild(r);
    else {
      const a = this.captureSource.getBoundingClientRect();
      let n = Math.round(a.width), o = Math.round(a.height);
      if (this.captureSource instanceof HTMLVideoElement) {
        const u = this.captureSource;
        (n === 0 || o === 0) && u.videoWidth > 0 && u.videoHeight > 0 && (n = u.videoWidth, o = u.videoHeight);
      }
      r.width = n, r.height = o, r.style.width = n + "px", r.style.height = o + "px", r.style.position = "absolute", r.style.pointerEvents = "none";
      const h = window.getComputedStyle(this.captureSource);
      let c = parseInt(h.zIndex || "0", 10);
      isNaN(c) && (c = 0), r.style.zIndex = (c + 1).toString(), this.positionOverlayCanvas(r), (i = this.captureSource.parentNode) == null || i.insertBefore(r, this.captureSource.nextSibling);
    }
    return r;
  }
  positionOverlayCanvas(e) {
    const t = this.captureSource.getBoundingClientRect();
    let r = this.captureSource.offsetParent;
    if (r && r !== document.body) {
      const i = r.getBoundingClientRect();
      e.style.top = t.top - i.top + "px", e.style.left = t.left - i.left + "px";
    } else
      e.style.top = t.top + window.scrollY + "px", e.style.left = t.left + window.scrollX + "px";
  }
  resize(e, t) {
    if (this._isStandalone)
      this._canvas.width = e ?? this._canvas.width, this._canvas.height = t ?? this._canvas.height, this._canvas.style.width = (e ?? this._canvas.width) + "px", this._canvas.style.height = (t ?? this._canvas.height) + "px";
    else {
      const r = this.captureSource.getBoundingClientRect();
      let i = Math.round(r.width), a = Math.round(r.height);
      if (this.captureSource instanceof HTMLVideoElement) {
        const n = this.captureSource;
        (i === 0 || a === 0) && n.videoWidth > 0 && n.videoHeight > 0 && (i = n.videoWidth, a = n.videoHeight);
      }
      this._canvas.width = i, this._canvas.height = a, this._canvas.style.width = i + "px", this._canvas.style.height = a + "px", this.positionOverlayCanvas(this._canvas);
    }
  }
  /**
   * Get the WebGL context for the overlay canvas
   */
  getWebGLContext() {
    const e = {
      alpha: !0,
      premultipliedAlpha: !1,
      preserveDrawingBuffer: !0,
      antialias: !1,
      depth: !1,
      stencil: !1,
      powerPreference: "high-performance"
    }, t = this._canvas.getContext("webgl2", e) || this._canvas.getContext("webgl", e);
    if (!t)
      throw new b("WebGL context could not be created. Ensure your browser supports WebGL.");
    return t;
  }
  // Getters
  get canvas() {
    return this._canvas;
  }
  get width() {
    return this._canvas.width;
  }
  get height() {
    return this._canvas.height;
  }
}
class U {
  /**
   * Creates a new TextmodeConverter instance.
   * @param renderer Renderer instance for texture creation
   * @param fontManager Font manager for character extraction and color mapping
   * @param grid Grid instance for managing textmode layout
   * @param options Additional options for the converter
   * @ignore
   */
  constructor(e, t, r, i = {}) {
    l(this, "renderer");
    l(this, "fontManager");
    l(this, "grid");
    l(this, "_characterFramebuffer");
    l(this, "_primaryColorFramebuffer");
    l(this, "_secondaryColorFramebuffer");
    l(this, "_rotationFramebuffer");
    l(this, "_transformFramebuffer");
    l(this, "_options");
    this.renderer = e, this.fontManager = t, this.grid = r, this._options = i, this._characterFramebuffer = this.renderer.createFramebuffer(this.grid.cols, this.grid.rows), this._primaryColorFramebuffer = this.renderer.createFramebuffer(this.grid.cols, this.grid.rows), this._secondaryColorFramebuffer = this.renderer.createFramebuffer(this.grid.cols, this.grid.rows), this._rotationFramebuffer = this.renderer.createFramebuffer(this.grid.cols, this.grid.rows), this._transformFramebuffer = this.renderer.createFramebuffer(this.grid.cols, this.grid.rows);
  }
  /**
   * Resizes all internal framebuffers to match the grid dimensions.
   * @ignore
   */
  resize() {
    this._characterFramebuffer.resize(this.grid.cols, this.grid.rows), this._primaryColorFramebuffer.resize(this.grid.cols, this.grid.rows), this._secondaryColorFramebuffer.resize(this.grid.cols, this.grid.rows), this._rotationFramebuffer.resize(this.grid.cols, this.grid.rows), this._transformFramebuffer.resize(this.grid.cols, this.grid.rows);
  }
  /**
   * Enables or disables the converter.
   * @param enabled Whether to enable or disable the converter.
   */
  enabled(e) {
    this._options.enabled = e;
  }
  /**
   * Enables the converter.
   */
  enable() {
    this.enabled(!0);
  }
  /**
   * Disables the converter.
   */
  disable() {
    this.enabled(!1);
  }
  /** Returns the framebuffer containing character data. */
  get characterFramebuffer() {
    return this._characterFramebuffer;
  }
  /** Returns the framebuffer containing primary color data. */
  get primaryColorFramebuffer() {
    return this._primaryColorFramebuffer;
  }
  /** Returns the framebuffer containing secondary color data. */
  get secondaryColorFramebuffer() {
    return this._secondaryColorFramebuffer;
  }
  /** Returns the framebuffer containing rotation data. */
  get rotationFramebuffer() {
    return this._rotationFramebuffer;
  }
  /** Returns the framebuffer containing transformation data. */
  get transformFramebuffer() {
    return this._transformFramebuffer;
  }
  /** Returns the renderer used by this converter. */
  get options() {
    return this._options;
  }
}
class ne {
  /**
   * Create a new color palette instance.
   * @param renderer The renderer instance.
   * @param colors The RGB colors to store as [r, g, b] arrays where values are 0-255.
   */
  constructor(e, t) {
    /** The framebuffer used to store the color palette. */
    l(this, "_framebuffer");
    l(this, "_renderer");
    l(this, "_colors");
    this._renderer = e, this._colors = t;
    const r = Math.max(this._colors.length, 1);
    this._framebuffer = this._renderer.createFramebuffer(r, 1), this._updateFramebuffer();
  }
  /**
   * Update the framebuffer with the currently selected colors.
   */
  _updateFramebuffer() {
    if (!this._framebuffer) return;
    const e = Math.max(this._colors.length, 1), t = 1;
    this._framebuffer.width !== e && this._framebuffer.resize(e, t);
    const r = new Uint8Array(e * t * 4);
    for (let i = 0; i < e; i++) {
      const a = i < this._colors.length ? this._colors[i] : [0, 0, 0], n = i * 4;
      r[n] = a[0], r[n + 1] = a[1], r[n + 2] = a[2], r[n + 3] = 255;
    }
    this._framebuffer.updatePixels(r, e, t);
  }
  /**
   * Sets the colors of the palette and updates the framebuffer.
   * @param newColors The new RGB colors to set as [r, g, b] arrays.
   */
  setColors(e) {
    this._colors = e, this._updateFramebuffer();
  }
  /**
   * Get the colors of the palette.
   */
  get colors() {
    return this._colors;
  }
  /**
   * Get the framebuffer containing the colors of the palette.
   */
  get framebuffer() {
    return this._framebuffer;
  }
  /**
   * Get the texture from the framebuffer for use in shaders.
   */
  get texture() {
    return this._framebuffer.texture;
  }
}
class G extends U {
  constructor(t, r, i, a = {}) {
    super(t, r, i, a);
    l(this, "palette");
    this.palette = new ne(this.renderer, this.fontManager.getCharacterColors(" .:-=+*%@#"));
  }
  /**
   * Sets the characters used for mapping.
   * @param characters The characters to use for mapping, usually ordered from darkest to brightest.
   */
  characters(t) {
    p.validate(
      this.fontManager.hasAllCharacters(t),
      "One or more characters do not exist in the current font.",
      { method: "characters", providedValue: t }
    ) && (this._options.characters = t, this.palette.setColors(this.fontManager.getCharacterColors(t)));
  }
  /**
   * Sets the color of the characters affected by the converter.
   * This is only used when `characterColorMode` is set to `'fixed'`.
   * @param r Red component (0-255).
   * @param g Green component (0-255).
   * @param b Blue component (0-255).
   * @param a Alpha component (0-255).
   */
  characterColor(t, r = t, i = t, a = 255) {
    p.validate(
      [t, r, i, a].every((n) => n >= 0 && n <= 255),
      "Character color values must be between 0 and 255",
      { method: "characterColor", providedValues: { r: t, g: r, b: i, a } }
    ) && (this._options.characterColor = [t, r, i, a]);
  }
  /**
   * Sets the character color mode.
   * - `'sampled'`: Uses sampled colors from the source texture.
   * - `'fixed'`: Uses a fixed color set by `characterColor()`.
   * @param mode The color mode to use for characters.
   */
  characterColorMode(t) {
    p.validate(
      ["sampled", "fixed"].includes(t),
      "Invalid character color mode. Must be 'sampled' or 'fixed'.",
      { method: "characterColorMode", providedValue: t }
    ) && (this._options.characterColorMode = t);
  }
  /**
   * Sets the cell color for all cells affected by the converter.
   * This is only used when `cellColorMode` is set to `'fixed'`.
   * @param r Red component (0-255).
   * @param g Green component (0-255).
   * @param b Blue component (0-255).
   * @param a Alpha component (0-255).
   */
  cellColor(t, r = t, i = t, a = 255) {
    p.validate(
      [t, r, i, a].every((n) => n >= 0 && n <= 255),
      "Cell color values must be between 0 and 255",
      { method: "cellColor", providedValues: { r: t, g: r, b: i, a } }
    ) && (this._options.cellColor = [t, r, i, a]);
  }
  /**
   * Sets the cell color mode.
   * - `'sampled'`: Uses sampled colors from the source texture.
   * - `'fixed'`: Uses a fixed color set via {@link cellColor}.
   * @param mode The color mode to use for background cells.
   */
  cellColorMode(t) {
    p.validate(
      ["sampled", "fixed"].includes(t),
      "Invalid cell color mode. Must be 'sampled' or 'fixed'.",
      { method: "cellColorMode", providedValue: t }
    ) && (this._options.cellColorMode = t);
  }
  /**
   * Swaps the character and cell color.
   * @param invert If `true`, the character color becomes the cell color and vice versa.
   */
  invert(t) {
    p.validate(
      typeof t == "boolean" || typeof t == "number" && Number.isInteger(t),
      "Invert must be a boolean value or an integer (0 for false, any other number for true).",
      { method: "invert", providedValue: t }
    ) && (this._options.invert = !!t);
  }
  /**
   * Sets the rotation angle for the characters.
   * @param angle The rotation angle in degrees.
   */
  rotation(t) {
    if (!p.validate(
      typeof t == "number",
      "Rotation angle must be a number.",
      { method: "rotation", providedValue: t }
    ))
      return;
    t = t % 360, t < 0 && (t += 360);
    const r = t * 255 / 360, i = Math.floor(r) / 255, a = Math.round(r - i);
    this._options.rotation = [i, a, 0, 1];
  }
  /**
   * Flips the characters horizontally.
   * @param flip If `true`, characters are flipped horizontally. If `false`, no flip is applied.
   */
  flipHorizontally(t) {
    p.validate(
      typeof t == "boolean" || typeof t == "number" && Number.isInteger(t),
      "Flip horizontally must be a boolean value or an integer (0 for false, any other number for true).",
      { method: "flipHorizontally", providedValue: t }
    ) && (this._options.flipHorizontally = !!t);
  }
  /**
   * Flips the characters vertically.
   * @param flip If `true`, characters are flipped vertically. If `false`, no flip is applied.
   */
  flipVertically(t) {
    p.validate(
      typeof t == "boolean" || typeof t == "number" && Number.isInteger(t),
      "Flip vertically must be a boolean value or an integer (0 for false, any other number for true).",
      { method: "flipVertically", providedValue: t }
    ) && (this._options.flipVertically = !!t);
  }
}
var se = "precision lowp float;uniform sampler2D u_sketchTexture;uniform vec2 u_gridCellDimensions;uniform vec2 u_brightnessRange;varying vec2 v_uv;void main(){vec2 cellCenter=(floor(v_uv*u_gridCellDimensions)+vec2(0.5))/u_gridCellDimensions;vec4 color=texture2D(u_sketchTexture,cellCenter);float brightness=dot(color.rgb,vec3(0.299,0.587,0.114));float brightnessValue=brightness*255.0;if(brightnessValue>=u_brightnessRange.x&&brightnessValue<=u_brightnessRange.y){gl_FragColor=color;}else{gl_FragColor=vec4(0.0);}}", oe = "precision lowp float;uniform sampler2D u_sampleTexture;uniform vec4 u_fillColor;uniform bool u_useFixedColor;varying vec2 v_uv;void main(){vec4 sampleColor=texture2D(u_sampleTexture,v_uv);if(sampleColor.a>0.0){if(u_useFixedColor){gl_FragColor=u_fillColor;}else{gl_FragColor=sampleColor;}}else{gl_FragColor=vec4(0.0);}}", le = "precision lowp float;uniform sampler2D u_sampleTexture;uniform bool u_invert;uniform bool u_flipHorizontally;uniform bool u_flipVertically;varying vec2 v_uv;void main(){vec4 sampleColor=texture2D(u_sampleTexture,v_uv);if(sampleColor.a>0.0){float invertValue=u_invert ? 1.0 : 0.0;float flipHValue=u_flipHorizontally ? 1.0 : 0.0;float flipVValue=u_flipVertically ? 1.0 : 0.0;gl_FragColor=vec4(invertValue,flipHValue,flipVValue,1.0);}else{gl_FragColor=vec4(0.0);}}", he = "precision lowp float;uniform sampler2D u_sampleTexture;uniform vec4 u_rotation;varying vec2 v_uv;void main(){vec4 sampleColor=texture2D(u_sampleTexture,v_uv);if(sampleColor.a>0.0){gl_FragColor=u_rotation;}else{gl_FragColor=vec4(0.0);}}", ce = "precision lowp float;uniform sampler2D u_colorSampleFramebuffer;uniform sampler2D u_charPaletteTexture;uniform vec2 u_charPaletteSize;uniform vec2 u_brightnessRange;varying vec2 v_uv;void main(){vec4 color=texture2D(u_colorSampleFramebuffer,v_uv);if(color.a==0.0){gl_FragColor=vec4(0.0);return;}float brightness=dot(color.rgb,vec3(0.299,0.587,0.114))*255.0;vec2 range=u_brightnessRange;if(brightness<range.x||brightness>range.y){gl_FragColor=vec4(0.0);return;}float t=(brightness-range.x)/(range.y-range.x);float idx=clamp(floor(t*u_charPaletteSize.x),0.0,u_charPaletteSize.x-1.0);vec3 charColor=texture2D(u_charPaletteTexture,vec2((idx+0.5)/u_charPaletteSize.x,0.0)).rgb;gl_FragColor=vec4(charColor,1.0);}";
const ue = {
  /** Enable/disable the renderer */
  enabled: !0,
  /** Characters used for brightness mapping (from darkest to brightest) */
  characters: " .:-=+*%@#",
  /** Color of the ASCII characters. Only used when `characterColorMode` is set to `fixed` */
  characterColor: [255, 255, 255, 255],
  /** Character color mode */
  characterColorMode: "sampled",
  /** Cell background color. Only used when `characterColorMode` is set to `fixed` */
  cellColor: [0, 0, 0, 255],
  /** Background color mode */
  cellColorMode: "fixed",
  /** Swap the cells ASCII character colors with it's cell background colors */
  invert: !1,
  /** Rotation angle of all characters in the grid in degrees */
  rotation: [0, 0, 0, 255],
  /** Flip the ASCII characters horizontally */
  flipHorizontally: !1,
  /** Flip the ASCII characters vertically */
  flipVertically: !1,
  /** Range of brightness values to map to ASCII characters */
  brightnessRange: [0, 255]
};
class I extends G {
  /**
   * Creates a new TextmodeBrightnessConverter instance.
   * @param renderer Renderer instance for texture creation
   * @param fontManager Font manager for character extraction and color mapping
   * @param grid Grid manager for layout and positioning
   * @ignore
   */
  constructor(t, r, i) {
    super(t, r, i, { ...ue });
    l(this, "sampleShader");
    l(this, "colorFillShader");
    l(this, "charMappingShader");
    l(this, "transformFillShader");
    l(this, "rotationFillShader");
    l(this, "sampleFramebuffer");
    this.sampleShader = new y(t.context, T, se), this.colorFillShader = new y(t.context, T, oe), this.transformFillShader = new y(t.context, T, le), this.rotationFillShader = new y(t.context, T, he), this.charMappingShader = new y(t.context, T, ce), this.sampleFramebuffer = this.renderer.createFramebuffer(this.grid.cols, this.grid.rows);
  }
  convert(t) {
    this.sampleFramebuffer.begin(), this.renderer.clear(), this.renderer.shader(this.sampleShader), this.renderer.setUniform("u_sketchTexture", t), this.renderer.setUniform("u_gridCellDimensions", [this.grid.cols, this.grid.rows]), this.renderer.setUniform("u_brightnessRange", this._options.brightnessRange), this.renderer.rect(0, 0, this.grid.cols, this.grid.rows), this.sampleFramebuffer.end(), this._primaryColorFramebuffer.begin(), this.renderer.clear(), this.renderer.shader(this.colorFillShader), this.renderer.setUniform("u_sampleTexture", this.sampleFramebuffer.texture), this.renderer.setUniform("u_fillColor", this._options.characterColor), this.renderer.setUniform("u_useFixedColor", this._options.characterColorMode === "fixed"), this.renderer.rect(0, 0, this.grid.cols, this.grid.rows), this._primaryColorFramebuffer.end(), this._secondaryColorFramebuffer.begin(), this.renderer.clear(), this.renderer.shader(this.colorFillShader), this.renderer.setUniform("u_sampleTexture", this.sampleFramebuffer.texture), this.renderer.setUniform("u_fillColor", this._options.cellColor), this.renderer.setUniform("u_useFixedColor", this._options.cellColorMode === "fixed"), this.renderer.rect(0, 0, this.grid.cols, this.grid.rows), this._secondaryColorFramebuffer.end(), this._transformFramebuffer.begin(), this.renderer.clear(), this.renderer.shader(this.transformFillShader), this.renderer.setUniform("u_sampleTexture", this.sampleFramebuffer.texture), this.renderer.setUniform("u_invert", this._options.invert), this.renderer.setUniform("u_flipHorizontally", this._options.flipHorizontally), this.renderer.setUniform("u_flipVertically", this._options.flipVertically), this.renderer.rect(0, 0, this.grid.cols, this.grid.rows), this._transformFramebuffer.end(), this._rotationFramebuffer.begin(), this.renderer.clear(), this.renderer.shader(this.rotationFillShader), this.renderer.setUniform("u_sampleTexture", this.sampleFramebuffer.texture), this.renderer.setUniform("u_rotation", this._options.rotation), this.renderer.rect(0, 0, this.grid.cols, this.grid.rows), this._rotationFramebuffer.end(), this._characterFramebuffer.begin(), this.renderer.clear(0, 0, 0, 0), this.renderer.shader(this.charMappingShader), this.renderer.setUniform("u_colorSampleFramebuffer", this.sampleFramebuffer.texture), this.renderer.setUniform("u_charPaletteTexture", this.palette.texture), this.renderer.setUniform("u_charPaletteSize", [this.palette.colors.length, 1]), this.renderer.setUniform("u_brightnessRange", this._options.brightnessRange), this.renderer.rect(0, 0, this.grid.cols, this.grid.rows), this._characterFramebuffer.end();
  }
  resize() {
    super.resize(), this.sampleFramebuffer.resize(this.grid.cols, this.grid.rows);
  }
  /**
   * Sets the brightness range for ASCII character mapping.
   * 
   * Cells that sample outside this range are rendered as transparent.
   * 
   * @param range Array of two numbers `[min, max]`, where `min` is darkest and `max` is brightest.
   */
  brightnessRange(t) {
    p.validate(
      Array.isArray(t) && t.length === 2 && t.every((r) => typeof r == "number" && r >= 0 && r <= 255),
      "Brightness range must be an array of two numbers between 0 and 255.",
      { method: "brightnessRange", providedValue: t }
    ) && (this._options.brightnessRange = t);
  }
}
const Se = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TextmodeBrightnessConverter: I,
  TextmodeConverter: U,
  TextmodeFeatureConverter: G
}, Symbol.toStringTag, { value: "Module" }));
var de = "precision mediump float;uniform sampler2D u_characterTexture;uniform vec2 u_charsetDimensions;uniform sampler2D u_primaryColorTexture;uniform sampler2D u_secondaryColorTexture;uniform sampler2D u_transformTexture;uniform sampler2D u_asciiCharacterTexture;uniform sampler2D u_rotationTexture;uniform sampler2D u_captureTexture;uniform vec2 u_captureDimensions;uniform int u_backgroundMode;uniform vec2 u_gridCellDimensions;uniform vec2 u_gridPixelDimensions;mat2 rotate2D(float angle){float s=sin(angle);float c=cos(angle);return mat2(c,-s,s,c);}void main(){vec2 adjustedCoord=gl_FragCoord.xy/u_gridPixelDimensions;vec2 gridCoord=adjustedCoord*u_gridCellDimensions;vec2 cellCoord=floor(gridCoord);vec2 charIndexTexCoord=(cellCoord+0.5)/u_gridCellDimensions;vec4 primaryColor=texture2D(u_primaryColorTexture,charIndexTexCoord);vec4 secondaryColor=texture2D(u_secondaryColorTexture,charIndexTexCoord);vec4 transformColor=texture2D(u_transformTexture,charIndexTexCoord);bool isInverted=transformColor.r>0.5;bool flipHorizontal=transformColor.g>0.5;bool flipVertical=transformColor.b>0.5;vec4 encodedIndexVec=texture2D(u_asciiCharacterTexture,charIndexTexCoord);if(encodedIndexVec.a<0.01){gl_FragColor=(u_backgroundMode==0)? vec4(0.0):texture2D(u_captureTexture,gl_FragCoord.xy/u_captureDimensions);return;}int charIndex=int(encodedIndexVec.r*255.0+0.5)+int(encodedIndexVec.g*255.0+0.5)*256;int charCol=int(mod(float(charIndex),u_charsetDimensions.x));int charRow=charIndex/int(u_charsetDimensions.x);vec2 charCoord=vec2(charCol,charRow)/u_charsetDimensions;vec4 rotationColor=texture2D(u_rotationTexture,charIndexTexCoord);float scaledAngle=rotationColor.r*255.0+rotationColor.g;float rotationAngle=(scaledAngle*360.0/255.0)*0.017453292;vec2 fractionalPart=fract(gridCoord)-0.5;if(flipHorizontal)fractionalPart.x=-fractionalPart.x;if(flipVertical)fractionalPart.y=-fractionalPart.y;fractionalPart=rotate2D(rotationAngle)*fractionalPart+0.5;vec2 cellSize=1.0/u_charsetDimensions;vec2 texCoord=charCoord+fractionalPart*cellSize;vec2 cellMax=charCoord+cellSize;if(any(lessThan(texCoord,charCoord))||any(greaterThan(texCoord,cellMax))){gl_FragColor=isInverted ? primaryColor : secondaryColor;return;}vec4 charTexel=texture2D(u_characterTexture,texCoord);if(isInverted)charTexel.rgb=1.0-charTexel.rgb;gl_FragColor=mix(secondaryColor,primaryColor,charTexel);}";
class fe {
  /**
   * Creates an instance of TextmodeConversionPipeline.
   * @param renderer The renderer to use for the pipeline.
   * @param font The textmode font to use.
   * @param grid The textmode grid to use.
   * @ignore
   */
  constructor(e, t, r) {
    l(this, "renderer");
    l(this, "font");
    l(this, "grid");
    l(this, "converters");
    l(this, "_resultFramebuffer");
    l(this, "_asciiShader");
    l(this, "_characterFramebuffer");
    l(this, "_primaryColorFramebuffer");
    l(this, "_secondaryColorFramebuffer");
    l(this, "_rotationFramebuffer");
    l(this, "_transformFramebuffer");
    this.renderer = e, this.font = t, this.grid = r, this._asciiShader = this.renderer.createShader(T, de), this.converters = [
      { name: "brightness", converter: new I(e, t, r) },
      { name: "custom", converter: new U(e, t, r) }
    ], this._characterFramebuffer = this.renderer.createFramebuffer(r.cols, r.rows), this._primaryColorFramebuffer = this.renderer.createFramebuffer(r.cols, r.rows), this._secondaryColorFramebuffer = this.renderer.createFramebuffer(r.cols, r.rows), this._rotationFramebuffer = this.renderer.createFramebuffer(r.cols, r.rows), this._transformFramebuffer = this.renderer.createFramebuffer(r.cols, r.rows), this._resultFramebuffer = this.renderer.createFramebuffer(this.grid.width, this.grid.height);
  }
  /**
   * Performs the conversion process by applying all converters in the pipeline.
   * @param sourceFramebuffer The source framebuffer to convert.
   * @ignore
   */
  render(e) {
    for (const r of this.converters) {
      const i = r.converter;
      i.options.enabled && i instanceof G && i.convert(e);
    }
    const t = (r, i) => {
      r.begin(), this.renderer.clear();
      for (const a of this.converters) {
        const n = a.converter;
        n.options.enabled && this.renderer.image(i(n), 0, 0);
      }
      r.end();
    };
    t(this._characterFramebuffer, (r) => r.characterFramebuffer), t(this._primaryColorFramebuffer, (r) => r.primaryColorFramebuffer), t(this._secondaryColorFramebuffer, (r) => r.secondaryColorFramebuffer), t(this._rotationFramebuffer, (r) => r.rotationFramebuffer), t(this._transformFramebuffer, (r) => r.transformFramebuffer), this._resultFramebuffer.begin(), this.renderer.clear(), this.renderer.shader(this._asciiShader), this.renderer.setUniform("u_characterTexture", this.font.fontFramebuffer), this.renderer.setUniform("u_charsetDimensions", [this.font.textureColumns, this.font.textureRows]), this.renderer.setUniform("u_asciiCharacterTexture", this._characterFramebuffer.texture), this.renderer.setUniform("u_primaryColorTexture", this._primaryColorFramebuffer.texture), this.renderer.setUniform("u_secondaryColorTexture", this._secondaryColorFramebuffer.texture), this.renderer.setUniform("u_transformTexture", this._transformFramebuffer.texture), this.renderer.setUniform("u_rotationTexture", this._rotationFramebuffer.texture), this.renderer.setUniform("u_captureTexture", e.texture), this.renderer.setUniform("u_backgroundMode", !1), this.renderer.setUniform("u_captureDimensions", [e.width, e.height]), this.renderer.setUniform("u_gridCellDimensions", [this.grid.cols, this.grid.rows]), this.renderer.setUniform("u_gridPixelDimensions", [this.grid.width, this.grid.height]), this.renderer.rect(0, 0, this._resultFramebuffer.width, this._resultFramebuffer.height), this._resultFramebuffer.end();
  }
  /**
   * Get a specific converter by name.
   * @param name The name of the converter to retrieve.
   * @returns The requested `TextmodeConverter` instance.
   */
  get(e) {
    if (!p.validate(
      typeof e == "string" && e.length > 0,
      "Converter name must be a non-empty string.",
      { method: "converter", providedValue: e }
    ))
      return;
    const t = this.converters.find((i) => i.name === e), r = t == null ? void 0 : t.converter;
    if (p.validate(
      r instanceof U,
      `Converter "${e}" is not a valid TextmodeConverter.`,
      { method: "converter", providedValue: e, converterInstance: r }
    ))
      return r;
  }
  /**
   * Adds a new converter to the pipeline.
   * @param name A unique name for the converter.
   * @param type The type of converter to add. Can be either "brightness" or "custom".
   * @returns The newly created {@link TextmodeConverter} instance or `void` if the addition failed.
   */
  add(e, t) {
    if (!p.validate(
      typeof e == "string" && e.length > 0,
      "Converter name must be a non-empty string.",
      { method: "add", providedValue: e }
    ) || !p.validate(
      t === "brightness" || t === "custom",
      `Converter type must be either "brightness" or "custom". Provided: ${t}`,
      { method: "add", providedValue: t }
    ))
      return;
    let r;
    return t === "brightness" ? r = new I(this.renderer, this.font, this.grid) : r = new U(this.renderer, this.font, this.grid), this.converters.push({ name: e, converter: r }), r;
  }
  /**
  * Removes a converter from the pipeline by name or instance.
  * @param nameOrInstance The unique name of the converter or the converter instance to remove.
  * @returns `true` if the converter was successfully removed, `false` otherwise.
  */
  remove(e) {
    if (!p.validate(
      typeof e == "string" || e instanceof U,
      "Parameter must be either a string (converter name) or a TextmodeConverter instance.",
      { method: "remove", providedValue: e }
    ))
      return !1;
    let t = -1;
    if (typeof e == "string") {
      if (!p.validate(
        e.length > 0,
        "Converter name must be a non-empty string.",
        { method: "remove", providedValue: e }
      ))
        return !1;
      t = this.converters.findIndex((r) => r.name === e);
    } else
      t = this.converters.findIndex((r) => r.converter === e);
    return p.validate(
      t !== -1,
      typeof e == "string" ? `Converter with name "${e}" not found in pipeline.` : "Converter instance not found in pipeline.",
      { method: "remove", providedValue: e, convertersCount: this.converters.length }
    ) ? (this.converters.splice(t, 1), !0) : !1;
  }
  /**
   * Returns the framebuffer containing the textmode conversion result.
   */
  get texture() {
    return this._resultFramebuffer;
  }
  /**
   * Resizes all internal framebuffers.
   * @ignore
   */
  resize() {
    this._resultFramebuffer.resize(this.grid.width, this.grid.height), this._characterFramebuffer.resize(this.grid.cols, this.grid.rows), this._primaryColorFramebuffer.resize(this.grid.cols, this.grid.rows), this._secondaryColorFramebuffer.resize(this.grid.cols, this.grid.rows), this._rotationFramebuffer.resize(this.grid.cols, this.grid.rows), this._transformFramebuffer.resize(this.grid.cols, this.grid.rows);
    for (const e of this.converters)
      e.converter.resize();
  }
  /**
   * Checks if any converter in the pipeline is enabled.
   * @returns `true` if any converter is enabled, `false` otherwise.
   */
  hasEnabledConverters() {
    return this.converters.some((e) => e.converter.options.enabled);
  }
  /**
   * Disables all converters in the pipeline.
   */
  disable() {
    for (const e of this.converters)
      e.converter.disable();
  }
  /**
   * Enables all converters in the pipeline.
   */
  enable() {
    for (const e of this.converters)
      e.converter.enable();
  }
  /** Returns the character framebuffer containing the combined result of all converters. @ignore */
  get characterFramebuffer() {
    return this._characterFramebuffer;
  }
  /** Returns the primary color framebuffer containing the combined result of all converters. @ignore */
  get primaryColorFramebuffer() {
    return this._primaryColorFramebuffer;
  }
  /** Returns the secondary color framebuffer containing the combined result of all converters. @ignore */
  get secondaryColorFramebuffer() {
    return this._secondaryColorFramebuffer;
  }
  /** Returns the rotation framebuffer containing the combined result of all converters. @ignore */
  get rotationFramebuffer() {
    return this._rotationFramebuffer;
  }
  /** Returns the transform framebuffer containing the combined result of all converters. @ignore */
  get transformFramebuffer() {
    return this._transformFramebuffer;
  }
}
class P {
  /**
   * Extracts pixel data from all framebuffers needed for export
   * @param pipeline The conversion pipeline containing framebuffers
   * @returns Object containing all pixel data arrays
   */
  extractFramebufferData(e) {
    const t = e.get("brightness"), r = t == null ? void 0 : t.characterFramebuffer, i = t == null ? void 0 : t.primaryColorFramebuffer, a = t == null ? void 0 : t.secondaryColorFramebuffer, n = t == null ? void 0 : t.transformFramebuffer, o = t == null ? void 0 : t.rotationFramebuffer;
    return r == null || r.loadPixels(), i == null || i.loadPixels(), a == null || a.loadPixels(), n == null || n.loadPixels(), o == null || o.loadPixels(), {
      characterPixels: (r == null ? void 0 : r.pixels) || new Uint8Array(0),
      primaryColorPixels: (i == null ? void 0 : i.pixels) || new Uint8Array(0),
      secondaryColorPixels: (a == null ? void 0 : a.pixels) || new Uint8Array(0),
      transformPixels: (n == null ? void 0 : n.pixels) || new Uint8Array(0),
      rotationPixels: (o == null ? void 0 : o.pixels) || new Uint8Array(0)
    };
  }
  /**
   * Gets character index from character framebuffer pixels
   * @param characterPixels Character framebuffer pixel data
   * @param pixelIndex Index in the pixel array (already multiplied by 4 for RGBA)
   * @param charactersLength Total number of available characters
   * @returns Character index
   */
  getCharacterIndex(e, t) {
    const r = e[t], i = e[t + 1];
    return r + (i << 8);
  }
  /**
   * Converts raw pixel data to RGBA color object
   * @param pixels Pixel data array
   * @param index Pixel index (already multiplied by 4 for RGBA)
   * @returns RGBA color object with r, g, b, a properties
   */
  pixelsToRGBA(e, t) {
    return {
      r: e[t],
      g: e[t + 1],
      b: e[t + 2],
      a: e[t + 3]
    };
  }
}
class V {
  /**
   * Creates a downloadable blob from content
   * @param content The content to include in the blob
   * @param mimeType The MIME type for the blob
   * @returns Blob object containing the content
   */
  createBlob(e, t) {
    return new Blob([e], { type: t });
  }
  /**
   * Creates a data URL from content
   * @param content The content to convert
   * @param mimeType The MIME type for the blob
   * @returns Data URL string
   */
  createDataURL(e, t) {
    const r = this.createBlob(e, t);
    return URL.createObjectURL(r);
  }
  /**
   * Downloads content as a file
   * @param content The content to download
   * @param filename The filename (with extension)
   * @param mimeType The MIME type for the content
   */
  downloadFile(e, t, r) {
    try {
      const i = this.createBlob(e, r), a = URL.createObjectURL(i), n = document.createElement("a");
      n.href = a, n.download = t, n.style.display = "none", n.rel = "noopener", document.body.appendChild(n), n.click(), document.body.removeChild(n), URL.revokeObjectURL(a);
    } catch (i) {
      throw console.error("Failed to download file:", i), new Error(`File download failed: ${i instanceof Error ? i.message : "Unknown error"}`);
    }
  }
  /**
   * Generates a timestamp string for filenames
   * @returns Formatted timestamp string
   */
  generateTimestamp() {
    return (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace(/:/g, "-");
  }
  /**
   * Generates a date-time string for filenames (alternative format)
   * @returns Formatted date and time string
   */
  generateDateTimeString() {
    const e = /* @__PURE__ */ new Date(), t = e.toISOString().split("T")[0], r = e.toTimeString().split(" ")[0].replace(/:/g, "-");
    return { date: t, time: r };
  }
  /**
   * Validates and sanitizes filename for safety and compatibility
   * @param filename The filename to validate
   * @returns Sanitized filename
   */
  sanitizeFilename(e) {
    return e.replace(/[<>:"/\\|?*]/g, "_").replace(/\s+/g, "_").replace(/_{2,}/g, "_").replace(/^_+|_+$/g, "").substring(0, 255);
  }
  /**
   * Ensures filename has the correct extension
   * @param filename The filename to check
   * @param expectedExtension The expected file extension (with dot)
   * @returns Filename with correct extension
   */
  ensureFileExtension(e, t) {
    return e.toLowerCase().endsWith(t.toLowerCase()) ? e : e + t;
  }
  /**
   * Generates a default filename with prefix and timestamp
   * @param prefix The prefix for the filename
   * @param extension The file extension (with dot)
   * @returns Generated filename
   */
  generateDefaultFilename(e, t) {
    const r = this.generateTimestamp();
    return `${e}-${r}${t}`;
  }
}
class me extends P {
  /**
   * Extracts transform data from transform pixels
   * @param transformPixels Transform framebuffer pixels
   * @param rotationPixels Rotation framebuffer pixels
   * @param pixelIndex Pixel index in the array
   * @returns Transform data object
   */
  extractTransformData(e, t, r) {
    const i = e[r], a = e[r + 1], n = e[r + 2], o = i === 255, h = a === 255, c = n === 255, u = t[r], f = t[r + 1], m = u + f / 255, _ = Math.round(m * 360 / 255 * 100) / 100;
    return {
      isInverted: o,
      flipHorizontal: h,
      flipVertical: c,
      rotation: _
    };
  }
  /**
   * Calculates cell position information
   * @param x Grid X coordinate
   * @param y Grid Y coordinate
   * @param gridInfo Grid information
   * @returns Position data object
   */
  calculateCellPosition(e, t, r) {
    return {
      x: e,
      y: t,
      cellX: e * r.cellWidth,
      cellY: t * r.cellHeight
    };
  }
  /**
   * Processes all grid cells and extracts SVG cell data
   * @param framebufferData Raw pixel data from framebuffers
   * @param grid Grid information
   * @param font Font information
   * @returns Array of SVG cell data objects
   */
  extractSVGCellData(e, t) {
    const r = [];
    let i = 0;
    for (let a = 0; a < t.rows; a++)
      for (let n = 0; n < t.cols; n++) {
        const o = i * 4, h = this.getCharacterIndex(
          e.characterPixels,
          o
        );
        let c = this.pixelsToRGBA(e.primaryColorPixels, o), u = this.pixelsToRGBA(e.secondaryColorPixels, o);
        const f = this.extractTransformData(
          e.transformPixels,
          e.rotationPixels,
          o
        );
        if (f.isInverted) {
          const _ = c;
          c = u, u = _;
        }
        const m = this.calculateCellPosition(n, a, t);
        r.push({
          charIndex: h,
          primaryColor: c,
          secondaryColor: u,
          transform: f,
          position: m
        }), i++;
      }
    return r;
  }
}
class ge {
  /**
   * Gets the glyph index for a given Unicode code point in a Typr.js font
   * @param fontData The Typr.js font data
   * @param codePoint The Unicode code point to look up
   * @returns The glyph index, or 0 if not found
   */
  getGlyphIndex(e, t) {
    const r = e.cmap;
    if (!r || !r.tables) return 0;
    for (const i of r.tables)
      if (i.format === 4) {
        for (let a = 0; a < i.startCount.length; a++)
          if (t >= i.startCount[a] && t <= i.endCount[a]) {
            if (i.idRangeOffset[a] === 0)
              return t + i.idDelta[a] & 65535;
            {
              const n = i.idRangeOffset[a] / 2 + (t - i.startCount[a]) - (i.startCount.length - a);
              if (n >= 0 && n < i.glyphIdArray.length) {
                const o = i.glyphIdArray[n];
                if (o !== 0)
                  return o + i.idDelta[a] & 65535;
              }
            }
          }
      }
    return 0;
  }
  /**
   * Creates an empty path object for characters with no glyph data
   * @returns Empty path object
   */
  createEmptyPath() {
    return {
      getBoundingBox: () => ({ x1: 0, y1: 0, x2: 0, y2: 0 }),
      toSVG: () => ""
    };
  }
  /**
   * Creates a path object for a glyph
   * @param fontData Font data object
   * @param glyphData Glyph data from font
   * @param x X position
   * @param y Y position
   * @param fontSize Font size
   * @returns Path object with bounding box and SVG methods
   */
  createGlyphPath(e, t, r, i, a) {
    if (!t || !t.xs || t.xs.length === 0)
      return this.createEmptyPath();
    const n = a / e.head.unitsPerEm;
    return {
      getBoundingBox: () => ({
        x1: r + t.xMin * n,
        y1: i + -t.yMax * n,
        x2: r + t.xMax * n,
        y2: i + -t.yMin * n
      }),
      toSVG: () => this.glyphToSVGPath(t, r, i, n)
    };
  }
  /**
   * Converts glyph data to SVG path string
   * @param glyphData Glyph data from font
   * @param x X position
   * @param y Y position
   * @param scale Scale factor
   * @returns SVG path data string
   */
  glyphToSVGPath(e, t, r, i) {
    if (!e || !e.xs) return "";
    const { xs: a, ys: n, endPts: o, flags: h } = e;
    if (!a || !n || !o || !h) return "";
    let c = "", u = 0;
    for (let f = 0; f < o.length; f++) {
      const m = o[f];
      if (!(m < u)) {
        if (m >= u) {
          const _ = t + a[u] * i, x = r - n[u] * i;
          c += `M${_.toFixed(2)},${x.toFixed(2)}`;
          let g = u + 1;
          for (; g <= m; )
            if ((h[g] & 1) !== 0) {
              const w = t + a[g] * i, F = r - n[g] * i;
              c += `L${w.toFixed(2)},${F.toFixed(2)}`, g++;
            } else {
              const w = t + a[g] * i, F = r - n[g] * i;
              let C = g + 1 > m ? u : g + 1;
              if ((h[C] & 1) !== 0) {
                const S = t + a[C] * i, E = r - n[C] * i;
                c += `Q${w.toFixed(2)},${F.toFixed(2)} ${S.toFixed(2)},${E.toFixed(2)}`, g = C + 1;
              } else {
                const S = t + a[C] * i, E = r - n[C] * i, N = (w + S) / 2, O = (F + E) / 2;
                c += `Q${w.toFixed(2)},${F.toFixed(2)} ${N.toFixed(2)},${O.toFixed(2)}`, g = C;
              }
            }
          c += "Z";
        }
        u = m + 1;
      }
    }
    return c;
  }
  /**
   * Generates an SVG path for a character glyph
   * @param character The character to generate a path for
   * @param fontData The font data object
   * @param x X position
   * @param y Y position
   * @param fontSize Font size
   * @returns Path object with SVG generation methods
   */
  generateCharacterPath(e, t, r, i, a) {
    try {
      const n = e.codePointAt(0) || 0, o = this.getGlyphIndex(t, n);
      if (o === 0)
        return this.createEmptyPath();
      let h = null;
      try {
        t.glyf && t.glyf[o] !== null ? h = t.glyf[o] : d && d.T && d.T.glyf && d.T.glyf._parseGlyf && (h = d.T.glyf._parseGlyf(t, o), t.glyf && h && (t.glyf[o] = h));
      } catch (c) {
        console.warn(`Failed to parse glyph ${o}:`, c);
      }
      return h ? this.createGlyphPath(t, h, r, i, a) : this.createEmptyPath();
    } catch (n) {
      return console.warn(`Failed to generate path for character "${e}":`, n), this.createEmptyPath();
    }
  }
  /**
   * Generates SVG path data for a character with positioning calculations
   * @param character The character to render
   * @param fontData The font data
   * @param cellX Cell X position
   * @param cellY Cell Y position
   * @param cellWidth Cell width
   * @param cellHeight Cell height
   * @param fontSize Font size
   * @param advanceWidth Character advance width
   * @returns SVG path data string or null if generation fails
   */
  generatePositionedCharacterPath(e, t, r, i, a, n, o, h) {
    try {
      const c = o / t.head.unitsPerEm, u = h * c, f = r + (a - u) / 2, m = i + (n + o * 0.7) / 2;
      return this.generateCharacterPath(e, t, f, m, o).toSVG() || null;
    } catch (c) {
      return console.warn(`Failed to generate positioned character path for "${e}":`, c), null;
    }
  }
}
class pe {
  constructor() {
    l(this, "pathGenerator");
    this.pathGenerator = new ge();
  }
  /**
   * Generates the SVG header with metadata
   * @param gridInfo Grid dimensions
   * @returns SVG header string
   */
  generateSVGHeader(e) {
    return `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="${e.width}" height="${e.height}" viewBox="0 0 ${e.width} ${e.height}" 
     xmlns="http://www.w3.org/2000/svg" version="1.1">
<title>textmode art generated via textmode.js</title>
<desc>textmode art visualization generated by textmode.js library</desc>`;
  }
  /**
   * Generates the SVG footer
   * @returns SVG footer string
   */
  generateSVGFooter() {
    return `
</g>
</svg>`;
  }
  /**
   * Generates background rectangle if needed
   * @param gridInfo Grid information
   * @param options SVG generation options
   * @returns Background rectangle SVG string or empty string
   */
  generateBackground(e, t) {
    if (!t.includeBackgroundRectangles)
      return "";
    const r = t.backgroundColor, i = `rgba(${r[0]},${r[1]},${r[2]},${r[3] / 255})`;
    return `
<rect width="${e.width}" height="${e.height}" fill="${i}" />`;
  }
  /**
   * Converts RGBA object to CSS color string
   * @param color RGBA color object
   * @returns CSS color string
   */
  rgbaToColorString(e) {
    return `rgba(${e.r},${e.g},${e.b},${e.a / 255})`;
  }
  /**
   * Generates SVG transform attribute string
   * @param cellData Cell data with transform information
   * @param gridInfo Grid information for center calculations
   * @returns Transform attribute string or empty string
   */
  generateTransformAttribute(e, t) {
    const { transform: r, position: i } = e, a = i.cellX + t.cellWidth / 2, n = i.cellY + t.cellHeight / 2, o = [];
    if (r.flipHorizontal || r.flipVertical) {
      const h = r.flipHorizontal ? -1 : 1, c = r.flipVertical ? -1 : 1;
      o.push(`translate(${a} ${n})`), o.push(`scale(${h} ${c})`), o.push(`translate(${-a} ${-n})`);
    }
    return r.rotation && o.push(`rotate(${r.rotation} ${a} ${n})`), o.length ? ` transform="${o.join(" ")}"` : "";
  }
  /**
   * Generates background rectangle for a cell
   * @param cellData Cell data
   * @param gridInfo Grid information
   * @param options SVG generation options
   * @returns Background rectangle SVG string or empty string
   */
  generateCellBackground(e, t, r) {
    if (!r.includeBackgroundRectangles || e.secondaryColor.a === 0)
      return "";
    const { position: i } = e, a = this.rgbaToColorString(e.secondaryColor);
    return r.drawMode === "stroke" ? `
  <rect x="${i.cellX}" y="${i.cellY}" width="${t.cellWidth}" height="${t.cellHeight}" stroke="${a}" fill="none" stroke-width="${r.strokeWidth}" />` : `
  <rect x="${i.cellX}" y="${i.cellY}" width="${t.cellWidth}" height="${t.cellHeight}" fill="${a}" />`;
  }
  /**
   * Generates character path element for a cell
   * @param cellData Cell data
   * @param gridInfo Grid information
   * @param fontInfo Font information
   * @param options SVG generation options
   * @returns Character path SVG string
   */
  generateCharacterPath(e, t, r, i) {
    const a = r.characters[e.charIndex];
    if (!a)
      return "";
    const n = this.pathGenerator.generatePositionedCharacterPath(
      a.character,
      r.font,
      e.position.cellX,
      e.position.cellY,
      t.cellWidth,
      t.cellHeight,
      r.fontSize,
      a.advanceWidth
    );
    if (!n)
      return "";
    const o = this.rgbaToColorString(e.primaryColor);
    return i.drawMode === "stroke" ? `
    <path id="${`path-${e.charIndex}-${e.position.cellX}-${e.position.cellY}`.replace(/\./g, "-")}" d="${n}" stroke="${o}" stroke-width="${i.strokeWidth}" fill="none" />` : `
    <path d="${n}" fill="${o}" />`;
  }
  /**
   * Generates complete SVG content for a single cell
   * @param cellData Cell data
   * @param gridInfo Grid information
   * @param fontInfo Font information
   * @param options SVG generation options
   * @returns Complete cell SVG content
   */
  generateCellContent(e, t, r, i) {
    let a = "";
    a += this.generateCellBackground(e, t, i);
    const n = this.generateTransformAttribute(e, t), o = this.generateCharacterPath(e, t, r, i);
    return o && (n ? (a += `
  <g${n}>`, a += o, a += `
  </g>`) : a += o), a;
  }
  /**
   * Generates the complete SVG content from cell data
   * @param cellDataArray Array of cell data
   * @param grid Grid information
   * @param fontInfo Font information
   * @param options SVG generation options
   * @returns Complete SVG string
   */
  generateSVGContent(e, t, r, i) {
    let a = this.generateSVGHeader(t);
    a += this.generateBackground(t, i), a += `
<g id="ascii-cells">`;
    for (const n of e)
      a += this.generateCellContent(n, t, r, i);
    return a += this.generateSVGFooter(), a;
  }
  /**
   * Optimizes SVG content by removing empty elements and unnecessary whitespace
   * @param svgContent Raw SVG content
   * @returns Optimized SVG content
   */
  optimizeSVGContent(e) {
    return e.replace(/<path[^>]*d=""[^>]*\/>/g, "").replace(/\n\s*\n/g, `
`).replace(/[ \t]+$/gm, "");
  }
}
class _e extends V {
  /**
   * Generates a default filename for SVG export
   * @param prefix Optional prefix for the filename
   * @returns Generated filename without extension
   */
  generateDefaultFilename(e = "textmode_output") {
    const { date: t, time: r } = this.generateDateTimeString();
    return `${e}_${t}_${r}`;
  }
  /**
   * Validates filename for safety and compatibility
   * @param filename The filename to validate
   * @returns Sanitized filename
   */
  sanitizeFilename(e) {
    return super.sanitizeFilename(e);
  }
  /**
   * Creates a downloadable blob from SVG content
   * @param svgContent The SVG content string
   * @returns Blob object containing the SVG data
   */
  createSVGBlob(e) {
    return this.createBlob(e, "image/svg+xml;charset=utf-8");
  }
  /**
   * Creates a data URL from SVG content
   * @param svgContent The SVG content string
   * @returns Data URL string
   */
  createDataURL(e) {
    return super.createDataURL(e, "image/svg+xml;charset=utf-8");
  }
  /**
   * Downloads SVG content as a file
   * @param svgContent The SVG content to download
   * @param filename The filename (without extension)
   */
  downloadSVG(e, t) {
    try {
      const r = this.sanitizeFilename(t), i = this.ensureFileExtension(r, ".svg");
      this.downloadFile(e, i, "image/svg+xml;charset=utf-8");
    } catch (r) {
      throw console.error("Failed to download SVG file:", r), new Error(`SVG download failed: ${r instanceof Error ? r.message : "Unknown error"}`);
    }
  }
  /**
   * Saves SVG content with automatic filename generation if not provided
   * @param svgContent The SVG content to save
   * @param filename Optional filename (will generate if not provided)
   */
  saveSVG(e, t) {
    const r = t || this.generateDefaultFilename();
    this.downloadSVG(e, r);
  }
}
class H {
  constructor() {
    l(this, "dataExtractor");
    l(this, "contentGenerator");
    l(this, "fileHandler");
    this.dataExtractor = new me(), this.contentGenerator = new pe(), this.fileHandler = new _e();
  }
  /**
   * Applies default values to SVG export options
   * @param options User-provided options
   * @returns Complete options with defaults applied
   */
  applyDefaultOptions(e) {
    return {
      includeBackgroundRectangles: e.includeBackgroundRectangles ?? !0,
      drawMode: e.drawMode ?? "fill",
      strokeWidth: e.strokeWidth ?? 1,
      backgroundColor: e.backgroundColor ?? [0, 0, 0, 0]
    };
  }
  /**
   * Generates SVG content from textmode rendering data without saving to file
   * @param textmodifier The textmodifier instance containing rendering data
   * @param options Export options (excluding filename)
   * @returns SVG content as string
   */
  generateSVG(e, t = {}) {
    const r = this.applyDefaultOptions(t), i = this.dataExtractor.extractFramebufferData(e.pipeline), a = this.dataExtractor.extractSVGCellData(
      i,
      e.grid
    ), n = this.contentGenerator.generateSVGContent(
      a,
      e.grid,
      e.font,
      r
    );
    return this.contentGenerator.optimizeSVGContent(n);
  }
  /**
   * Exports SVG content to a downloadable file
   * @param textmodifier The textmodifier instance containing rendering data
   * @param options Export options including filename
   */
  saveSVG(e, t = {}) {
    try {
      const r = this.generateSVG(e, t), i = t.filename || this.fileHandler.generateDefaultFilename();
      this.fileHandler.saveSVG(r, i);
    } catch (r) {
      throw console.error("Failed to save SVG:", r), new Error(`SVG save failed: ${r instanceof Error ? r.message : "Unknown error"}`);
    }
  }
}
class xe extends P {
  /**
   * Extracts character data for TXT generation
   * @param framebufferData Framebuffer pixel data
   * @param grid Grid information
   * @param font Font information
   * @param emptyCharacter Character to use for empty cells
   * @returns 2D array of characters (rows x columns)
   */
  extractCharacterGrid(e, t, r, i = " ") {
    var o;
    const a = [];
    let n = 0;
    for (let h = 0; h < t.rows; h++) {
      const c = [];
      for (let u = 0; u < t.cols; u++) {
        const f = n * 4, m = this.getCharacterIndex(
          e.characterPixels,
          f
        ), _ = ((o = r.characters[m]) == null ? void 0 : o.character) || i;
        c.push(_), n++;
      }
      a.push(c);
    }
    return a;
  }
}
class ve {
  /**
   * Generates TXT content from a 2D character array
   * @param characterGrid 2D array of characters (rows x columns)
   * @param options Generation options
   * @returns TXT content as string
   */
  generateTXTContent(e, t) {
    const r = [];
    for (const a of e) {
      let n = a.join("");
      t.preserveTrailingSpaces || (n = n.replace(/\s+$/, "")), r.push(n);
    }
    const i = t.lineEnding === "crlf" ? `\r
` : `
`;
    return r.join(i);
  }
}
class be extends V {
  /**
   * Saves TXT content as a downloadable file
   * @param content The TXT content to save
   * @param filename The filename to use for the download
   */
  saveTXT(e, t) {
    try {
      const r = this.ensureValidFilename(t);
      this.downloadFile(e, r, "text/plain;charset=utf-8");
    } catch (r) {
      throw console.error("Failed to save TXT file:", r), new Error(`TXT file save failed: ${r instanceof Error ? r.message : "Unknown error"}`);
    }
  }
  /**
   * Generates a default filename for TXT export
   * @returns Default filename with timestamp
   */
  generateDefaultFilename() {
    return super.generateDefaultFilename("textmode-export", ".txt");
  }
  /**
   * Ensures filename has proper extension and is valid
   * @param filename The filename to validate and fix
   * @returns Valid filename with .txt extension
   */
  ensureValidFilename(e) {
    let t = this.sanitizeFilename(e);
    return t = this.ensureFileExtension(t, ".txt"), t === ".txt" || t.length <= 4 ? this.generateDefaultFilename() : t;
  }
}
class L {
  constructor() {
    l(this, "dataExtractor");
    l(this, "contentGenerator");
    l(this, "fileHandler");
    this.dataExtractor = new xe(), this.contentGenerator = new ve(), this.fileHandler = new be();
  }
  /**
   * Applies default values to TXT export options
   * @param options User-provided options
   * @returns Complete options with defaults applied
   */
  applyDefaultOptions(e) {
    return {
      preserveTrailingSpaces: e.preserveTrailingSpaces ?? !1,
      lineEnding: e.lineEnding ?? "lf",
      emptyCharacter: e.emptyCharacter ?? " "
    };
  }
  /**
   * Generates TXT content from textmode rendering data without saving to file
   * @param textmodifier The textmodifier instance containing rendering data
   * @param options Export options (excluding filename)
   * @returns TXT content as string
   */
  generateTXT(e, t = {}) {
    const r = this.applyDefaultOptions(t), i = this.dataExtractor.extractFramebufferData(e.pipeline), a = this.dataExtractor.extractCharacterGrid(
      i,
      e.grid,
      e.font,
      r.emptyCharacter
    );
    return this.contentGenerator.generateTXTContent(
      a,
      r
    );
  }
  /**
   * Exports TXT content to a downloadable file
   * @param textmodifier The textmodifier instance containing rendering data
   * @param options Export options including filename
   */
  saveTXT(e, t = {}) {
    try {
      const r = this.generateTXT(e, t), i = t.filename || this.fileHandler.generateDefaultFilename();
      this.fileHandler.saveTXT(r, i);
    } catch (r) {
      throw console.error("Failed to save TXT:", r), new Error(`TXT save failed: ${r instanceof Error ? r.message : "Unknown error"}`);
    }
  }
}
class Ce extends P {
  /**
   * Captures the current state of the textmode canvas as image data
   * @param textmodeCanvas The TextmodeCanvas instance to capture from
   * @param scale Scale factor for the output image
   * @param backgroundColor Background color for formats that don't support transparency
   * @returns Canvas element containing the captured image data
   */
  captureCanvasData(e, t = 1, r = "transparent") {
    const i = e.canvas;
    if (t === 1 && r === "transparent")
      return i;
    const a = document.createElement("canvas"), n = a.getContext("2d");
    if (!n)
      throw new Error("Failed to get 2D rendering context for image capture");
    const o = Math.round(i.width * t), h = Math.round(i.height * t);
    return a.width = o, a.height = h, r !== "transparent" && (n.fillStyle = r, n.fillRect(0, 0, o, h)), n.imageSmoothingEnabled = !1, n.drawImage(
      i,
      0,
      0,
      i.width,
      i.height,
      0,
      0,
      o,
      h
    ), a;
  }
}
class Fe {
  /**
   * Generates image data from canvas
   * @param canvas The canvas containing the image data
   * @param options Generation options with format, quality, etc.
   * @returns Data URL string containing the image data
   */
  generateImageData(e, t) {
    const r = this.getMimeType(t.format);
    return t.format === "png" ? e.toDataURL(r) : e.toDataURL(r, t.quality);
  }
  /**
   * Generates image blob from canvas
   * @param canvas The canvas containing the image data
   * @param options Generation options with format, quality, etc.
   * @returns Promise that resolves to a Blob containing the image data
   */
  async generateImageBlob(e, t) {
    return new Promise((r, i) => {
      const a = this.getMimeType(t.format), n = (o) => {
        o ? r(o) : i(new Error(`Failed to generate ${t.format.toUpperCase()} blob`));
      };
      t.format === "png" ? e.toBlob(n, a) : e.toBlob(n, a, t.quality);
    });
  }
  /**
   * Gets the MIME type for a given image format
   * @param format The image format
   * @returns The corresponding MIME type
   */
  getMimeType(e) {
    switch (e) {
      case "png":
        return "image/png";
      case "jpg":
        return "image/jpeg";
      case "webp":
        return "image/webp";
      default:
        throw new Error(`Unsupported image format: ${e}`);
    }
  }
}
const k = {
  png: "image/png",
  jpg: "image/jpeg",
  webp: "image/webp"
}, A = {
  png: ".png",
  jpg: ".jpg",
  webp: ".webp"
};
class we extends V {
  /**
   * Saves image content as a downloadable file
   * @param content The image content (data URL or blob)
   * @param filename The filename (without extension)
   * @param format The image format
   */
  saveImage(e, t, r) {
    try {
      const i = this.sanitizeFilename(t), a = A[r], n = this.ensureFileExtension(i, a);
      typeof e == "string" ? this.saveImageFromDataURL(e, n) : this.saveImageFromBlob(e, n);
    } catch (i) {
      throw console.error(`Failed to save ${r.toUpperCase()} image:`, i), new Error(`Image save failed: ${i instanceof Error ? i.message : "Unknown error"}`);
    }
  }
  /**
   * Saves image from data URL
   * @param dataURL The data URL containing image data
   * @param filename The complete filename with extension
   */
  saveImageFromDataURL(e, t) {
    const r = document.createElement("a");
    r.href = e, r.download = t, r.style.display = "none", r.rel = "noopener", document.body.appendChild(r), r.click(), document.body.removeChild(r);
  }
  /**
   * Saves image from blob
   * @param blob The blob containing image data
   * @param filename The complete filename with extension
   */
  saveImageFromBlob(e, t) {
    const r = URL.createObjectURL(e);
    try {
      const i = document.createElement("a");
      i.href = r, i.download = t, i.style.display = "none", i.rel = "noopener", document.body.appendChild(i), i.click(), document.body.removeChild(i);
    } finally {
      URL.revokeObjectURL(r);
    }
  }
  /**
   * Generates a default filename for image export
   * @param format The image format for the file extension
   * @returns Generated filename with timestamp
   */
  generateDefaultImageFilename(e = "png") {
    const t = A[e];
    return super.generateDefaultFilename("textmode-export", t);
  }
  /**
   * Validates if the browser supports saving files in the specified format
   * @param format The image format to validate
   * @returns True if the format is supported for saving
   */
  validateSaveSupport(e) {
    return e in k && e in A;
  }
  /**
   * Gets the MIME type for the specified image format
   * @param format The image format
   * @returns The MIME type string
   */
  getMimeType(e) {
    return k[e];
  }
  /**
   * Gets the file extension for the specified image format
   * @param format The image format
   * @returns The file extension (including the dot)
   */
  getFileExtension(e) {
    return A[e];
  }
}
class ye {
  constructor() {
    l(this, "dataExtractor");
    l(this, "contentGenerator");
    l(this, "fileHandler");
    this.dataExtractor = new Ce(), this.contentGenerator = new Fe(), this.fileHandler = new we();
  }
  /**
   * Applies default values to image export options
   * @param options User-provided options
   * @returns Complete options with defaults applied
   */
  applyDefaultOptions(e) {
    return {
      format: e.format ?? "png",
      quality: e.quality ?? 1,
      scale: e.scale ?? 1,
      backgroundColor: e.backgroundColor ?? "transparent"
    };
  }
  /**
   * Validates export options and browser support
   * @param options The options to validate
   * @throws Error if options are invalid or format is not supported
   */
  validateOptions(e) {
    if (console.log("Validating image export options:", e), !this.fileHandler.validateSaveSupport(e.format))
      throw new Error(`Saving '${e.format}' files is not supported`);
    if (e.quality < 0 || e.quality > 1)
      throw new Error("Image quality must be between 0.0 and 1.0");
    if (e.scale <= 0)
      throw new Error("Scale factor must be greater than 0");
    e.scale > 10 && console.warn("Large scale factors may result in very large files and slow performance"), e.format === "jpg" && e.backgroundColor === "transparent" && (e.backgroundColor = "black");
  }
  /**
   * Generates image data from textmode rendering without saving to file
   * @param textmodifier The textmodifier instance containing the canvas
   * @param options Export options (excluding filename)
   * @returns Data URL string containing the image data
   */
  generateImage(e, t = {}) {
    const r = this.applyDefaultOptions(t);
    if (this.validateOptions(r), r.scale === 1 && r.backgroundColor === "transparent") {
      const n = e.textmodeCanvas.canvas;
      return this.contentGenerator.generateImageData(n, r);
    }
    const i = this.dataExtractor.captureCanvasData(
      e.textmodeCanvas,
      r.scale,
      r.backgroundColor
    );
    return this.contentGenerator.generateImageData(
      i,
      r
    );
  }
  /**
   * Generates image blob from textmode rendering without saving to file
   * @param textmodifier The textmodifier instance containing the canvas
   * @param options Export options (excluding filename)
   * @returns Promise that resolves to a Blob containing the image data
   */
  async generateImageBlob(e, t = {}) {
    const r = this.applyDefaultOptions(t);
    if (this.validateOptions(r), r.scale === 1 && r.backgroundColor === "transparent") {
      const n = e.textmodeCanvas.canvas;
      return await this.contentGenerator.generateImageBlob(n, r);
    }
    const i = this.dataExtractor.captureCanvasData(
      e.textmodeCanvas,
      r.scale,
      r.backgroundColor
    );
    return await this.contentGenerator.generateImageBlob(
      i,
      r
    );
  }
  /**
   * Exports image to a downloadable file
   * @param textmodifier The textmodifier instance containing the canvas
   * @param options Export options including filename
   */
  async saveImage(e, t = {}) {
    try {
      const r = await this.generateImageBlob(e, t), i = t.format ?? "png", a = t.filename || this.fileHandler.generateDefaultImageFilename(i);
      this.fileHandler.saveImage(r, a, i);
    } catch (r) {
      throw console.error("Failed to save image:", r), new Error(`Image save failed: ${r instanceof Error ? r.message : "Unknown error"}`);
    }
  }
}
class D {
  constructor(e = null, t = {}) {
    /** The element to capture content from (optional for standalone mode) */
    l(this, "captureSource");
    /** Our WebGL overlay canvas manager */
    l(this, "textmodeCanvas");
    /** Core WebGL renderer */
    l(this, "_renderer");
    l(this, "_canvasFramebuffer");
    l(this, "_font");
    l(this, "_grid");
    l(this, "resizeObserver");
    // Auto-rendering properties
    l(this, "_mode");
    l(this, "_frameRateLimit");
    l(this, "animationFrameId", null);
    l(this, "lastFrameTime", 0);
    l(this, "frameInterval");
    l(this, "_frameRate", 0);
    l(this, "lastRenderTime", 0);
    l(this, "_frameCount", 0);
    // Frame rate measurement smoothing
    l(this, "frameTimeHistory", []);
    l(this, "frameTimeHistorySize", 10);
    l(this, "_pipeline");
    // Standalone canvas properties
    l(this, "_standalone", !1);
    l(this, "_drawCallback", () => {
    });
    l(this, "_resizedCallback", () => {
    });
    this.captureSource = e, this._standalone = e === null, this._mode = t.renderMode ?? "auto", this._frameRateLimit = t.frameRate ?? 60, this.frameInterval = 1e3 / this._frameRateLimit;
  }
  /**
   * Static factory method for creating and initializing a Textmodifier instance.
   * @param source The HTML canvas or video element to capture content from. Pass `null` for standalone mode.
   * @param opts Optional configuration options for the `Textmodifier` instance.
   * @ignore
   */
  static async create(e = null, t = {}) {
    const r = new D(e, t), i = r._standalone ? t : void 0;
    r.textmodeCanvas = new ae(r.captureSource, r._standalone, i), r._renderer = new Z(r.textmodeCanvas.getWebGLContext());
    let a, n;
    r._standalone ? (a = t.width || 800, n = t.height || 600) : (a = r.textmodeCanvas.width || 800, n = r.textmodeCanvas.height || 600), r._canvasFramebuffer = r._renderer.createFramebuffer(a, n), r._font = new re(r._renderer, t.fontSize ?? 16), await r._font.initialize(t.fontSource);
    const o = r._font.maxGlyphDimensions;
    return r._grid = new ie(r.textmodeCanvas.canvas, o.width, o.height), r._pipeline = new fe(r._renderer, r._font, r._grid), r.setupEventListeners(), r.startAutoRendering(), r;
  }
  setupEventListeners() {
    window.addEventListener("resize", () => {
      this._standalone ? this._resizedCallback() : this.resize();
    }), window.ResizeObserver && this.captureSource && !this._standalone && (this.resizeObserver = new ResizeObserver(() => {
      this.resize();
    }), this.resizeObserver.observe(this.captureSource));
  }
  /**
   * Generate the current textmode rendering as a text string.
   * @param options Options for text generation *(excluding filename)*
   * @returns Textmode grid content as a string.
   * 
   * @example
   * ```javascript
   * // Fetch a canvas element to apply textmode rendering to
   * const canvas = document.querySelector('canvas#myCanvas');
   * 
   * // Create a Textmodifier instance
   * const textmodifier = await textmode.create(canvas, {renderMode: 'manual'});
   *
   * // Render a single frame
   * textmodifier.render();
   * 
   * // Get the current rendering as a text string
   * const textString = textmodifier.toString({
   *   preserveTrailingSpaces: false,
   *   lineEnding: 'lf'
   * });
   * 
   * // Print to console or use otherwise
   * console.log(textString);
   * 
   * ////////
   * 
   * // Example with video element
   * const video = document.querySelector('video#myVideo');
   * const videoTextmodifier = await textmode.create(video);
   * 
   * // The textmode overlay will automatically update as the video plays
   * video.play();
   * 
   * // Get current frame as ASCII
   * const videoFrame = videoTextmodifier.toString();
   * ```
   */
  toString(e = {}) {
    return new L().generateTXT(this, e);
  }
  /**
   * Export the current textmode rendering to a TXT file.
   * @param options Options for TXT export
   * 
   * @example
   * ```javascript
   * // Fetch a canvas element to apply textmode rendering to
   * const canvas = document.querySelector('canvas#myCanvas');
   * 
   * // Create a Textmodifier instance
   * const textmodifier = await textmode.create(canvas, {renderMode: 'manual'});
   *
   * // Render a single frame
   * textmodifier.render();
   * 
   * // Export the current rendering to a TXT file
   * textmodifier.saveStrings({
   *   filename: 'my_textmode_rendering',
   *   preserveTrailingSpaces: false
   * });
   * ```
   */
  saveStrings(e = {}) {
    new L().saveTXT(this, e);
  }
  /**
   * Generate the current textmode rendering as an SVG string.
   * @param options Options for SVG generation *(excluding filename)*
   * @returns SVG content as a string.
   * 
   * @example
   * ```javascript
   * // Fetch a canvas element to apply textmode rendering to
   * const canvas = document.querySelector('canvas#myCanvas');
   * 
   * // Create a Textmodifier instance
   * const textmodifier = await textmode.create(canvas, {renderMode: 'manual'});
   *
   * // Render a single frame
   * textmodifier.render();
   * 
   * // Get the current rendering as an SVG string
   * const svgString = textmodifier.toSVG({
   *   includeBackgroundRectangles: true,
   *   drawMode: 'fill'
   * });
   * 
   * // Print to console or use otherwise
   * console.log(svgString);
   * ```
   */
  toSVG(e = {}) {
    return new H().generateSVG(this, e);
  }
  /**
   * Export the current textmode rendering to an SVG file.
   * @param options Options for SVG export
   * 
   * @example
   * ```javascript
   * // Fetch a canvas element to apply textmode rendering to
   * const canvas = document.querySelector('canvas#myCanvas');
   * 
   * // Create a Textmodifier instance
   * const textmodifier = await textmode.create(canvas, {renderMode: 'manual'});
   *
   * // Render a single frame
   * textmodifier.render();
   * 
   * // Export the current rendering to an SVG file
   * textmodifier.saveSVG({
   *   filename: 'my_textmode_rendering',
   * });
   * ```
   */
  saveSVG(e = {}) {
    new H().saveSVG(this, e);
  }
  /**
   * Export the current textmode rendering to an image file.
   * @param filename The filename (without extension) to save the image as
   * @param format The image format ('png', 'jpg', or 'webp')
   * @param options Additional options for image export
   * 
   * @example
   * ```javascript
   * // Fetch a canvas element to apply textmode rendering to
   * const canvas = document.querySelector('canvas#myCanvas');
   * 
   * // Create a Textmodifier instance
   * const textmodifier = await textmode.create(canvas, {renderMode: 'manual'});
   *
   * // Render a single frame
   * textmodifier.render();
   * 
   * // Export the current rendering to a PNG file
   * textmodifier.saveCanvas('my_textmode_rendering', 'png');
   * 
   * // Export with custom options
   * textmodifier.saveCanvas('my_textmode_rendering', 'jpg', {
   *   quality: 0.8,
   *   scale: 2.0,
   *   backgroundColor: 'white'
   * });
   * ```
   */
  async saveCanvas(e, t, r = {}) {
    await new ye().saveImage(this, {
      ...r,
      filename: e,
      format: t
    });
  }
  /**
   * Update the font used for rendering.
   * @param fontSource The URL of the font to load.
   * 
   * @example
   * ```javascript
   * // Fetch a canvas element to apply textmode rendering to
   * const canvas = document.querySelector('canvas#myCanvas');
   * 
   * // Create a Textmodifier instance
   * const textmodifier = await textmode.create(canvas);
   * 
   * // Load a custom font from a URL
   * await textmodifier.loadFont('https://example.com/fonts/myfont.ttf');
   * 
   * // Local font example
   * // await textmodifier.loadFont('./fonts/myfont.ttf'); 
   * ```
   */
  async loadFont(e) {
    return this._font.loadFont(e).then(() => {
      const t = this._font.maxGlyphDimensions;
      this._grid.resizeCellPixelDimensions(t.width, t.height), this._pipeline.resize();
    });
  }
  /**
   * Apply textmode rendering to the canvas.
   * 
   * **Note:** In `'auto'` mode, this is called automatically.
   * In `'manual'` mode, you need to call this method when you want to update the textmode rendering.
   * 
   * @example
   * ```javascript
   * // p5.js example
   * 
   * let textmodifier;
   * 
   * // p5.js setup function
   * async function setup() {
   * 
   *   // Create a p5.js canvas
   *   const canvas = createCanvas(800, 600);
   * 
   *   // Create a Textmodifier instance
   *   textmodifier = await textmode.create(canvas.elt);
   * 
   *   // Update the rendering mode to 'manual'
   *   textmodifier.renderMode('manual');
   * }
   * 
   * // p5.js draw function
   * function draw() {
   * 
   *   // Draw something on the p5.js canvas
   *   background(220);
   *   fill(255, 0, 0);
   *   rect(50, 50, 100, 100);
   * 
   *   // Apply textmode rendering
   *   textmodifier.render();
   * }
   * ```
   */
  render() {
    this.measureFrameRate(), this._frameCount++, this._standalone ? (this._canvasFramebuffer.begin(), this._drawCallback(), this._canvasFramebuffer.end()) : this._canvasFramebuffer.update(this.captureSource), this._pipeline.render(this._canvasFramebuffer), this._pipeline.hasEnabledConverters() ? (this._renderer.background(0), this._renderer.image(this._pipeline.texture, this._grid.offsetX, this._grid.offsetY, this._pipeline.texture.width, this._pipeline.texture.height)) : (this._renderer.clear(), this._renderer.image(this._canvasFramebuffer, this._grid.offsetX, this._grid.offsetY, this._canvasFramebuffer.width, this._canvasFramebuffer.height)), this._renderer.reset();
  }
  resize() {
    this.textmodeCanvas.resize(), this._canvasFramebuffer.resize(this.textmodeCanvas.width, this.textmodeCanvas.height), this._grid.resize(), this._pipeline.resize(), this._renderer.resetViewport(), this._mode !== "manual" && this.render();
  }
  /**
   * Start automatic rendering
   */
  startAutoRendering() {
    if (this._mode !== "auto") return;
    this.lastFrameTime = performance.now();
    const e = (t) => {
      const r = t - this.lastFrameTime;
      r >= this.frameInterval && (this.render(), this.lastFrameTime = t - r % this.frameInterval), this.animationFrameId = requestAnimationFrame(e);
    };
    this.animationFrameId = requestAnimationFrame(e);
  }
  /**
   * Update FPS measurement - works for both auto and manual modes
   * Uses a rolling average for smoother frame rate reporting
   */
  measureFrameRate() {
    const e = performance.now();
    if (this.lastRenderTime > 0) {
      const t = e - this.lastRenderTime;
      this.frameTimeHistory.push(t), this.frameTimeHistory.length > this.frameTimeHistorySize && this.frameTimeHistory.shift();
      const r = this.frameTimeHistory.reduce((i, a) => i + a, 0) / this.frameTimeHistory.length;
      this._frameRate = 1e3 / r;
    }
    this.lastRenderTime = e;
  }
  /**
   * Stop automatic rendering
   */
  stopAutoRendering() {
    this.animationFrameId && (cancelAnimationFrame(this.animationFrameId), this.animationFrameId = null);
  }
  /**
   * Update the rendering mode. 
   * 
   * If called without arguments, returns the current mode.
   * 
   * - `'manual'`: Requires manual [render](#render) calls
   * - `'auto'`: Automatically renders using [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame)
   *
   * @param mode The new rendering mode to set.
   * 
   * @example
   * ```javascript
   * // Fetch a canvas element to apply textmode rendering to
   * const canvas = document.querySelector('canvas#myCanvas');
   * 
   * // Create a Textmodifier instance
   * const textmodifier = await textmode.create(canvas);
   * 
   * // Update the rendering mode to 'manual'
   * textmodifier.renderMode('manual');
   * 
   * // Now you need to call textmodifier.render() manually in your animation loop
   * ```
   */
  renderMode(e) {
    if (this._mode !== e) {
      if (e === void 0)
        return this._mode;
      this.stopAutoRendering(), this._mode = e, e === "auto" && this.startAutoRendering();
    }
  }
  /**
   * Set the maximum frame rate for auto rendering. If called without arguments, returns the current measured frame rate.
   * @param fps The maximum frames per second for auto rendering.
   * 
   * @example
   * ```javascript
   * // Fetch a canvas element to apply textmode rendering to
   * const canvas = document.querySelector('canvas#myCanvas');
   * 
   * // Create a Textmodifier instance
   * const textmodifier = await textmode.create(canvas);
   * 
   * // Set the maximum frame rate to 30 FPS
   * textmodifier.frameRate(30);
   * ```
   */
  frameRate(e) {
    if (e === void 0)
      return this._frameRate;
    this._frameRateLimit = e, this.frameInterval = 1e3 / e, this._mode === "auto" && (this.stopAutoRendering(), this.startAutoRendering());
  }
  /**
   * Set the font size used for rendering.
   * @param size The font size to set.
   * 
   * @example
   * ```javascript
   * // Fetch a canvas element to apply textmode rendering to
   * const canvas = document.querySelector('canvas#myCanvas');
   * 
   * // Create a Textmodifier instance
   * const textmodifier = await textmode.create(canvas);
   * 
   * // Set the font size to 24
   * textmodifier.fontSize(24);
   * ```
   */
  fontSize(e) {
    p.validate(
      typeof e == "number" && e > 0,
      "Font size must be a positive number greater than 0.",
      { method: "fontSize", providedValue: e }
    ) && this._font.fontSize !== e && (this._font.setFontSize(e), this._grid.resizeCellPixelDimensions(this._font.maxGlyphDimensions.width, this._font.maxGlyphDimensions.height), this._pipeline.resize(), this._renderer.resetViewport());
  }
  /**
   * Set a draw callback function that will be executed before each render.
   * This method is primarily useful for standalone textmodifier instances.
   * @param callback The function to call before each render
   * 
   * @example
   * ```javascript
   * // Create a standalone textmodifier instance
   * const t = await textmode.create({
   *  width: 800,
   *  height: 600,
   * });
   * 
   * // Set up draw callback
   * t.draw(() => {
   *   // Set background color
   *   t.background(128);
   *   
   *   // Draw some content
   *   t.fill(255, 0, 0); // Set fill color to red
   *   t.rect(50, 50, 100, 100);
   * });
   * ```
   */
  draw(e) {
    this._drawCallback = e;
  }
  /**
   * Set a callback function that will be called when the window is resized.
   * @param callback The function to call when the window is resized.
   * 
   * @example
   * ```javascript
   * // Create a standalone textmodifier instance
   * const t = await textmode.create({
   *  width: window.innerWidth,
   *  height: window.innerHeight,
   * });
   * 
   * // Draw callback to update content
   * t.draw(() => {
   *   // Set background color
   *   t.background(128);
   * 
   *   // Draw some content
   *   t.fill(255, 0, 0); // Set fill color to red
   *   t.rect(50, 50, 100, 100);
   * });
   * 
   * // Set up window resize callback
   * t.windowResized(() => {
   *   // Resize the canvas to match window size
   *   t.resizeCanvas(window.innerWidth, window.innerHeight);
   * });
   * 
   */
  windowResized(e) {
    this._resizedCallback = e;
  }
  /**
   * Resize the `textmode.js` canvas.
   * @param width The new width of the canvas.
   * @param height The new height of the canvas.
   */
  resizeCanvas(e, t) {
    this.textmodeCanvas.resize(e, t), this._canvasFramebuffer.resize(this.textmodeCanvas.width, this.textmodeCanvas.height), this._grid.resize(), this._pipeline.resize(), this._renderer.resetViewport(), this._mode !== "manual" && this.render();
  }
  /**
   * @inheritDoc TextmodeConversionPipeline.get
   * 
   * @example
   * ```javascript
   * // Fetch a canvas element to apply textmode rendering to
   * const canvas = document.querySelector('canvas#myCanvas');
   * 
   * // Create a Textmodifier instance
   * const textmodifier = await textmode.create(canvas);
   * 
   * // Get the pre-defined brightness converter from the pipeline
   * const brightnessConverter = textmodifier.converter('brightness');
   * 
   * // Update properties of the brightness converter
   * brightnessConverter.invert(true);
   * brightnessConverter.characters(" .,;:*");
   * ```
   */
  converter(e) {
    return this._pipeline.get(e);
  }
  /**
   * Sets the fill color for subsequent rendering operations
   * @param r Red component (0-255)
   * @param g Green component (0-255, optional)
   * @param b Blue component (0-255, optional)
   * @param a Alpha component (0-255, optional)
   * 
   * @example
   * ```javascript
   * const t = await textmode.create({
   *   width: 800,
   *   height: 600,
   * })
   * 
   * t.draw(() => {
   *   // Set the background color to black
   *   t.background(0);
   * 
   *   const centerX = t.width / 2;
   *   const centerY = t.height / 2;
   *   const radius = Math.min(t.width, t .height) / 3;
   *   const speed = 0.02; // Adjust speed of rotation
   *
   *   const angle = t.frameCount * speed;
   *   const x = centerX + Math.cos(angle) * radius - 100;
   *   const y = centerY + Math.sin(angle) * radius - 50;
   *
   *   // Set the fill color to white
   *   t.fill(255);
   * 
   *   // Draw a rectangle with the fill color
   *   t.rect(x, y, 200, 150);
   * });
   * ```
   */
  fill(e, t, r, i) {
    this._renderer.fill(e, t, r, i);
  }
  /**
   * Draw a rectangle with the current shader or fill color.
   * @param x X-coordinate of the rectangle
   * @param y Y-coordinate of the rectangle
   * @param width Width of the rectangle
   * @param height Height of the rectangle
   * 
   * @example
   * ```javascript
   * const t = await textmode.create({
   *   width: 800,
   *   height: 600,
   * })
   * 
   * t.draw(() => {
   *   // Set the background color to black
   *   t.background(0);
   * 
   *   const centerX = t.width / 2;
   *   const centerY = t.height / 2;
   *   const radius = Math.min(t.width, t .height) / 3;
   *   const speed = 0.02; // Adjust speed of rotation
   *
   *   const angle = t.frameCount * speed;
   *   const x = centerX + Math.cos(angle) * radius - 100;
   *   const y = centerY + Math.sin(angle) * radius - 50;
   *
   *   // Set the fill color to white
   *   t.fill(255);
   * 
   *   // Draw a rectangle with the fill color
   *   t.rect(x, y, 200, 150);
   * });
   * ```
   */
  rect(e, t, r = 1, i = 1) {
    this._renderer.rect(e, t, r, i);
  }
  /**
   * Set the background color for the canvas.
   * @param r Red component (0-255)
   * @param g Green component (0-255, optional)
   * @param b Blue component (0-255, optional)
   * @param a Alpha component (0-255, optional)
   * 
   * @example
   * ```javascript
   * const t = await textmode.create({
   *   width: 800,
   *   height: 600,
   * })
   * 
   * t.draw(() => {
   *   // Set the background color to black
   *   t.background(0);
   * 
   *   const centerX = t.width / 2;
   *   const centerY = t.height / 2;
   *   const radius = Math.min(t.width, t .height) / 3;
   *   const speed = 0.02; // Adjust speed of rotation
   *
   *   const angle = t.frameCount * speed;
   *   const x = centerX + Math.cos(angle) * radius - 100;
   *   const y = centerY + Math.sin(angle) * radius - 50;
   *
   *   // Set the fill color to white
   *   t.fill(255);
   * 
   *   // Draw a rectangle with the fill color
   *   t.rect(x, y, 200, 150);
   * });
   * ```
   */
  background(e, t = e, r = e, i = 255) {
    this._renderer.background(e, t, r, i);
  }
  /**
   * Create a shader program from vertex and fragment source code.
   * @param vertexSource The GLSL source code for the vertex shader.
   * @param fragmentSource The GLSL source code for the fragment shader.
   * @returns The created shader program for use in `textmode.js`.
   */
  createShader(e, t) {
    return this._renderer.createShader(e, t);
  }
  /**
   * Set the current shader for rendering.
   * @param shader The shader program to use for rendering.
   */
  shader(e) {
    this._renderer.shader(e);
  }
  /**
   * Set a uniform variable for the current shader.
   * @param name The name of the uniform variable to set.
   * @param value The value to set for the uniform variable.
   */
  setUniform(e, t) {
    this._renderer.setUniform(e, t);
  }
  /** Get the current grid object used for rendering. */
  get grid() {
    return this._grid;
  }
  /** Get the current font object used for rendering. */
  get font() {
    return this._font;
  }
  /** Get the current rendering mode.*/
  get mode() {
    return this._mode;
  }
  /** Get the current textmode conversion pipeline. */
  get pipeline() {
    return this._pipeline;
  }
  /** Get the current frame count. */
  get frameCount() {
    return this._frameCount;
  }
  /** Get the width of the canvas. */
  get width() {
    return this.textmodeCanvas.width;
  }
  /** Get the height of the canvas. */
  get height() {
    return this.textmodeCanvas.height;
  }
}
class $ {
  /**
   * Create a {@link Textmodifier} instance for textmode rendering.
   * 
   * @param sourceOrOptions - Either an HTML canvas/video element for capturing content, or options for standalone mode.
   * @param opts - Optional configuration options *(only used when first parameter is a canvas/video element)*.
   * @returns A Promise that resolves to a Textmodifier instance.
   * 
   * @example
   * ```javascript
   * // Create a Textmodifier for an existing canvas
   * const canvas = document.querySelector('canvas#myCanvas');
   * const textmodifier = await textmode.create(canvas);
   * 
   * ////////
   * 
   * // Create a Textmodifier for a video element
   * const video = document.querySelector('video#myVideo');
   * const textmodifier = await textmode.create(video);
   * 
   * ////////
   * 
   * // Create a standalone Textmodifier
   * const t = await textmode.create({ width: 800, height: 600 });
   * 
   * // Set up a draw loop for standalone usage
   * t.draw(() => {
   *   t.background(0);
   * 
   *   const centerX = t.width / 2;
   *   const centerY = t.height / 2;
   *   const radius = Math.min(t.width, t .height) / 3;
   *   const speed = 0.02; // Adjust speed of rotation
   *
   *   const angle = t.frameCount * speed;
   *   const x = centerX + Math.cos(angle) * radius - 100;
   *   const y = centerY + Math.sin(angle) * radius - 50;
   *
   *   // Set the fill color to white
   *   t.fill(255);
   * 
   *   // Draw a rectangle with the fill color
   *   t.rect(x, y, 200, 150);
   * });
   * ```
   */
  static async create(e, t = {}) {
    if (e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement)
      return D.create(e, t);
    {
      const r = e || {};
      return D.create(null, r);
    }
  }
  /**
   * Set the global error handling level for the library. This applies to all `Textmodifier` instances.
   * @param level The error handling level to set.
   * 
   * @example
   * ```javascript
   * // Set error level to WARNING
   * textmode.setErrorLevel(TextmodeErrorLevel.WARNING);
   * ```
   */
  static setErrorLevel(e) {
    p.setGlobalLevel(e);
  }
  /**
   * Returns the current version of the `textmode.js` library.
   * 
   * @example
   * ```javascript
   * console.log(textmode.version); // "1.0.0"
   * ```
   */
  static get version() {
    return "0.1.2";
  }
  constructor() {
    throw new Error("Textmode is a static class and cannot be instantiated.");
  }
}
const Ee = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), Re = $.create, Ue = $.setErrorLevel, Me = $.version;
export {
  ae as TextmodeCanvas,
  fe as TextmodeConversionPipeline,
  Y as TextmodeErrorLevel,
  re as TextmodeFont,
  ie as TextmodeGrid,
  D as Textmodifier,
  Se as converters,
  Re as create,
  $ as default,
  Ee as export,
  Ue as setErrorLevel,
  $ as textmode,
  Me as version
};
