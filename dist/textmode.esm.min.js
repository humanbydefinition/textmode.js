var st = Object.defineProperty;
var it = (a, t, e) => t in a ? st(a, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : a[t] = e;
var h = (a, t, e) => it(a, typeof t != "symbol" ? t + "" : t, e);
class w extends Error {
  constructor(t, e = {}) {
    super(w.i(t, e)), this.name = "TextmodeError";
  }
  static i(t, e) {
    let r = t;
    if (e && Object.keys(e).length > 0) {
      r += `

ðŸ“‹ Context:`;
      for (const [s, i] of Object.entries(e))
        r += `
  - ${s}: ${w.o(i)}`;
    }
    return r += `

`, r += "â†“".repeat(24) + `
`, r;
  }
  static o(t) {
    if (t === null) return "null";
    if (t === void 0) return "undefined";
    if (typeof t == "string") return `"${t}"`;
    if (typeof t == "number" || typeof t == "boolean") return t + "";
    if (Array.isArray(t)) return t.length === 0 ? "[]" : t.length <= 5 ? `[${t.map((e) => w.o(e)).join(", ")}]` : `[${t.slice(0, 3).map((e) => w.o(e)).join(", ")}, ... +${t.length - 3} more]`;
    if (typeof t == "object") {
      const e = Object.keys(t);
      return e.length === 0 ? "{}" : e.length <= 3 ? `{ ${e.map((r) => `${r}: ${w.o(t[r])}`).join(", ")} }` : `{ ${e.slice(0, 2).map((r) => `${r}: ${w.o(t[r])}`).join(", ")}, ... +${e.length - 2} more }`;
    }
    return t + "";
  }
}
var ot = ((a) => (a[a.SILENT = 0] = "SILENT", a[a.WARNING = 1] = "WARNING", a[a.ERROR = 2] = "ERROR", a[a.THROW = 3] = "THROW", a))(ot || {});
const A = class A {
  constructor() {
    h(this, "l", { globalLevel: 3 });
  }
  static u() {
    return A.h || (A.h = new A()), A.h;
  }
  p(t, e) {
    const r = "%c[textmode.js] Oops! (â•¯Â°â–¡Â°)â•¯ï¸µ Something went wrong in your code.", s = "color: #f44336; font-weight: bold; background: #ffebee; padding: 2px 6px; border-radius: 3px;";
    switch (this.l.globalLevel) {
      case 0:
        return !1;
      case 1:
        return console.group(r, s), console.warn(w.i(t, e)), console.groupEnd(), !1;
      case 2:
        return console.group(r, s), console.error(w.i(t, e)), console.groupEnd(), !1;
      default:
        throw new w(t, e);
    }
  }
  m(t, e, r) {
    return !!t || (this.p(e, r), !1);
  }
  _(t) {
    this.l.globalLevel = t;
  }
};
h(A, "h", null);
let B = A;
const x = B.u(), Y = /* @__PURE__ */ new WeakMap();
function $(a, t) {
  Y.set(a, t);
}
function q(a) {
  return Y.get(a);
}
class K {
  constructor(t, e = t, r = {}) {
    h(this, "v");
    h(this, "C");
    h(this, "l");
    h(this, "$", null);
    this.v = t, this.C = e, this.l = { filter: "nearest", wrap: "clamp", format: "rgba", type: "unsigned_byte", ...r };
  }
  get width() {
    return this.v;
  }
  get height() {
    return this.C;
  }
  get pixels() {
    return this.$;
  }
  get options() {
    return { ...this.l };
  }
  validateCoordinates(t, e, r = !0) {
    return (t < 0 || e < 0 || t >= this.v || e >= this.C) && r && console.warn("The x and y values passed to Framebuffer.get are outside of its range and will be clamped."), [Math.max(0, Math.min(t, this.v - 1)), Math.max(0, Math.min(e, this.C - 1))];
  }
  validateRegion(t, e, r, s) {
    return [t = Math.max(0, Math.min(t, this.v - 1)), e = Math.max(0, Math.min(e, this.C - 1)), r = Math.max(1, Math.min(r, this.v - t)), s = Math.max(1, Math.min(s, this.C - e))];
  }
  updateDimensions(t, e) {
    this.v = t, this.C = e, this.$ = null;
  }
}
class Q extends K {
  constructor(e, r, s = r, i = {}) {
    super(r, s, i);
    h(this, "F");
    h(this, "M");
    h(this, "S");
    h(this, "D", null);
    this.F = e, this.S = this.R(), this.M = e.createFramebuffer(), this.V();
  }
  I(e) {
    const { F: r } = this, s = r.getParameter(r.FRAMEBUFFER_BINDING);
    r.bindFramebuffer(r.FRAMEBUFFER, this.M);
    try {
      return e();
    } finally {
      r.bindFramebuffer(r.FRAMEBUFFER, s);
    }
  }
  R() {
    const { F: e } = this, r = e.createTexture();
    e.bindTexture(e.TEXTURE_2D, r);
    const s = this.l.filter === "linear" ? e.LINEAR : e.NEAREST, i = this.l.wrap === "repeat" ? e.REPEAT : e.CLAMP_TO_EDGE;
    return e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, s), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, s), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, i), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, i), this.k(), r;
  }
  k() {
    const { F: e } = this, r = this.l.type === "float" ? e.FLOAT : e.UNSIGNED_BYTE;
    e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, this.v, this.C, 0, e.RGBA, r, null);
  }
  V() {
    const { F: e } = this;
    e.bindFramebuffer(e.FRAMEBUFFER, this.M), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, this.S, 0), e.bindFramebuffer(e.FRAMEBUFFER, null);
  }
  P(e) {
    const { F: r } = this;
    r.bindTexture(r.TEXTURE_2D, this.S), r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, 1), r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, r.RGBA, r.UNSIGNED_BYTE, e), r.bindTexture(r.TEXTURE_2D, null);
  }
  updatePixels(e, r, s) {
    const { F: i } = this;
    i.bindTexture(i.TEXTURE_2D, this.S), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, r, s, 0, i.RGBA, i.UNSIGNED_BYTE, e), i.bindTexture(i.TEXTURE_2D, null);
  }
  resize(e, r) {
    const { F: s } = this;
    this.updateDimensions(e, r), s.bindTexture(s.TEXTURE_2D, this.S), this.k(), s.bindTexture(s.TEXTURE_2D, null);
  }
  begin() {
    const { F: e } = this;
    this.D = { framebuffer: e.getParameter(e.FRAMEBUFFER_BINDING), viewport: e.getParameter(e.VIEWPORT) }, e.bindFramebuffer(e.FRAMEBUFFER, this.M), e.viewport(0, 0, this.v, this.C), $(e, [0, 0, this.v, this.C]);
  }
  end() {
    if (!this.D) return;
    const { F: e } = this;
    e.bindFramebuffer(e.FRAMEBUFFER, this.D.framebuffer), e.viewport(...this.D.viewport), $(e, this.D.viewport), this.D = null;
  }
  loadPixels() {
    const { F: e } = this;
    this.$ || (this.$ = new Uint8Array(this.v * this.C * 4)), this.I(() => {
      e.readPixels(0, 0, this.v, this.C, e.RGBA, e.UNSIGNED_BYTE, this.$);
    });
  }
  get(e, r, s, i) {
    const { F: o } = this;
    if (e === void 0 && r === void 0) {
      const n = new Uint8Array(this.v * this.C * 4);
      return this.I(() => (o.readPixels(0, 0, this.v, this.C, o.RGBA, o.UNSIGNED_BYTE, n), n));
    }
    if (s === void 0 && i === void 0) {
      const [n, l] = this.validateCoordinates(e, r), c = new Uint8Array(4);
      return this.I(() => (o.readPixels(n, l, 1, 1, o.RGBA, o.UNSIGNED_BYTE, c), [c[0], c[1], c[2], c[3]]));
    }
    {
      const [n, l, c, u] = this.validateRegion(e, r, s, i), f = new Uint8Array(c * u * 4);
      return this.I(() => (o.readPixels(n, l, c, u, o.RGBA, o.UNSIGNED_BYTE, f), f));
    }
  }
  A() {
    this.M && this.F.deleteFramebuffer(this.M), this.S && this.F.deleteTexture(this.S);
  }
  get framebuffer() {
    return this.M;
  }
  get texture() {
    return this.S;
  }
}
class J {
  constructor() {
    h(this, "G", !1);
  }
  get isReady() {
    return this.G;
  }
  setUniforms(t) {
    for (const [e, r] of Object.entries(t)) this.setUniform(e, r);
  }
}
class y extends J {
  constructor(e, r, s) {
    super();
    h(this, "F");
    h(this, "U");
    h(this, "L", /* @__PURE__ */ new Map());
    h(this, "O", /* @__PURE__ */ new Map());
    h(this, "j", 0);
    h(this, "H");
    this.F = e, this.U = this.W(r, s), this.H = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), this.N(), this.G = !0;
  }
  static fromSource(e, r) {
    return new y(e, r.vertex, r.fragment);
  }
  N() {
    const e = this.F.getProgramParameter(this.U, this.F.ACTIVE_UNIFORMS);
    for (let r = 0; r < e; r++) {
      const s = this.F.getActiveUniform(this.U, r);
      if (s) {
        const i = this.F.getUniformLocation(this.U, s.name);
        i && (this.L.set(s.name, i), this.O.set(s.name, s.type));
      }
    }
  }
  W(e, r) {
    const s = this.X(this.F.VERTEX_SHADER, e), i = this.X(this.F.FRAGMENT_SHADER, r), o = this.F.createProgram();
    if (this.F.attachShader(o, s), this.F.attachShader(o, i), this.F.linkProgram(o), !this.F.getProgramParameter(o, this.F.LINK_STATUS)) {
      const n = this.F.getProgramInfoLog(o);
      throw Error("Shader program link error: " + n);
    }
    return this.F.deleteShader(s), this.F.deleteShader(i), o;
  }
  X(e, r) {
    const s = this.F.createShader(e);
    if (this.F.shaderSource(s, r), this.F.compileShader(s), !this.F.getShaderParameter(s, this.F.COMPILE_STATUS)) {
      const i = this.F.getShaderInfoLog(s);
      throw this.F.deleteShader(s), Error("Shader compilation error: " + i);
    }
    return s;
  }
  q() {
    this.F.useProgram(this.U), this.Y();
  }
  Y() {
    this.j = 0;
  }
  setUniform(e, r) {
    const s = this.L.get(e);
    if (s) if (typeof r == "number")
      this.Z(e) ? this.F.uniform1i(s, Math.floor(r)) : this.F.uniform1f(s, r);
    else if (typeof r == "boolean") this.F.uniform1i(s, r ? 1 : 0);
    else if (Array.isArray(r)) switch (r.length) {
      case 2:
        this.F.uniform2f(s, r[0], r[1]);
        break;
      case 3:
        this.F.uniform3f(s, r[0], r[1], r[2]);
        break;
      case 4:
        this.F.uniform4f(s, r[0], r[1], r[2], r[3]);
        break;
      default:
        console.warn(`Unsupported array length ${r.length} for uniform '${e}'`);
    }
    else if (r instanceof WebGLTexture) {
      const i = this.J();
      this.F.uniform1i(s, i), this.F.activeTexture(this.F.TEXTURE0 + i), this.F.bindTexture(this.F.TEXTURE_2D, r);
    } else if (r instanceof Q) {
      const i = this.J();
      this.F.uniform1i(s, i), this.F.activeTexture(this.F.TEXTURE0 + i), this.F.bindTexture(this.F.TEXTURE_2D, r.texture);
    } else if (typeof r == "object" && "texture" in r) {
      const i = this.J();
      this.F.uniform1i(s, i), this.F.activeTexture(this.F.TEXTURE0 + i), this.F.bindTexture(this.F.TEXTURE_2D, r.texture);
    } else console.warn(`Unsupported uniform type for '${e}':`, typeof r);
  }
  J() {
    return this.j >= this.H && console.warn(`Exceeded maximum texture units (${this.H}). Texture may not render correctly.`), this.j++;
  }
  Z(e) {
    const r = this.O.get(e);
    return !!r && (r === this.F.INT || r === this.F.INT_VEC2 || r === this.F.INT_VEC3 || r === this.F.INT_VEC4 || r === this.F.SAMPLER_2D || r === this.F.SAMPLER_CUBE);
  }
  get glProgram() {
    return this.U;
  }
  A() {
    this.F.deleteProgram(this.U);
  }
}
class tt {
  constructor(t) {
    h(this, "F");
    h(this, "K", null);
    h(this, "tt", 16);
    h(this, "et", /* @__PURE__ */ new Map());
    this.F = t;
  }
  rt() {
    if (this.K) return;
    const t = this.F;
    this.K = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this.K);
  }
  st() {
    const t = this.F, e = t.getParameter(t.CURRENT_PROGRAM);
    let r = this.et.get(e);
    return r || (r = { a_position: t.getAttribLocation(e, "a_position"), a_texCoord: t.getAttribLocation(e, "a_texCoord") }, this.et.set(e, r)), t.enableVertexAttribArray(r.a_position), t.vertexAttribPointer(r.a_position, 2, t.FLOAT, !1, this.tt, 0), t.enableVertexAttribArray(r.a_texCoord), t.vertexAttribPointer(r.a_texCoord, 2, t.FLOAT, !1, this.tt, 8), { positionLoc: r.a_position, texLoc: r.a_texCoord };
  }
  it(t, e) {
    const r = this.F;
    r.disableVertexAttribArray(t), r.disableVertexAttribArray(e);
  }
  ot(t, e) {
    const r = this.F, s = q(r) || [0, 0, r.canvas.width, r.canvas.height];
    return { nx: t / s[2] * 2 - 1, ny: 1 - e / s[3] * 2 };
  }
  nt(t, e, r, s) {
    const i = this.F;
    this.rt(), i.bindBuffer(i.ARRAY_BUFFER, this.K);
    const o = new Float32Array([t, s, 0, 0, r, s, 1, 0, t, e, 0, 1, t, e, 0, 1, r, s, 1, 0, r, e, 1, 1]);
    i.bufferData(i.ARRAY_BUFFER, o, i.DYNAMIC_DRAW);
  }
  A() {
    this.K && this.F.deleteBuffer(this.K);
  }
}
class nt extends tt {
  constructor(t) {
    super(t);
  }
  ht(t, e, r, s) {
    const i = this.ot(t, e), o = this.ot(t + r, e + s);
    this.nt(i.nx, i.ny, o.nx, o.ny);
    const n = this.st();
    this.F.drawArrays(this.F.TRIANGLES, 0, 6), this.it(n.positionLoc, n.texLoc);
  }
  lt(t, e, r, s, i) {
    this.ht(t, e, r, i), this.ht(t + r - i, e, i, s), this.ht(t, e + s - i, r, i), this.ht(t, e, i, s);
  }
}
class at extends tt {
  constructor(t) {
    super(t);
  }
  ct(t, e, r, s, i) {
    const o = r - t, n = s - e, l = Math.hypot(o, n);
    if (l === 0) {
      const u = i / 2, f = this.ot(t - u, e - u), d = this.ot(t + u, e + u);
      this.nt(f.nx, f.ny, d.nx, d.ny);
    } else {
      const u = -n / l, f = o / l, d = i / 2, p = t + u * d, m = e + f * d, g = t - u * d, C = e - f * d, b = r + u * d, v = s + f * d, F = r - u * d, T = s - f * d, S = this.ot(p, m), R = this.ot(g, C), M = this.ot(b, v), j = this.ot(F, T), D = this.F;
      this.rt(), D.bindBuffer(D.ARRAY_BUFFER, this.K);
      const rt = new Float32Array([S.nx, S.ny, 0, 0, R.nx, R.ny, 0, 1, M.nx, M.ny, 1, 0, R.nx, R.ny, 0, 1, j.nx, j.ny, 1, 1, M.nx, M.ny, 1, 0]);
      D.bufferData(D.ARRAY_BUFFER, rt, D.DYNAMIC_DRAW);
    }
    const c = this.st();
    this.F.drawArrays(this.F.TRIANGLES, 0, 6), this.it(c.positionLoc, c.texLoc);
  }
}
var G = "attribute vec2 a_position;attribute vec2 a_texCoord;varying vec2 v_uv;uniform float u_rotation;uniform vec2 u_center;uniform float u_aspectRatio;mat2 rotate2D(float angle){float s=sin(angle);float c=cos(angle);return mat2(c,-s,s,c);}void main(){v_uv=a_texCoord;vec2 pos=a_position;pos-=u_center;pos.x*=u_aspectRatio;pos=rotate2D(-u_rotation)*pos;pos.x/=u_aspectRatio;pos+=u_center;gl_Position=vec4(pos,0.0,1.0);}";
class ht {
  constructor(t) {
    h(this, "F");
    h(this, "ut");
    h(this, "ft");
    h(this, "dt", null);
    h(this, "gt");
    h(this, "_t");
    h(this, "vt", [1, 1, 1, 1]);
    h(this, "xt", !0);
    h(this, "bt", [0, 0, 0, 1]);
    h(this, "wt", 1);
    h(this, "Ct", !0);
    h(this, "yt", 0);
    h(this, "$t", []);
    this.F = t, this.ut = new y(this.F, G, "precision lowp float;uniform sampler2D u_texture;varying vec2 v_uv;void main(){gl_FragColor=texture2D(u_texture,v_uv);}"), this.ft = new y(this.F, G, "precision lowp float;uniform vec4 u_color;void main(){gl_FragColor=u_color;}"), this.gt = new nt(this.F), this._t = new at(this.F), this.F.enable(this.F.BLEND), this.F.blendEquation(this.F.FUNC_ADD), this.F.blendFunc(this.F.ONE, this.F.ONE_MINUS_SRC_ALPHA), $(this.F, [0, 0, this.F.canvas.width, this.F.canvas.height]);
  }
  Ft(t) {
    this.dt !== t && (this.dt = t, t.q());
  }
  Tt(t, e, r, s) {
    if (this.xt = !0, e === void 0 && r === void 0 && s === void 0) {
      const i = t / 255;
      this.vt = [i, i, i, 1];
    } else if (r !== void 0 && s === void 0) this.vt = [t / 255, e / 255, r / 255, 1];
    else {
      if (r === void 0 || s === void 0) throw Error("Invalid fill parameters. Use fill(gray), fill(r,g,b), or fill(r,g,b,a)");
      this.vt = [t / 255, e / 255, r / 255, s / 255];
    }
  }
  Mt(t, e, r, s) {
    if (this.Ct = !0, e === void 0 && r === void 0 && s === void 0) {
      const i = t / 255;
      this.bt = [i, i, i, 1];
    } else if (r !== void 0 && s === void 0) this.bt = [t / 255, e / 255, r / 255, 1];
    else {
      if (r === void 0 || s === void 0) throw Error("Invalid stroke parameters. Use stroke(gray), stroke(r,g,b), or stroke(r,g,b,a)");
      this.bt = [t / 255, e / 255, r / 255, s / 255];
    }
  }
  St(t) {
    if (t < 0) throw Error("Stroke weight must be non-negative");
    this.wt = t;
  }
  Dt() {
    this.Ct = !1;
  }
  Rt() {
    this.xt = !1;
  }
  Vt(t) {
    this.yt = t;
  }
  It() {
    this.$t.push({ fillColor: [...this.vt], fillMode: this.xt, strokeColor: [...this.bt], strokeWeight: this.wt, strokeMode: this.Ct, rotation: this.yt });
  }
  kt() {
    const t = this.$t.pop();
    t ? (this.vt = t.fillColor, this.xt = t.fillMode, this.bt = t.strokeColor, this.wt = t.strokeWeight, this.Ct = t.strokeMode, this.yt = t.rotation) : console.warn("pop() called without matching push()");
  }
  Et() {
    this.dt = null, this.$t = [], this.yt = 0;
  }
  Pt(t) {
    const e = t.replace(/\/\*[\s\S]*?\*\//g, "").replace(/\/\/.*$/gm, "").trim().match(/^#version\s+(\d+)\s+(es)?/i);
    return e ? parseInt(e[1], 10) >= 300 : !1;
  }
  At(t, e) {
    return new y(this.F, t, e);
  }
  zt(t) {
    const e = this.Pt(t) ? `#version 300 es
in vec2 a_position;in vec2 a_texCoord;out vec2 v_uv;uniform float u_rotation;uniform vec2 u_center;uniform float u_aspectRatio;mat2 rotate2D(float angle){float s=sin(angle);float c=cos(angle);return mat2(c,-s,s,c);}void main(){v_uv=a_texCoord;vec2 pos=a_position;pos-=u_center;pos.x*=u_aspectRatio;pos=rotate2D(-u_rotation)*pos;pos.x/=u_aspectRatio;pos+=u_center;gl_Position=vec4(pos,0.0,1.0);}` : G;
    return new y(this.F, e, t);
  }
  Gt(t, e) {
    this.dt.setUniform(t, e);
  }
  Ut(t, e, r, s) {
    if (this.dt !== null) {
      const { centerX: f, centerY: d, radians: p, aspectRatio: m } = this.Lt(t, e, r, s);
      return this.Gt("u_rotation", p), this.Gt("u_center", [f, d]), this.Gt("u_aspectRatio", m), this.gt.ht(t, e, r, s), void (this.dt = null);
    }
    const i = this.ft;
    let o = 0, n = 0, l = 0, c = 1;
    const u = this.Lt(t, e, r, s);
    o = u.centerX, n = u.centerY, l = u.radians, c = u.aspectRatio, this.xt && (this.Ft(i), this.Gt("u_color", this.vt), this.Gt("u_rotation", l), this.Gt("u_center", [o, n]), this.Gt("u_aspectRatio", c), this.gt.ht(t, e, r, s)), this.Ct && this.wt > 0 && (this.Ft(i), this.Gt("u_color", this.bt), this.Gt("u_rotation", l), this.Gt("u_center", [o, n]), this.Gt("u_aspectRatio", c), this.gt.lt(t, e, r, s, this.wt)), this.dt = null;
  }
  Ot(t, e, r, s) {
    if (this.dt !== null) {
      const g = (t + r) / 2, C = (e + s) / 2, b = Math.abs(r - t) || 1, v = Math.abs(s - e) || 1, { centerX: F, centerY: T, radians: S, aspectRatio: R } = this.Lt(g - b / 2, C - v / 2, b, v);
      this.Gt("u_rotation", S), this.Gt("u_center", [F, T]), this.Gt("u_aspectRatio", R);
      const M = this.wt > 0 ? this.wt : 1;
      return this._t.ct(t, e, r, s, M), void (this.dt = null);
    }
    if (!this.Ct || this.wt <= 0) return;
    const i = this.ft, o = (t + r) / 2, n = (e + s) / 2, l = Math.abs(r - t) || 1, c = Math.abs(s - e) || 1, u = this.yt !== 0;
    let f = 0, d = 0, p = 0, m = 1;
    if (u) {
      const g = this.Lt(o - l / 2, n - c / 2, l, c);
      f = g.centerX, d = g.centerY, p = g.radians, m = g.aspectRatio;
    }
    this.Ft(i), this.Gt("u_color", this.bt), u && (this.Gt("u_rotation", p), this.Gt("u_center", [f, d]), this.Gt("u_aspectRatio", m)), this._t.ct(t, e, r, s, this.wt);
  }
  Lt(t, e, r, s) {
    const i = q(this.F) || [0, 0, this.F.canvas.width, this.F.canvas.height], o = i[2], n = i[3], l = o / n;
    return { centerX: (t + r / 2) / o * 2 - 1, centerY: 1 - (e + s / 2) / n * 2, radians: this.yt * Math.PI / 180, aspectRatio: l };
  }
  jt(t, e, r = {}) {
    return new Q(this.F, t, e, r);
  }
  Ht(t, e = t, r = t, s = 255) {
    this.Bt(t / 255, e / 255, r / 255, s / 255);
  }
  Bt(t = 0, e = 0, r = 0, s = 0) {
    this.F.clearColor(t, e, r, s), this.F.clear(this.F.COLOR_BUFFER_BIT);
  }
  Wt() {
    this.F.viewport(0, 0, this.F.canvas.width, this.F.canvas.height), $(this.F, [0, 0, this.F.canvas.width, this.F.canvas.height]);
  }
  get context() {
    return this.F;
  }
  A() {
    this.ut.A(), this.ft.A(), this.gt.A(), this._t.A();
  }
  Nt(t, e, r, s, i) {
    const o = this.F, n = s ?? t.width, l = i ?? t.height;
    this.Ft(this.ut), this.Gt("u_texture", t);
    const c = this.Lt(e, r, n, l);
    this.Gt("u_rotation", c.radians), this.Gt("u_center", [c.centerX, c.centerY]), this.Gt("u_aspectRatio", c.aspectRatio), this.gt.ht(e, r, n, l), o.bindTexture(o.TEXTURE_2D, null), this.dt = null;
  }
}
const _ = { readShort: (a, t) => (_.t.uint16[0] = a[t] << 8 | a[t + 1], _.t.int16[0]), readUshort: (a, t) => a[t] << 8 | a[t + 1], readUshorts(a, t, e) {
  const r = [];
  for (let s = 0; s < e; s++) r.push(_.readUshort(a, t + 2 * s));
  return r;
}, readUint(a, t) {
  const e = _.t.uint8;
  return e[3] = a[t], e[2] = a[t + 1], e[1] = a[t + 2], e[0] = a[t + 3], _.t.uint32[0];
}, readASCII(a, t, e) {
  let r = "";
  for (let s = 0; s < e; s++) r += String.fromCharCode(a[t + s]);
  return r;
}, t: (() => {
  const a = new ArrayBuffer(8);
  return { uint8: new Uint8Array(a), int16: new Int16Array(a), uint16: new Uint16Array(a), uint32: new Uint32Array(a) };
})() }, lt = { parseTab(a, t, e) {
  const r = { tables: [], ids: {}, off: t };
  a = new Uint8Array(a.buffer, t, e), t = 0;
  const s = _, i = s.readUshort, o = i(a, t += 2);
  t += 2;
  const n = [];
  for (let l = 0; l < o; l++) {
    const c = i(a, t), u = i(a, t += 2);
    t += 2;
    const f = s.readUint(a, t);
    t += 4;
    const d = `p${c}e${u}`;
    let p = n.indexOf(f);
    if (p === -1) {
      let m;
      p = r.tables.length, n.push(f);
      const g = i(a, f);
      m = g === 4 ? this.parse4(a, f) : g === 12 ? this.parse12(a, f) : { format: g }, r.tables.push(m);
    }
    r.ids[d] != null && console.warn("Multiple tables for one platform+encoding: " + d), r.ids[d] = p;
  }
  return r;
}, parse4(a, t) {
  const e = _, r = e.readUshort, s = e.readUshorts, i = t, o = r(a, t += 2);
  t += 2;
  const n = r(a, t += 2) >>> 1, l = { format: 4, searchRange: r(a, t += 2), entrySelector: 0, rangeShift: 0, endCount: [], startCount: [], idDelta: [], idRangeOffset: [], glyphIdArray: [] };
  t += 2, l.entrySelector = r(a, t), t += 2, l.rangeShift = r(a, t), t += 2, l.endCount = s(a, t, n), t += 2 * n, t += 2, l.startCount = s(a, t, n), t += 2 * n;
  for (let c = 0; c < n; c++) l.idDelta.push(e.readShort(a, t)), t += 2;
  return l.idRangeOffset = s(a, t, n), t += 2 * n, l.glyphIdArray = s(a, t, i + o - t >> 1), l;
}, parse12(a, t) {
  const e = _.readUint;
  e(a, t += 4), e(a, t += 4);
  const r = e(a, t += 4);
  t += 4;
  const s = new Uint32Array(3 * r);
  for (let i = 0; i < 3 * r; i += 3) s[i] = e(a, t + (i << 2)), s[i + 1] = e(a, t + (i << 2) + 4), s[i + 2] = e(a, t + (i << 2) + 8);
  return { format: 12, groups: s };
} }, ct = { parseTab(a, t, e) {
  const r = _;
  t += 18;
  const s = r.readUshort(a, t);
  t += 2, t += 16;
  const i = r.readShort(a, t);
  t += 2;
  const o = r.readShort(a, t);
  t += 2;
  const n = r.readShort(a, t);
  t += 2;
  const l = r.readShort(a, t);
  return t += 2, t += 6, { unitsPerEm: s, xMin: i, yMin: o, xMax: n, yMax: l, indexToLocFormat: r.readShort(a, t) };
} }, ut = { parseTab(a, t, e) {
  const r = _;
  t += 4;
  const s = ["ascender", "descender", "lineGap", "advanceWidthMax", "minLeftSideBearing", "minRightSideBearing", "xMaxExtent", "caretSlopeRise", "caretSlopeRun", "caretOffset", "res0", "res1", "res2", "res3", "metricDataFormat", "numberOfHMetrics"], i = {};
  for (let o = 0; o < s.length; o++) {
    const n = s[o], l = n === "advanceWidthMax" || n === "numberOfHMetrics" ? r.readUshort : r.readShort;
    i[n] = l(a, t + 2 * o);
  }
  return i;
} }, dt = { parseTab(a, t, e, r) {
  if (!r) throw Error("Font object required for hmtx parsing");
  const s = _, i = [], o = [], n = r.maxp.numGlyphs, l = r.hhea.numberOfHMetrics;
  let c = 0, u = 0, f = 0;
  for (; f < l; ) c = s.readUshort(a, t + (f << 2)), u = s.readShort(a, t + (f << 2) + 2), i.push(c), o.push(u), f++;
  for (; f < n; ) i.push(c), o.push(u), f++;
  return { aWidth: i, lsBearing: o };
} }, z = { cmap: lt, head: ct, hhea: ut, maxp: { parseTab(a, t, e) {
  const r = _;
  return r.readUint(a, t), t += 4, { numGlyphs: r.readUshort(a, t) };
} }, hmtx: dt, loca: { parseTab(a, t, e, r) {
  if (!r) throw Error("Font object required for loca parsing");
  const s = _, i = [], o = r.head.indexToLocFormat, n = r.maxp.numGlyphs + 1;
  if (o === 0) for (let l = 0; l < n; l++) i.push(s.readUshort(a, t + (l << 1)) << 1);
  else if (o === 1) for (let l = 0; l < n; l++) i.push(s.readUint(a, t + (l << 2)));
  return i;
} }, glyf: { parseTab(a, t, e, r) {
  if (!r) throw Error("Font object required for glyf parsing");
  const s = [], i = r.maxp.numGlyphs;
  for (let o = 0; o < i; o++) s.push(null);
  return s;
}, Xt(a, t) {
  const e = _, r = a.qt, s = a.loca;
  if (s[t] === s[t + 1]) return null;
  const i = E.findTable(r, "glyf", a.Yt);
  if (!i) return null;
  let o = i[0] + s[t];
  const n = {};
  if (n.noc = e.readShort(r, o), o += 2, n.xMin = e.readShort(r, o), o += 2, n.yMin = e.readShort(r, o), o += 2, n.xMax = e.readShort(r, o), o += 2, n.yMax = e.readShort(r, o), o += 2, n.xMin >= n.xMax || n.yMin >= n.yMax) return null;
  if (n.noc > 0) {
    n.endPts = [];
    for (let d = 0; d < n.noc; d++) n.endPts.push(e.readUshort(r, o)), o += 2;
    const l = e.readUshort(r, o);
    if (o += 2, r.length - o < l) return null;
    o += l;
    const c = n.endPts[n.noc - 1] + 1;
    n.flags = [];
    for (let d = 0; d < c; d++) {
      const p = r[o];
      if (o++, n.flags.push(p), 8 & p) {
        const m = r[o];
        o++;
        for (let g = 0; g < m; g++) n.flags.push(p), d++;
      }
    }
    n.xs = [];
    for (let d = 0; d < c; d++) {
      const p = n.flags[d], m = !!(16 & p);
      2 & p ? (n.xs.push(m ? r[o] : -r[o]), o++) : m ? n.xs.push(0) : (n.xs.push(e.readShort(r, o)), o += 2);
    }
    n.ys = [];
    for (let d = 0; d < c; d++) {
      const p = n.flags[d], m = !!(32 & p);
      4 & p ? (n.ys.push(m ? r[o] : -r[o]), o++) : m ? n.ys.push(0) : (n.ys.push(e.readShort(r, o)), o += 2);
    }
    let u = 0, f = 0;
    for (let d = 0; d < c; d++) u += n.xs[d], f += n.ys[d], n.xs[d] = u, n.ys[d] = f;
  } else n.parts = [], n.endPts = [], n.flags = [], n.xs = [], n.ys = [];
  return n;
} } }, E = { parse: (a) => [((t, e, r, s) => {
  const i = z, o = { qt: t, Qt: e, Yt: r };
  for (const n in i) {
    const l = n, c = E.findTable(t, l, r);
    if (c) {
      const [u, f] = c;
      let d = s[u];
      d == null && (d = i[l].parseTab(t, u, f, o), s[u] = d), o[l] = d;
    }
  }
  return o;
})(new Uint8Array(a), 0, 0, {})], findTable(a, t, e) {
  const r = _, s = r.readUshort(a, e + 4);
  let i = e + 12;
  for (let o = 0; o < s; o++) {
    const n = r.readASCII(a, i, 4);
    r.readUint(a, i + 4);
    const l = r.readUint(a, i + 8), c = r.readUint(a, i + 12);
    if (n === t) return [l, c];
    i += 16;
  }
  return null;
}, T: z, B: _ };
class I {
  constructor() {
    h(this, "Zt", /* @__PURE__ */ new Map());
    h(this, "Jt", /* @__PURE__ */ new Map());
  }
  Kt(t, e) {
    const r = `${this.te(t)}_${e}`;
    if (this.Zt.has(r)) return this.Zt.get(r);
    const s = t.cmap;
    if (!s || !s.tables) return this.Zt.set(r, 0), 0;
    let i = 0;
    for (const o of s.tables) if (o.format === 4 ? i = this.ee(e, o) : o.format === 12 && (i = this.re(e, o)), i > 0) break;
    return this.Zt.set(r, i), i;
  }
  se(t, e) {
    const r = e.codePointAt(0);
    return r === void 0 ? 0 : this.Kt(t, r);
  }
  ie(t, e) {
    const r = t.hmtx;
    return r && r.aWidth && r.aWidth.length !== 0 ? e < r.aWidth.length ? r.aWidth[e] : r.aWidth[r.aWidth.length - 1] : 0;
  }
  oe(t, e) {
    const r = e / t.head.unitsPerEm, s = t.hhea.ascender * r, i = t.hhea.descender * r, o = t.hhea.lineGap * r;
    return { ascender: s, descender: i, lineGap: o, lineHeight: s - i + o, unitsPerEm: t.head.unitsPerEm, scale: r };
  }
  ne() {
    this.Zt.clear(), this.Jt.clear();
  }
  te(t) {
    return `${t.Yt}_${t.qt.length}`;
  }
  ee(t, e) {
    const r = e.endCount.length;
    let s = -1;
    for (let i = 0; i < r; i++) if (t <= e.endCount[i]) {
      s = i;
      break;
    }
    if (s === -1 || t < e.startCount[s]) return 0;
    if (e.idRangeOffset[s] === 0) return t + e.idDelta[s] & 65535;
    {
      const i = e.idRangeOffset[s] / 2 + (t - e.startCount[s]) - (r - s);
      if (i >= 0 && i < e.glyphIdArray.length) {
        const o = e.glyphIdArray[i];
        return o === 0 ? 0 : o + e.idDelta[s] & 65535;
      }
    }
    return 0;
  }
  re(t, e) {
    const r = e.groups.length / 3;
    for (let s = 0; s < r; s++) {
      const i = e.groups[3 * s], o = e.groups[3 * s + 1], n = e.groups[3 * s + 2];
      if (t >= i && t <= o) return n + (t - i);
    }
    return 0;
  }
}
class ft {
  constructor(t) {
    h(this, "ae");
    this.ae = t;
  }
  he(t) {
    var r;
    const e = [];
    return (r = t == null ? void 0 : t.cmap) != null && r.tables ? (t.cmap.tables.forEach((s) => {
      if (s.format === 4) {
        const i = this.le(s);
        e.push(...i);
      } else if (s.format === 12) {
        const i = this.ce(s);
        e.push(...i);
      }
    }), [...new Set(e)]) : [];
  }
  ue(t, e) {
    return this.ae.se(t, e) > 0;
  }
  fe(t, e) {
    for (const r of e) if (!this.ue(t, r)) return !1;
    return !0;
  }
  de(t, e) {
    return e.filter((r) => this.ue(t, r));
  }
  pe(t) {
    return t.filter((e) => this.me(e));
  }
  le(t) {
    const e = [];
    if (!(t.startCount && t.endCount && t.idRangeOffset && t.idDelta)) return e;
    for (let r = 0; r < t.startCount.length; r++) {
      const s = t.startCount[r], i = t.endCount[r];
      if (s !== 65535 || i !== 65535) {
        for (let o = s; o <= i; o++)
          if (this.ge(t, o, r) > 0) try {
            const n = String.fromCodePoint(o);
            e.push(n);
          } catch {
          }
      }
    }
    return e;
  }
  ce(t) {
    const e = [];
    if (!t.groups) return e;
    for (let r = 0; r < t.groups.length; r += 3) {
      const s = t.groups[r], i = t.groups[r + 1], o = t.groups[r + 2];
      for (let n = s; n <= i; n++)
        if (o + (n - s) > 0) try {
          const l = String.fromCodePoint(n);
          e.push(l);
        } catch {
        }
    }
    return e;
  }
  ge(t, e, r) {
    if (t.idRangeOffset[r] === 0) return e + t.idDelta[r] & 65535;
    {
      const s = t.idRangeOffset[r] / 2 + (e - t.startCount[r]) - (t.startCount.length - r);
      if (s >= 0 && t.glyphIdArray && s < t.glyphIdArray.length) {
        const i = t.glyphIdArray[s];
        if (i !== 0) return i + t.idDelta[r] & 65535;
      }
    }
    return 0;
  }
  me(t) {
    const e = t.codePointAt(0) || 0;
    return !(e >= 0 && e <= 31 && e !== 9 && e !== 10 && e !== 13 || e >= 127 && e <= 159);
  }
}
class gt {
  constructor() {
    h(this, "_e");
    const t = new I();
    this._e = new ft(t);
  }
  extractCharacters(t) {
    return this._e.he(t);
  }
  filterProblematicCharacters(t) {
    return this._e.pe(t);
  }
  characterExists(t, e) {
    return this._e.ue(t, e);
  }
  allCharactersExist(t, e) {
    return this._e.fe(t, e);
  }
}
class mt {
  constructor(t) {
    h(this, "ve");
    h(this, "xe");
    h(this, "be");
    h(this, "we");
    this.be = t, this.we = new I(), this.ve = document.createElement("canvas"), this.xe = this.ve.getContext("2d", { willReadFrequently: !0, alpha: !1 });
  }
  createTextureAtlas(t, e, r, s) {
    const i = t.length, o = Math.ceil(Math.sqrt(i)), n = Math.ceil(i / o), l = e.width * o, c = e.height * n, u = typeof s == "object" ? s : null;
    this.Ce(l, c), this.ye(t, e, o, r, u);
    const f = this.be.jt(l, c, { filter: "nearest" });
    return f.P(this.ve), { framebuffer: f, columns: o, rows: n };
  }
  Ce(t, e) {
    this.ve.width = t, this.ve.height = e, this.ve.style.width = t + "px", this.ve.style.height = t + "px", this.xe.imageSmoothingEnabled = !1, this.ve.style.imageRendering = "pixelated", this.xe.fillStyle = "black", this.xe.fillRect(0, 0, t, e), this.xe.textBaseline = "top", this.xe.textAlign = "left", this.xe.fillStyle = "white";
  }
  ye(t, e, r, s, i) {
    const o = s / i.head.unitsPerEm;
    for (let n = 0; n < t.length; n++) {
      const l = n % r, c = Math.floor(n / r), u = t[n].character, f = this.$e(i, u);
      if (!f) continue;
      const d = u.codePointAt(0) || 0, p = this.we.Kt(i, d), m = this.Fe(i, p) * o, g = l * e.width, C = c * e.height, b = g + 0.5 * e.width, v = C + 0.5 * e.height, F = Math.round(b - 0.5 * e.width), T = Math.round(v - 0.5 * s), S = F + 0.5 * (e.width - m), R = T + i.hhea.ascender * o;
      this.Te(f, S, R, o);
    }
  }
  $e(t, e) {
    const r = e.codePointAt(0) || 0, s = this.we.Kt(t, r);
    if (s === 0) return null;
    if (t.glyf && t.glyf[s] !== null) return t.glyf[s];
    if (E && E.T && E.T.glyf) {
      const i = E.T.glyf.Xt(t, s);
      return t.glyf && i && (t.glyf[s] = i), i;
    }
    return null;
  }
  Fe(t, e) {
    const r = t.hmtx;
    return r && r.aWidth ? e < r.aWidth.length ? r.aWidth[e] : r.aWidth[r.aWidth.length - 1] : 0;
  }
  Te(t, e, r, s) {
    if (!t || !t.xs || t.noc === 0) return;
    const { xs: i, ys: o, endPts: n, flags: l } = t;
    if (!(i && o && n && l)) return;
    this.xe.beginPath();
    let c = 0;
    for (let u = 0; u < n.length; u++) {
      const f = n[u];
      if (!(f < c)) {
        if (f >= c) {
          const d = e + i[c] * s, p = r - o[c] * s;
          this.xe.moveTo(d, p);
          let m = c + 1;
          for (; m <= f; )
            if (1 & l[m]) {
              const g = e + i[m] * s, C = r - o[m] * s;
              this.xe.lineTo(g, C), m++;
            } else {
              const g = e + i[m] * s, C = r - o[m] * s;
              let b = m + 1 > f ? c : m + 1;
              if (1 & l[b]) {
                const v = e + i[b] * s, F = r - o[b] * s;
                this.xe.quadraticCurveTo(g, C, v, F), m = b + 1;
              } else {
                const v = (g + (e + i[b] * s)) / 2, F = (C + (r - o[b] * s)) / 2;
                this.xe.quadraticCurveTo(g, C, v, F), m = b;
              }
            }
          this.xe.closePath();
        }
        c = f + 1;
      }
    }
    this.xe.fill();
  }
}
class pt {
  constructor() {
    h(this, "ae");
    this.ae = new I();
  }
  calculateMaxGlyphDimensions(t, e, r) {
    let s = 0;
    const i = this.ae.oe(r, e), o = i.lineHeight;
    for (const n of t) {
      const l = this.ae.se(r, n);
      if (l === 0) continue;
      const c = this.ae.ie(r, l) * i.scale;
      s = Math.max(s, c);
    }
    return { width: Math.ceil(s), height: Math.ceil(o) };
  }
  getCharacterAdvanceWidth(t, e, r) {
    const s = this.ae.oe(r, e), i = this.ae.se(r, t);
    return this.ae.ie(r, i) * s.scale;
  }
  getFontMetrics(t, e) {
    return this.ae.oe(e, t);
  }
  ne() {
    this.ae.ne();
  }
}
class bt {
  constructor() {
    h(this, "we");
    this.we = new I();
  }
  createCharacterObjects(t, e) {
    return t.map((r, s) => {
      const i = r.codePointAt(0) || 0, o = this.Me(s);
      let n = 0;
      if (e.hmtx && e.hmtx.aWidth) {
        const l = this.we.Kt(e, i);
        l > 0 && e.hmtx.aWidth[l] !== void 0 && (n = e.hmtx.aWidth[l]);
      }
      return { character: r, unicode: i, color: o, advanceWidth: n };
    });
  }
  Me(t) {
    return [t % 256, Math.floor(t / 256) % 256, Math.floor(t / 65536) % 256];
  }
  getCharacterColor(t, e) {
    if (!x.m(typeof t == "string", "Character must be a string.", { method: "getCharacterColor", providedValue: t })) return [0, 0, 0];
    const r = e.find((s) => s.character === t);
    return r ? r.color : [0, 0, 0];
  }
  getCharacterColors(t, e) {
    return x.m(typeof t == "string" && t.length > 0, "Characters must be a string with at least one character.", { method: "getCharacterColors", providedValue: t }) ? Array.from(t).map((r) => this.getCharacterColor(r, e) || [0, 0, 0]) : [[0, 0, 0]];
  }
}
class xt {
  constructor(t, e = 16) {
    h(this, "Se");
    h(this, "De", []);
    h(this, "Re");
    h(this, "Ve", 16);
    h(this, "Ie", 0);
    h(this, "ke", 0);
    h(this, "Ee", { width: 0, height: 0 });
    h(this, "Pe");
    h(this, "Ae", "UrsaFont");
    h(this, "ze");
    h(this, "Ge");
    h(this, "Ue");
    h(this, "Le");
    this.Ve = e, this.ze = new gt(), this.Ge = new mt(t), this.Ue = new pt(), this.Le = new bt();
  }
  async Oe(t) {
    let e;
    if (!t) throw new w("Embedded font not available. This appears to be a minified build - please provide `fontSource`.");
    {
      const r = await fetch(t);
      if (!r.ok) throw new w(`Failed to load font file: ${r.status} ${r.statusText}`);
      e = await r.arrayBuffer();
    }
    await this.je(e), this.Se = E.parse(e)[0], await this.He();
  }
  Be(t) {
    if (t === void 0) return this.Ve;
    this.Ve = t, this.Ee = this.Ue.calculateMaxGlyphDimensions(this.De.map((r) => r.character), this.Ve, this.Se);
    const e = this.Ge.createTextureAtlas(this.De, this.Ee, this.Ve, this.Se);
    this.Re = e.framebuffer, this.Ie = e.columns, this.ke = e.rows;
  }
  async We(t) {
    try {
      const e = await fetch(t);
      if (!e.ok) throw new w(`Failed to load font file: ${e.status} ${e.statusText}`);
      const r = await e.arrayBuffer();
      await this.je(r);
      const s = E.parse(r);
      if (!s || s.length === 0) throw Error("Failed to parse font file");
      this.Se = s[0], await this.He();
    } catch (e) {
      throw new w("Failed to load font: " + (e instanceof Error ? e.message : "Unknown error"), e);
    }
  }
  async je(t) {
    const e = Date.now();
    this.Ae = this.Ae === "UrsaFont" ? "UrsaFont" : "CustomFont_" + e, this.Pe = new FontFace(this.Ae, t), await this.Pe.load(), document.fonts.add(this.Pe);
  }
  async He() {
    const t = this.ze.extractCharacters(this.Se), e = this.ze.filterProblematicCharacters(t);
    this.De = this.Le.createCharacterObjects(e, this.Se), this.Ee = this.Ue.calculateMaxGlyphDimensions(e, this.Ve, this.Se);
    const r = this.Ge.createTextureAtlas(this.De, this.Ee, this.Ve, this.Se);
    this.Re = r.framebuffer, this.Ie = r.columns, this.ke = r.rows;
  }
  getCharacterColor(t) {
    return this.Le.getCharacterColor(t, this.De);
  }
  getCharacterColors(t) {
    return this.Le.getCharacterColors(t, this.De);
  }
  hasAllCharacters(t) {
    if (typeof t != "string" || t.length === 0) return !1;
    const e = new Set(this.De.map((r) => r.character));
    for (const r of t) if (!e.has(r)) return !1;
    return !0;
  }
  A() {
    this.Re.A(), document.fonts.delete(this.Pe);
  }
  get fontFramebuffer() {
    return this.Re;
  }
  get characters() {
    return this.De;
  }
  get textureColumns() {
    return this.Ie;
  }
  get textureRows() {
    return this.ke;
  }
  get maxGlyphDimensions() {
    return this.Ee;
  }
  get fontSize() {
    return this.Ve;
  }
  get font() {
    return this.Se;
  }
}
class vt {
  constructor(t, e, r) {
    h(this, "Ne");
    h(this, "Xe");
    h(this, "v");
    h(this, "C");
    h(this, "qe");
    h(this, "Ye");
    h(this, "Qe", !1);
    h(this, "Ze");
    h(this, "Je");
    h(this, "Ke");
    this.Ze = t, this.Je = e, this.Ke = r, this.Et();
  }
  Et() {
    this.Qe || (this.Ne = Math.floor(this.Ze.width / this.Je), this.Xe = Math.floor(this.Ze.height / this.Ke)), this.tr();
  }
  tr() {
    this.v = this.Ne * this.Je, this.C = this.Xe * this.Ke, this.qe = Math.floor((this.Ze.width - this.v) / 2), this.Ye = Math.floor((this.Ze.height - this.C) / 2);
  }
  er(t, e) {
    this.Je = t, this.Ke = e, this.Et();
  }
  rr(t, e) {
    this.Qe = !0, this.Ne = t, this.Xe = e, this.tr();
  }
  sr() {
    this.Qe = !1, this.Et();
  }
  ir() {
    this.Qe ? this.tr() : this.Et();
  }
  nr(t) {
    if (t === void 0) return this.Qe;
    this.Qe = t;
  }
  get cellWidth() {
    return this.Je;
  }
  get cellHeight() {
    return this.Ke;
  }
  get cols() {
    return this.Ne;
  }
  get rows() {
    return this.Xe;
  }
  get width() {
    return this.v;
  }
  get height() {
    return this.C;
  }
  get offsetX() {
    return this.qe;
  }
  get offsetY() {
    return this.Ye;
  }
}
class wt {
  constructor(t, e = !1, r = {}) {
    h(this, "Ze");
    h(this, "ar");
    h(this, "hr");
    h(this, "lr");
    h(this, "onTransformChange");
    this.ar = t, this.hr = e, this.Ze = this.cr(r.width, r.height), e && this.setupTransformObserver();
  }
  cr(t, e) {
    var s;
    const r = document.createElement("canvas");
    if (r.className = "textmodeCanvas", r.style.imageRendering = "pixelated", this.hr) r.width = t || 800, r.height = e || 600, document.body.appendChild(r);
    else {
      const i = this.ar.getBoundingClientRect();
      let o = Math.round(i.width), n = Math.round(i.height);
      if (this.ar instanceof HTMLVideoElement) {
        const u = this.ar;
        (o === 0 || n === 0) && u.videoWidth > 0 && u.videoHeight > 0 && (o = u.videoWidth, n = u.videoHeight);
      }
      r.width = o, r.height = n, r.style.position = "absolute", r.style.pointerEvents = "none";
      const l = window.getComputedStyle(this.ar);
      let c = parseInt(l.zIndex || "0", 10);
      isNaN(c) && (c = 0), r.style.zIndex = "" + (c + 1), this.ur(r), (s = this.ar.parentNode) == null || s.insertBefore(r, this.ar.nextSibling);
    }
    return r;
  }
  ur(t) {
    const e = this.ar.getBoundingClientRect();
    let r = this.ar.offsetParent;
    if (r && r !== document.body) {
      const s = r.getBoundingClientRect();
      t.style.top = e.top - s.top + "px", t.style.left = e.left - s.left + "px";
    } else t.style.top = e.top + window.scrollY + "px", t.style.left = e.left + window.scrollX + "px";
  }
  ir(t, e) {
    if (this.hr) this.Ze.width = t ?? this.Ze.width, this.Ze.height = e ?? this.Ze.height;
    else {
      const r = this.ar.getBoundingClientRect();
      let s = Math.round(r.width), i = Math.round(r.height);
      if (this.ar instanceof HTMLVideoElement) {
        const o = this.ar;
        (s === 0 || i === 0) && o.videoWidth > 0 && o.videoHeight > 0 && (s = o.videoWidth, i = o.videoHeight);
      }
      this.Ze.width = s, this.Ze.height = i, this.ur(this.Ze);
    }
  }
  dr() {
    const t = { alpha: !1, premultipliedAlpha: !1, preserveDrawingBuffer: !0, antialias: !1, depth: !1, stencil: !1, powerPreference: "high-performance" }, e = this.Ze.getContext("webgl2", t) || this.Ze.getContext("webgl", t);
    if (!e) throw new w("WebGL context could not be created. Ensure your browser supports WebGL.");
    return e;
  }
  setupTransformObserver() {
    this.lr = new ResizeObserver((t) => {
      for (const e of t) {
        const r = e.contentRect;
        !this.onTransformChange || Math.round(r.width) === this.Ze.width && Math.round(r.height) === this.Ze.height || this.onTransformChange();
      }
    }), this.lr.observe(this.Ze);
  }
  A() {
    this.lr && this.lr.disconnect();
    const t = this.Ze.getContext("webgl") || this.Ze.getContext("webgl2");
    if (t) {
      const e = t.getExtension("WEBGL_lose_context");
      e && e.loseContext();
    }
    this.Ze.parentNode && this.Ze.parentNode.removeChild(this.Ze);
  }
  get canvas() {
    return this.Ze;
  }
  get width() {
    return this.Ze.width;
  }
  get height() {
    return this.Ze.height;
  }
}
class U {
  constructor(t, e, r, s = {}) {
    h(this, "be");
    h(this, "pr");
    h(this, "mr");
    h(this, "gr");
    h(this, "_r");
    h(this, "vr");
    h(this, "br");
    h(this, "wr");
    h(this, "l");
    this.be = t, this.pr = e, this.mr = r, this.l = { enabled: !0, ...s };
    const i = this.mr.cols, o = this.mr.rows;
    this.gr = this.be.jt(i, o), this._r = this.be.jt(i, o), this.vr = this.be.jt(i, o), this.br = this.be.jt(i, o), this.wr = this.be.jt(i, o);
  }
  ir() {
    const t = this.mr.cols, e = this.mr.rows;
    this.gr.resize(t, e), this._r.resize(t, e), this.vr.resize(t, e), this.br.resize(t, e), this.wr.resize(t, e);
  }
  enabled(t) {
    x.m(typeof t == "boolean" || typeof t == "number" && Number.isInteger(t), "Enabled must be a boolean value or an integer (0 for false, any other number for true).", { method: "enabled", providedValue: t }) && (this.l.enabled = !!t);
  }
  enable() {
    this.enabled(!0);
  }
  disable() {
    this.enabled(!1);
  }
  A() {
    this.gr.A(), this._r.A(), this.vr.A(), this.br.A(), this.wr.A();
  }
  get characterFramebuffer() {
    return this.gr;
  }
  get primaryColorFramebuffer() {
    return this._r;
  }
  get secondaryColorFramebuffer() {
    return this.vr;
  }
  get rotationFramebuffer() {
    return this.br;
  }
  get transformFramebuffer() {
    return this.wr;
  }
  get options() {
    return this.l;
  }
}
class Ct {
  constructor(t, e) {
    h(this, "M");
    h(this, "be");
    h(this, "Cr");
    this.be = t, this.Cr = e;
    const r = Math.max(this.Cr.length, 1);
    this.M = this.be.jt(r, 1), this.yr();
  }
  yr() {
    const t = this.Cr.length;
    this.M.width !== t && this.M.resize(t, 1);
    const e = new Uint8Array(1 * t * 4);
    for (let r = 0; r < t; r++) {
      const s = this.Cr[r], i = 4 * r;
      e[i] = s[0], e[i + 1] = s[1], e[i + 2] = s[2], e[i + 3] = 255;
    }
    this.M.updatePixels(e, t, 1);
  }
  setColors(t) {
    this.Cr = t, this.yr();
  }
  get colors() {
    return this.Cr;
  }
  get framebuffer() {
    return this.M;
  }
}
class k extends U {
  constructor(e, r, s, i = {}) {
    super(e, r, s, { enabled: !0, characters: " .:-=+*%@#", characterColor: [1, 1, 1, 1], characterColorMode: "sampled", cellColor: [0, 0, 0, 1], cellColorMode: "fixed", invert: !1, rotation: [0, 0, 0, 1], flipHorizontally: !1, flipVertically: !1, ...i });
    h(this, "$r");
    this.$r = new Ct(this.be, this.pr.getCharacterColors(" .:-=+*%@#"));
  }
  characters(e) {
    x.m(this.pr.hasAllCharacters(e), "One or more characters do not exist in the current font.", { method: "characters", providedValue: e }) && (this.l.characters = e, this.$r.setColors(this.pr.getCharacterColors(e)));
  }
  characterColor(e, r, s, i = 255) {
    const o = this.Fr(e, "characterColor", r, s, i);
    o && (this.l.characterColor = o);
  }
  characterColorMode(e) {
    this.Tr(e, "characterColorMode");
  }
  cellColor(e, r, s, i = 255) {
    const o = this.Fr(e, "cellColor", r, s, i);
    o && (this.l.cellColor = o);
  }
  cellColorMode(e) {
    this.Tr(e, "cellColorMode");
  }
  invert(e) {
    this.Mr(e, "invert", "Invert");
  }
  rotation(e) {
    if (!x.m(typeof e == "number", "Rotation angle must be a number.", { method: "rotation", providedValue: e })) return;
    (e %= 360) < 0 && (e += 360);
    const r = 255 * e / 360, s = Math.floor(r) / 255, i = Math.round(r - s);
    this.l.rotation = [s, i, 0, 1];
  }
  flipHorizontally(e) {
    this.Mr(e, "flipHorizontally", "Flip horizontally");
  }
  flipVertically(e) {
    this.Mr(e, "flipVertically", "Flip vertically");
  }
  Fr(e, r, s, i, o = 255) {
    let n, l, c, u;
    if (typeof e == "string") {
      const f = this.Sr(e);
      if (!f) return x.m(!1, "Invalid hex color format. Use '#FF0000', '#F00', 'FF0000', or 'F00'.", { method: r, providedValue: e }), null;
      [n, l, c, u] = f;
    } else if (n = e, l = s !== void 0 ? s : e, c = i !== void 0 ? i : e, u = o, !x.m([n, l, c, u].every((f) => f >= 0 && f <= 255), r.charAt(0).toUpperCase() + r.slice(1) + " color values must be between 0 and 255", { method: r, providedValues: { r: n, g: l, b: c, a: u } })) return null;
    return [n / 255, l / 255, c / 255, u / 255];
  }
  Tr(e, r) {
    x.m(["sampled", "fixed"].includes(e), "Invalid color mode. Must be 'sampled' or 'fixed'.", { method: r, providedValue: e }) && (this.l[r] = e);
  }
  Mr(e, r, s) {
    x.m(typeof e == "boolean" || typeof e == "number" && Number.isInteger(e), s + " must be a boolean value or an integer (0 for false, any other number for true).", { method: r, providedValue: e }) && (this.l[r] = !!e);
  }
  Sr(e) {
    return e = e.replace(/^#/, ""), /^[0-9A-Fa-f]{3}$|^[0-9A-Fa-f]{6}$/.test(e) ? (e.length === 3 && (e = e.split("").map((r) => r + r).join("")), [parseInt(e.slice(0, 2), 16), parseInt(e.slice(2, 4), 16), parseInt(e.slice(4, 6), 16), 255]) : null;
  }
}
const P = `attribute vec2 a_position;\r
attribute vec2 a_texCoord;\r
varying vec2 v_uv;\r
\r
uniform float u_rotation; // rotation angle in radians\r
uniform vec2 u_center; // rotation center in normalized coordinates\r
uniform float u_aspectRatio; // canvas width / canvas height\r
\r
mat2 rotate2D(float angle) {\r
    float s = sin(angle);\r
    float c = cos(angle);\r
    return mat2(c, -s, s, c);\r
}\r
\r
void main() {\r
    v_uv = a_texCoord;\r
    \r
    // Use the position directly (it's already in normalized device coordinates)\r
    vec2 pos = a_position;\r
    \r
    // Translate to origin for rotation\r
    pos -= u_center;\r
    \r
    // Correct for aspect ratio: scale X coordinate to make space square\r
    pos.x *= u_aspectRatio;\r
    \r
    // Rotate in corrected space\r
    // Negate rotation to make positive values rotate clockwise (like p5.js)\r
    pos = rotate2D(-u_rotation) * pos;\r
    \r
    // Restore aspect ratio: scale X coordinate back\r
    pos.x /= u_aspectRatio;\r
    \r
    // Translate back from origin\r
    pos += u_center;\r
    \r
    gl_Position = vec4(pos, 0.0, 1.0);\r
}\r
`, et = { enabled: !0, characters: " .:-=+*%@#", characterColor: [1, 1, 1, 1], characterColorMode: "sampled", cellColor: [0, 0, 0, 1], cellColorMode: "fixed", invert: !1, rotation: [0, 0, 0, 255], flipHorizontally: !1, flipVertically: !1, brightnessRange: [0, 255] };
class L extends k {
  constructor(e, r, s) {
    super(e, r, s, et);
    h(this, "Dr");
    h(this, "Rr");
    h(this, "Vr");
    h(this, "Ir");
    h(this, "kr");
    h(this, "Er");
    this.Dr = new y(e.context, P, "precision lowp float;uniform sampler2D u_sketchTexture;uniform vec2 u_gridCellDimensions;uniform vec2 u_brightnessRange;varying vec2 v_uv;void main(){vec2 cellCenter=(floor(v_uv*u_gridCellDimensions)+vec2(0.5))/u_gridCellDimensions;vec4 color=texture2D(u_sketchTexture,cellCenter);float brightness=dot(color.rgb,vec3(0.299,0.587,0.114));float brightnessValue=brightness*255.0;if(brightnessValue>=u_brightnessRange.x&&brightnessValue<=u_brightnessRange.y){gl_FragColor=color;}else{gl_FragColor=vec4(0.0);}}"), this.Rr = new y(e.context, P, "precision lowp float;uniform sampler2D u_sampleTexture;uniform vec4 u_fillColor;uniform bool u_useFixedColor;varying vec2 v_uv;void main(){vec4 sampleColor=texture2D(u_sampleTexture,v_uv);if(sampleColor.a>0.0){if(u_useFixedColor){gl_FragColor=u_fillColor;}else{gl_FragColor=sampleColor;}}else{gl_FragColor=vec4(0.0);}}"), this.Ir = new y(e.context, P, "precision lowp float;uniform sampler2D u_sampleTexture;uniform bool u_invert;uniform bool u_flipHorizontally;uniform bool u_flipVertically;varying vec2 v_uv;void main(){vec4 sampleColor=texture2D(u_sampleTexture,v_uv);if(sampleColor.a>0.0){float invertValue=u_invert ? 1.0 : 0.0;float flipHValue=u_flipHorizontally ? 1.0 : 0.0;float flipVValue=u_flipVertically ? 1.0 : 0.0;gl_FragColor=vec4(invertValue,flipHValue,flipVValue,1.0);}else{gl_FragColor=vec4(0.0);}}"), this.kr = new y(e.context, P, "precision lowp float;uniform sampler2D u_sampleTexture;uniform vec4 u_rotationColor;varying vec2 v_uv;void main(){vec4 sampleColor=texture2D(u_sampleTexture,v_uv);if(sampleColor.a>0.0){gl_FragColor=u_rotationColor;}else{gl_FragColor=vec4(0.0);}}"), this.Vr = new y(e.context, P, "precision lowp float;uniform sampler2D u_colorSampleFramebuffer;uniform sampler2D u_charPaletteTexture;uniform vec2 u_charPaletteSize;uniform vec2 u_brightnessRange;varying vec2 v_uv;void main(){vec4 color=texture2D(u_colorSampleFramebuffer,v_uv);if(color.a==0.0){gl_FragColor=vec4(0.0);return;}float brightness=dot(color.rgb,vec3(0.299,0.587,0.114))*255.0;vec2 range=u_brightnessRange;if(brightness<range.x||brightness>range.y){gl_FragColor=vec4(0.0);return;}float t=(brightness-range.x)/(range.y-range.x);float idx=clamp(floor(t*u_charPaletteSize.x),0.0,u_charPaletteSize.x-1.0);vec3 charColor=texture2D(u_charPaletteTexture,vec2((idx+0.5)/u_charPaletteSize.x,0.0)).rgb;gl_FragColor=vec4(charColor,1.0);}"), this.Er = this.be.jt(this.mr.cols, this.mr.rows);
  }
  Pr(e) {
    const r = this.mr.cols, s = this.mr.rows;
    this.Er.begin(), this.be.Bt(), this.be.Ft(this.Dr), this.be.Gt("u_sketchTexture", e), this.be.Gt("u_gridCellDimensions", [r, s]), this.be.Gt("u_brightnessRange", this.l.brightnessRange), this.be.Ut(0, 0, r, s), this.Er.end(), this._r.begin(), this.be.Bt(), this.be.Ft(this.Rr), this.be.Gt("u_sampleTexture", this.Er), this.be.Gt("u_fillColor", this.l.characterColor), this.be.Gt("u_useFixedColor", this.l.characterColorMode === "fixed"), this.be.Ut(0, 0, r, s), this._r.end(), this.vr.begin(), this.be.Bt(), this.be.Ft(this.Rr), this.be.Gt("u_sampleTexture", this.Er), this.be.Gt("u_fillColor", this.l.cellColor), this.be.Gt("u_useFixedColor", this.l.cellColorMode === "fixed"), this.be.Ut(0, 0, r, s), this.vr.end(), this.wr.begin(), this.be.Bt(), this.be.Ft(this.Ir), this.be.Gt("u_sampleTexture", this.Er), this.be.Gt("u_invert", this.l.invert), this.be.Gt("u_flipHorizontally", this.l.flipHorizontally), this.be.Gt("u_flipVertically", this.l.flipVertically), this.be.Ut(0, 0, r, s), this.wr.end(), this.br.begin(), this.be.Bt(), this.be.Ft(this.kr), this.be.Gt("u_sampleTexture", this.Er), this.be.Gt("u_rotationColor", this.l.rotation), this.be.Ut(0, 0, r, s), this.br.end(), this.gr.begin(), this.be.Bt(), this.be.Ft(this.Vr), this.be.Gt("u_colorSampleFramebuffer", this.Er), this.be.Gt("u_charPaletteTexture", this.$r.framebuffer), this.be.Gt("u_charPaletteSize", [this.$r.colors.length, 1]), this.be.Gt("u_brightnessRange", this.l.brightnessRange), this.be.Ut(0, 0, r, s), this.gr.end();
  }
  ir() {
    super.ir(), this.Er.resize(this.mr.cols, this.mr.rows);
  }
  brightnessRange(e) {
    x.m(Array.isArray(e) && e.length === 2 && e.every((r) => typeof r == "number" && r >= 0 && r <= 255), "Brightness range must be an array of two numbers between 0 and 255.", { method: "brightnessRange", providedValue: e }) && (this.l.brightnessRange = e);
  }
}
const Nt = Object.freeze(Object.defineProperty({ __proto__: null, BRIGHTNESS_DEFAULT_OPTIONS: et, TextmodeBrightnessConverter: L, TextmodeConverter: U, TextmodeFeatureConverter: k }, Symbol.toStringTag, { value: "Module" }));
class _t {
  constructor(t, e, r) {
    h(this, "be");
    h(this, "Se");
    h(this, "mr");
    h(this, "Ar");
    h(this, "zr");
    h(this, "Gr");
    h(this, "Ur");
    h(this, "Lr");
    h(this, "gr");
    h(this, "_r");
    h(this, "vr");
    h(this, "br");
    h(this, "wr");
    this.be = t, this.Se = e, this.mr = r, this.Lr = this.be.At(G, "precision mediump float;uniform sampler2D u_characterTexture;uniform vec2 u_charsetDimensions;uniform sampler2D u_primaryColorTexture;uniform sampler2D u_secondaryColorTexture;uniform sampler2D u_transformTexture;uniform sampler2D u_asciiCharacterTexture;uniform sampler2D u_rotationTexture;uniform sampler2D u_captureTexture;uniform vec2 u_captureDimensions;uniform int u_backgroundMode;uniform vec2 u_gridCellDimensions;uniform vec2 u_gridPixelDimensions;mat2 rotate2D(float angle){float s=sin(angle);float c=cos(angle);return mat2(c,-s,s,c);}void main(){vec2 adjustedCoord=gl_FragCoord.xy/u_gridPixelDimensions;vec2 gridCoord=adjustedCoord*u_gridCellDimensions;vec2 cellCoord=floor(gridCoord);vec2 charIndexTexCoord=(cellCoord+0.5)/u_gridCellDimensions;vec4 primaryColor=texture2D(u_primaryColorTexture,charIndexTexCoord);vec4 secondaryColor=texture2D(u_secondaryColorTexture,charIndexTexCoord);vec4 transformColor=texture2D(u_transformTexture,charIndexTexCoord);bool isInverted=transformColor.r>0.5;bool flipHorizontal=transformColor.g>0.5;bool flipVertical=transformColor.b>0.5;vec4 encodedIndexVec=texture2D(u_asciiCharacterTexture,charIndexTexCoord);if(encodedIndexVec.a<0.01){gl_FragColor=(u_backgroundMode==0)? vec4(0.0):texture2D(u_captureTexture,gl_FragCoord.xy/u_captureDimensions);return;}int charIndex=int(encodedIndexVec.r*255.0+0.5)+int(encodedIndexVec.g*255.0+0.5)*256;int charCol=int(mod(float(charIndex),u_charsetDimensions.x));int charRow=charIndex/int(u_charsetDimensions.x);float flippedRow=(u_charsetDimensions.y-1.0)-float(charRow);vec2 charCoord=vec2(float(charCol),flippedRow)/u_charsetDimensions;vec4 rotationColor=texture2D(u_rotationTexture,charIndexTexCoord);float scaledAngle=rotationColor.r*255.0+rotationColor.g;float rotationAngle=(scaledAngle*360.0/255.0)*0.017453292;vec2 fractionalPart=fract(gridCoord)-0.5;if(flipHorizontal)fractionalPart.x=-fractionalPart.x;if(flipVertical)fractionalPart.y=-fractionalPart.y;fractionalPart=rotate2D(rotationAngle)*fractionalPart+0.5;vec2 cellSize=1.0/u_charsetDimensions;vec2 texCoord=charCoord+fractionalPart*cellSize;vec2 cellMax=charCoord+cellSize;if(any(lessThan(texCoord,charCoord))||any(greaterThan(texCoord,cellMax))){gl_FragColor=isInverted ? primaryColor : secondaryColor;return;}vec4 charTexel=texture2D(u_characterTexture,texCoord);if(isInverted)charTexel.rgb=1.0-charTexel.rgb;gl_FragColor=mix(secondaryColor,primaryColor,charTexel);}"), this.zr = new L(t, e, r), this.Gr = new U(t, e, r), this.Ar = [this.zr, this.Gr], this.gr = this.be.jt(r.cols, r.rows), this._r = this.be.jt(r.cols, r.rows), this.vr = this.be.jt(r.cols, r.rows), this.br = this.be.jt(r.cols, r.rows), this.wr = this.be.jt(r.cols, r.rows), this.Ur = this.be.jt(this.mr.width, this.mr.height);
  }
  Or(t) {
    for (const r of this.Ar) r.options.enabled && r instanceof k && r.Pr(t);
    const e = (r, s) => {
      r.begin(), this.be.Bt();
      for (const i of this.Ar) i.options.enabled && this.be.Nt(s(i), 0, 0);
      r.end();
    };
    e(this.gr, (r) => r.characterFramebuffer), e(this._r, (r) => r.primaryColorFramebuffer), e(this.vr, (r) => r.secondaryColorFramebuffer), e(this.br, (r) => r.rotationFramebuffer), e(this.wr, (r) => r.transformFramebuffer), this.Ur.begin(), this.be.Bt(), this.be.Ft(this.Lr), this.be.Gt("u_characterTexture", this.Se.fontFramebuffer), this.be.Gt("u_charsetDimensions", [this.Se.textureColumns, this.Se.textureRows]), this.be.Gt("u_asciiCharacterTexture", this.gr), this.be.Gt("u_primaryColorTexture", this._r), this.be.Gt("u_secondaryColorTexture", this.vr), this.be.Gt("u_transformTexture", this.wr), this.be.Gt("u_rotationTexture", this.br), this.be.Gt("u_captureTexture", t), this.be.Gt("u_backgroundMode", !1), this.be.Gt("u_captureDimensions", [t.width, t.height]), this.be.Gt("u_gridCellDimensions", [this.mr.cols, this.mr.rows]), this.be.Gt("u_gridPixelDimensions", [this.mr.width, this.mr.height]), this.be.Ut(0, 0, this.Ur.width, this.Ur.height), this.Ur.end();
  }
  add(t) {
    if (!x.m(t === "brightness" || t === "custom", 'Converter type must be either "brightness" or "custom".', { method: "add", providedValue: t })) return;
    let e;
    return e = t === "brightness" ? new L(this.be, this.Se, this.mr) : new U(this.be, this.Se, this.mr), this.Ar.push(e), e;
  }
  remove(t) {
    if (!x.m(t instanceof U, "Parameter must be a TextmodeConverter instance.", { method: "remove", providedValue: t })) return;
    const e = this.Ar.indexOf(t);
    x.m(e !== -1, "Converter instance not found in pipeline.", { method: "remove", providedValue: t, convertersCount: this.Ar.length }) && this.Ar.splice(e, 1);
  }
  swap(t, e) {
    const r = (n, l) => {
      if (typeof n == "number") return x.m(Number.isInteger(n) && n >= 0 && n < this.Ar.length, l + " index must be a valid integer within the converter array bounds.", { method: "swap", providedValue: n, convertersCount: this.Ar.length }) ? n : null;
      if (n instanceof U) {
        const c = this.Ar.indexOf(n);
        return x.m(c !== -1, l + " converter instance not found in pipeline.", { method: "swap", providedValue: n, convertersCount: this.Ar.length }) ? c : null;
      }
      return x.m(!1, l + " parameter must be either an integer index or a TextmodeConverter instance.", { method: "swap", providedValue: n }), null;
    }, s = r(t, "First"), i = r(e, "Second");
    if (s === null || i === null || !x.m(s !== i, "Cannot swap a converter with itself.", { method: "swap", firstIndex: s, secondIndex: i })) return;
    const o = this.Ar[s];
    this.Ar[s] = this.Ar[i], this.Ar[i] = o;
  }
  ir() {
    this.Ur.resize(this.mr.width, this.mr.height);
    const t = this.mr.cols, e = this.mr.rows;
    this.gr.resize(t, e), this._r.resize(t, e), this.vr.resize(t, e), this.br.resize(t, e), this.wr.resize(t, e);
    for (const r of this.Ar) r.ir();
  }
  hasEnabledConverters() {
    return this.Ar.some((t) => t.options.enabled);
  }
  disable() {
    for (const t of this.Ar) t.disable();
  }
  enable() {
    for (const t of this.Ar) t.enable();
  }
  A() {
    for (const t of this.Ar) t.A();
    this.gr.A(), this._r.A(), this.vr.A(), this.br.A(), this.wr.A(), this.Ur.A(), this.Lr.A();
  }
  get texture() {
    return this.Ur;
  }
  get characterFramebuffer() {
    return this.gr;
  }
  get primaryColorFramebuffer() {
    return this._r;
  }
  get secondaryColorFramebuffer() {
    return this.vr;
  }
  get rotationFramebuffer() {
    return this.br;
  }
  get transformFramebuffer() {
    return this.wr;
  }
  get brightness() {
    return this.zr;
  }
  get custom() {
    return this.Gr;
  }
}
const Ft = (a) => class extends a {
  fill(t, e, r, s) {
    this.be.Tt(t, e, r, s);
  }
  stroke(t, e, r, s) {
    this.be.Mt(t, e, r, s);
  }
  strokeWeight(t) {
    this.be.St(t);
  }
  noStroke() {
    this.be.Dt();
  }
  noFill() {
    this.be.Rt();
  }
  rotate(t) {
    this.be.Vt(t);
  }
  push() {
    this.be.It();
  }
  pop() {
    this.be.kt();
  }
  rect(t, e, r = 1, s = 1) {
    this.be.Ut(t, e, r, s);
  }
  line(t, e, r, s) {
    this.be.Ot(t, e, r, s);
  }
  background(t, e = t, r = t, s = 255) {
    this.be.Ht(t, e, r, s);
  }
  createShader(t, e) {
    return this.be.At(t, e);
  }
  createFilterShader(t) {
    return this.be.zt(t);
  }
  shader(t) {
    this.be.Ft(t);
  }
  setUniform(t, e) {
    this.be.Gt(t, e);
  }
  image(t, e, r, s, i) {
    this.be.Nt(t, e, r, s, i);
  }
  clear() {
    this.be.Bt();
  }
  createFramebuffer(t, e, r = {}) {
    return this.be.jt(t, e, r);
  }
};
class V {
  jr(t) {
    const e = t.characterFramebuffer, r = t.primaryColorFramebuffer, s = t.secondaryColorFramebuffer, i = t.transformFramebuffer, o = t.rotationFramebuffer;
    return e == null || e.loadPixels(), r == null || r.loadPixels(), s == null || s.loadPixels(), i == null || i.loadPixels(), o == null || o.loadPixels(), { characterPixels: (e == null ? void 0 : e.pixels) || new Uint8Array(0), primaryColorPixels: (r == null ? void 0 : r.pixels) || new Uint8Array(0), secondaryColorPixels: (s == null ? void 0 : s.pixels) || new Uint8Array(0), transformPixels: (i == null ? void 0 : i.pixels) || new Uint8Array(0), rotationPixels: (o == null ? void 0 : o.pixels) || new Uint8Array(0) };
  }
  Hr(t, e) {
    return t[e] + (t[e + 1] << 8);
  }
  Br(t, e) {
    return { r: t[e], g: t[e + 1], b: t[e + 2], a: t[e + 3] };
  }
}
class N {
  Wr(t, e) {
    return new Blob([t], { type: e });
  }
  Nr(t, e, r) {
    try {
      const s = this.Wr(t, r), i = URL.createObjectURL(s), o = document.createElement("a");
      o.href = i, o.download = e, o.style.display = "none", o.rel = "noopener", document.body.appendChild(o), o.click(), document.body.removeChild(o), URL.revokeObjectURL(i);
    } catch (s) {
      throw console.error("Failed to download file:", s), Error("File download failed: " + (s instanceof Error ? s.message : "Unknown error"));
    }
  }
  Xr() {
    return (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace(/:/g, "-");
  }
  qr() {
    const t = /* @__PURE__ */ new Date();
    return { date: t.toISOString().split("T")[0], time: t.toTimeString().split(" ")[0].replace(/:/g, "-") };
  }
  Yr(t) {
    return t.replace(/[<>:"/\\|?*]/g, "_").replace(/\s+/g, "_").replace(/_{2,}/g, "_").replace(/^_+|_+$/g, "").substring(0, 255);
  }
  Qr() {
    return "'textmode-export'-" + this.Xr();
  }
}
class yt extends V {
  Zr(t, e, r) {
    const s = t[r] === 255, i = t[r + 1] === 255, o = t[r + 2] === 255, n = e[r], l = e[r + 1];
    return { isInverted: s, flipHorizontal: i, flipVertical: o, rotation: Math.round(360 * (n + l / 255) / 255 * 100) / 100 };
  }
  Jr(t, e, r) {
    return { x: t, y: e, cellX: t * r.cellWidth, cellY: e * r.cellHeight };
  }
  Kr(t, e) {
    const r = [];
    let s = 0;
    for (let i = 0; i < e.rows; i++) for (let o = 0; o < e.cols; o++) {
      const n = 4 * s, l = this.Hr(t.characterPixels, n);
      let c = this.Br(t.primaryColorPixels, n), u = this.Br(t.secondaryColorPixels, n);
      const f = this.Zr(t.transformPixels, t.rotationPixels, n);
      if (f.isInverted) {
        const p = c;
        c = u, u = p;
      }
      const d = this.Jr(o, i, e);
      r.push({ charIndex: l, primaryColor: c, secondaryColor: u, transform: f, position: d }), s++;
    }
    return r;
  }
}
class Tt {
  ts(t, e) {
    const r = t.cmap;
    for (const s of r.tables) if (s.format === 4) {
      const i = s;
      for (let o = 0; o < i.startCount.length; o++) if (e >= i.startCount[o] && e <= i.endCount[o]) {
        if (i.idRangeOffset[o] === 0) return e + i.idDelta[o] & 65535;
        {
          const n = i.idRangeOffset[o] / 2 + (e - i.startCount[o]) - (i.startCount.length - o);
          if (n >= 0 && n < i.glyphIdArray.length) {
            const l = i.glyphIdArray[n];
            if (l !== 0) return l + i.idDelta[o] & 65535;
          }
        }
      }
    } else if (s.format === 12) {
      const i = s;
      for (let o = 0; o < i.groups.length; o += 3) {
        const n = i.groups[o], l = i.groups[o + 1], c = i.groups[o + 2];
        if (e >= n && e <= l) return c + (e - n);
      }
    }
    return 0;
  }
  es(t, e, r, s, i) {
    const o = i / t.head.unitsPerEm;
    return { getBoundingBox: () => ({ x1: r + e.xMin * o, y1: s + -e.yMax * o, x2: r + e.xMax * o, y2: s + -e.yMin * o }), toSVG: () => this.rs(e, r, s, o) };
  }
  rs(t, e, r, s) {
    if (!t || !t.xs) return "";
    const { xs: i, ys: o, endPts: n, flags: l } = t;
    if (!(i && o && n && l)) return "";
    let c = "", u = 0;
    for (let f = 0; f < n.length; f++) {
      const d = n[f];
      if (!(d < u)) {
        if (d >= u) {
          const p = e + i[u] * s, m = r - o[u] * s;
          c += `M${p.toFixed(2)},${m.toFixed(2)}`;
          let g = u + 1;
          for (; g <= d; )
            if (1 & l[g]) {
              const C = e + i[g] * s, b = r - o[g] * s;
              c += `L${C.toFixed(2)},${b.toFixed(2)}`, g++;
            } else {
              const C = e + i[g] * s, b = r - o[g] * s;
              let v = g + 1 > d ? u : g + 1;
              if (1 & l[v]) {
                const F = e + i[v] * s, T = r - o[v] * s;
                c += `Q${C.toFixed(2)},${b.toFixed(2)} ${F.toFixed(2)},${T.toFixed(2)}`, g = v + 1;
              } else {
                const F = (C + (e + i[v] * s)) / 2, T = (b + (r - o[v] * s)) / 2;
                c += `Q${C.toFixed(2)},${b.toFixed(2)} ${F.toFixed(2)},${T.toFixed(2)}`, g = v;
              }
            }
          c += "Z";
        }
        u = d + 1;
      }
    }
    return c;
  }
  ss(t, e, r, s, i) {
    const o = t.codePointAt(0) || 0, n = this.ts(e, o);
    let l = null;
    return e.glyf && e.glyf[n] !== null ? l = e.glyf[n] : (l = E.T.glyf.Xt(e, n), e.glyf[n] = l), this.es(e, l, r, s, i);
  }
  ns(t, e, r, s, i, o, n, l) {
    const c = r + (i - l * (n / e.head.unitsPerEm)) / 2, u = s + (o + 0.7 * n) / 2;
    return this.ss(t, e, c, u, n).toSVG() || null;
  }
}
class Et {
  constructor() {
    h(this, "hs");
    this.hs = new Tt();
  }
  ls(t) {
    return `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="${t.width}" height="${t.height}" viewBox="0 0 ${t.width} ${t.height}" 
     xmlns="http://www.w3.org/2000/svg" version="1.1">
<title>textmode art generated via textmode.js</title>
<desc>textmode art visualization generated by textmode.js library</desc>`;
  }
  cs() {
    return `
</g>
</svg>`;
  }
  us(t, e) {
    if (!e.includeBackgroundRectangles) return "";
    const r = e.backgroundColor, s = `rgba(${r[0]},${r[1]},${r[2]},${r[3] / 255})`;
    return `
<rect width="${t.width}" height="${t.height}" fill="${s}" />`;
  }
  fs(t) {
    return `rgba(${t.r},${t.g},${t.b},${t.a / 255})`;
  }
  ds(t, e) {
    const { transform: r, position: s } = t, i = s.cellX + e.cellWidth / 2, o = s.cellY + e.cellHeight / 2, n = [];
    if (r.flipHorizontal || r.flipVertical) {
      const l = r.flipHorizontal ? -1 : 1, c = r.flipVertical ? -1 : 1;
      n.push(`translate(${i} ${o})`), n.push(`scale(${l} ${c})`), n.push(`translate(${-i} ${-o})`);
    }
    return r.rotation && n.push(`rotate(${r.rotation} ${i} ${o})`), n.length ? ` transform="${n.join(" ")}"` : "";
  }
  ps(t, e, r) {
    if (!r.includeBackgroundRectangles || t.secondaryColor.a === 0) return "";
    const { position: s } = t, i = this.fs(t.secondaryColor);
    return r.drawMode === "stroke" ? `
  <rect x="${s.cellX}" y="${s.cellY}" width="${e.cellWidth}" height="${e.cellHeight}" stroke="${i}" fill="none" stroke-width="${r.strokeWidth}" />` : `
  <rect x="${s.cellX}" y="${s.cellY}" width="${e.cellWidth}" height="${e.cellHeight}" fill="${i}" />`;
  }
  ss(t, e, r, s) {
    const i = r.characters[t.charIndex];
    if (!i) return "";
    const o = this.hs.ns(i.character, r.font, t.position.cellX, t.position.cellY, e.cellWidth, e.cellHeight, r.fontSize, i.advanceWidth);
    if (!o) return "";
    const n = this.fs(t.primaryColor);
    return s.drawMode === "stroke" ? `
    <path id="${`path-${t.charIndex}-${t.position.cellX}-${t.position.cellY}`.replace(/\./g, "-")}" d="${o}" stroke="${n}" stroke-width="${s.strokeWidth}" fill="none" />` : `
    <path d="${o}" fill="${n}" />`;
  }
  gs(t, e, r, s) {
    let i = "";
    i += this.ps(t, e, s);
    const o = this.ds(t, e), n = this.ss(t, e, r, s);
    return n && (o ? (i += `
  <g${o}>`, i += n, i += `
  </g>`) : i += n), i;
  }
  _s(t, e, r, s) {
    let i = this.ls(e);
    i += this.us(e, s), i += `
<g id="ascii-cells">`;
    for (const o of t) i += this.gs(o, e, r, s);
    return i += this.cs(), i;
  }
  vs(t) {
    return t.replace(/<path[^>]*d=""[^>]*\/>/g, "").replace(/\n\s*\n/g, `
`).replace(/[ \t]+$/gm, "");
  }
}
class Rt extends N {
  bs(t) {
    return this.Wr(t, "image/svg+xml;charset=utf-8");
  }
  ws(t, e) {
    this.Nr(t, this.Yr(e) + ".svg", "image/svg+xml;charset=utf-8");
  }
  Cs(t, e) {
    this.ws(t, e || this.Qr());
  }
}
class H {
  constructor() {
    h(this, "$s");
    h(this, "Fs");
    h(this, "Ts");
    this.$s = new yt(), this.Fs = new Et(), this.Ts = new Rt();
  }
  Ms(t) {
    return { includeBackgroundRectangles: t.includeBackgroundRectangles ?? !0, drawMode: t.drawMode ?? "fill", strokeWidth: t.strokeWidth ?? 1, backgroundColor: t.backgroundColor ?? [0, 0, 0, 0] };
  }
  Ss(t, e = {}) {
    const r = this.Ms(e), s = this.$s.jr(t.pipeline), i = this.$s.Kr(s, t.grid), o = this.Fs._s(i, t.grid, t.font, r);
    return this.Fs.vs(o);
  }
  Cs(t, e = {}) {
    const r = this.Ss(t, e), s = e.filename || this.Ts.Qr();
    this.Ts.Cs(r, s);
  }
}
class At extends V {
  Ds(t, e, r, s = " ") {
    var n;
    const i = [];
    let o = 0;
    for (let l = 0; l < e.rows; l++) {
      const c = [];
      for (let u = 0; u < e.cols; u++) {
        const f = 4 * o, d = this.Hr(t.characterPixels, f), p = ((n = r.characters[d]) == null ? void 0 : n.character) || s;
        c.push(p), o++;
      }
      i.push(c);
    }
    return i;
  }
}
class St {
  Rs(t, e) {
    const r = [];
    for (const i of t) {
      let o = i.join("");
      e.preserveTrailingSpaces || (o = o.replace(/\s+$/, "")), r.push(o);
    }
    const s = e.lineEnding === "crlf" ? `\r
` : `
`;
    return r.join(s);
  }
}
class Mt extends N {
  Vs(t, e) {
    const r = this.Is(e);
    this.Nr(t, r, "text/plain;charset=utf-8");
  }
  Is(t) {
    let e = this.Yr(t);
    return e === ".txt" || e.length <= 4 ? this.Qr() : e;
  }
}
class W {
  constructor() {
    h(this, "$s");
    h(this, "Fs");
    h(this, "Ts");
    this.$s = new At(), this.Fs = new St(), this.Ts = new Mt();
  }
  Ms(t) {
    return { preserveTrailingSpaces: t.preserveTrailingSpaces ?? !1, lineEnding: t.lineEnding ?? "lf", emptyCharacter: t.emptyCharacter ?? " " };
  }
  ks(t, e = {}) {
    const r = this.Ms(e), s = this.$s.jr(t.pipeline), i = this.$s.Ds(s, t.grid, t.font, r.emptyCharacter);
    return this.Fs.Rs(i, r);
  }
  Vs(t, e = {}) {
    const r = this.ks(t, e), s = e.filename || this.Ts.Qr();
    this.Ts.Vs(r, s);
  }
}
class Ut extends V {
  Es(t, e = 1, r = "transparent") {
    const s = t.canvas;
    if (e === 1 && r === "transparent") return s;
    const i = document.createElement("canvas"), o = i.getContext("2d"), n = Math.round(s.width * e), l = Math.round(s.height * e);
    return i.width = n, i.height = l, r !== "transparent" && (o.fillStyle = r, o.fillRect(0, 0, n, l)), o.imageSmoothingEnabled = !1, o.drawImage(s, 0, 0, s.width, s.height, 0, 0, n, l), i;
  }
}
class Dt {
  Ps(t, e) {
    const r = this.As(e.format);
    return e.format === "png" ? t.toDataURL(r) : t.toDataURL(r, e.quality);
  }
  async zs(t, e) {
    return new Promise((r, s) => {
      const i = this.As(e.format), o = (n) => {
        n ? r(n) : s(Error(`Failed to generate ${e.format.toUpperCase()} blob`));
      };
      e.format === "png" ? t.toBlob(o, i) : t.toBlob(o, i, e.quality);
    });
  }
  As(t) {
    switch (t) {
      case "png":
        return "image/png";
      case "jpg":
        return "image/jpeg";
      case "webp":
        return "image/webp";
      default:
        throw Error("Unsupported image format: " + t);
    }
  }
}
const Pt = { png: "image/png", jpg: "image/jpeg", webp: "image/webp" }, X = { png: ".png", jpg: ".jpg", webp: ".webp" };
class Gt extends N {
  Gs(t, e, r) {
    this.Us(t, this.Yr(e) + X[r]);
  }
  Us(t, e) {
    const r = URL.createObjectURL(t);
    try {
      const s = document.createElement("a");
      s.href = r, s.download = e, s.style.display = "none", s.rel = "noopener", document.body.appendChild(s), s.click(), document.body.removeChild(s);
    } finally {
      URL.revokeObjectURL(r);
    }
  }
  Ls(t) {
    return t in Pt && t in X;
  }
}
class $t {
  constructor() {
    h(this, "$s");
    h(this, "Fs");
    h(this, "Ts");
    this.$s = new Ut(), this.Fs = new Dt(), this.Ts = new Gt();
  }
  Ms(t) {
    return { format: t.format ?? "png", quality: t.quality ?? 1, scale: t.scale ?? 1, backgroundColor: t.backgroundColor ?? "transparent" };
  }
  Os(t) {
    if (console.log("Validating image export options:", t), !this.Ts.Ls(t.format)) throw Error(`Saving '${t.format}' files is not supported`);
    if (t.quality < 0 || t.quality > 1) throw Error("Image quality must be between 0.0 and 1.0");
    if (t.scale <= 0) throw Error("Scale factor must be greater than 0");
    t.scale > 10 && console.warn("Large scale factors may result in very large files and slow performance"), t.format === "jpg" && t.backgroundColor === "transparent" && (t.backgroundColor = "black");
  }
  js(t, e = {}) {
    const r = this.Ms(e);
    if (this.Os(r), r.scale === 1 && r.backgroundColor === "transparent") return this.Fs.Ps(t.canvas, r);
    const s = this.$s.Es(t, r.scale, r.backgroundColor);
    return this.Fs.Ps(s, r);
  }
  async zs(t, e = {}) {
    const r = this.Ms(e);
    if (this.Os(r), r.scale === 1 && r.backgroundColor === "transparent") return await this.Fs.zs(t.canvas, r);
    const s = this.$s.Es(t, r.scale, r.backgroundColor);
    return await this.Fs.zs(s, r);
  }
  async Gs(t, e = {}) {
    const r = await this.zs(t, e), s = e.format ?? "png", i = e.filename || this.Ts.Qr();
    this.Ts.Gs(r, i, s);
  }
}
const It = (a) => class extends a {
  toString(t = {}) {
    return new W().ks({ pipeline: this.Hs, grid: this.mr, font: this.Se }, t);
  }
  saveStrings(t = {}) {
    new W().Vs({ pipeline: this.Hs, grid: this.mr, font: this.Se }, t);
  }
  toSVG(t = {}) {
    return new H().Ss(this, t);
  }
  saveSVG(t = {}) {
    new H().Cs(this, t);
  }
  async saveCanvas(t, e = "png", r = {}) {
    await new $t().Gs(this.Ze, { ...r, filename: t, format: e });
  }
}, Bt = (a) => class extends a {
  async loadFont(t) {
    return this.Se.We(t).then(() => {
      const e = this.Se.maxGlyphDimensions;
      this.mr.er(e.width, e.height), this.Hs.ir();
    });
  }
  fontSize(t) {
    if (!x.m(typeof t == "number" && t > 0, "Font size must be a positive number greater than 0.", { method: "fontSize", providedValue: t }) || this.Se.fontSize === t) return;
    this.Se.Be(t);
    const e = this.Se.maxGlyphDimensions;
    this.mr.er(e.width, e.height), this.Hs.ir(), this.be.Wt();
  }
}, Lt = (a) => class extends a {
  addConverter(t) {
    return this.Hs.add(t);
  }
  removeConverter(t) {
    this.Hs.remove(t);
  }
};
class kt {
  constructor() {
    h(this, "be");
    h(this, "Se");
    h(this, "Hs");
    h(this, "Ze");
    h(this, "mr");
  }
}
class Z extends function(e, ...r) {
  return r.reduce((s, i) => i(s), e);
}(kt, Ft, It, Bt, Lt) {
  constructor(e = null, r = {}) {
    super();
    h(this, "ar");
    h(this, "Bs");
    h(this, "lr");
    h(this, "Ws");
    h(this, "Ns");
    h(this, "Xs", null);
    h(this, "qs", 0);
    h(this, "Ys");
    h(this, "Qs", !0);
    h(this, "Zs", 0);
    h(this, "Js", 0);
    h(this, "Ks", 0);
    h(this, "ti", []);
    h(this, "ei", 10);
    h(this, "ri", !1);
    h(this, "si", !1);
    h(this, "ii", () => {
    });
    h(this, "oi", () => {
    });
    h(this, "ni");
    this.ar = e, this.si = e === null, this.Ws = r.renderMode ?? "auto", this.Ns = r.frameRate ?? 60, this.Ys = 1e3 / this.Ns;
  }
  static async create(e = null, r = {}) {
    const s = new this(e, r), i = s.si ? r : void 0;
    let o, n;
    s.Ze = new wt(s.ar, s.si, i), s.be = new ht(s.Ze.dr()), s.si ? (o = r.width || 800, n = r.height || 600) : (o = s.Ze.width || 800, n = s.Ze.height || 600), s.Bs = s.be.jt(o, n), s.Se = new xt(s.be, r.fontSize ?? 16), await s.Se.Oe(r.fontSource);
    const l = s.Se.maxGlyphDimensions;
    return s.mr = new vt(s.Ze.canvas, l.width, l.height), s.Hs = new _t(s.be, s.Se, s.mr), s.ai(), s.hi(), s;
  }
  ai() {
    this.ni = () => {
      this.si ? this.oi() : this.li();
    }, window.addEventListener("resize", this.ni), window.ResizeObserver && this.ar && !this.si && (this.lr = new ResizeObserver(() => {
      this.li();
    }), this.lr.observe(this.ar));
  }
  render() {
    this.ci(), this.Ks++, this.ri ? console.warn("Cannot render: Required resources have been disposed") : (this.si ? (this.Bs.begin(), this.ii(), this.Bs.end()) : this.Bs.P(this.ar), this.Hs.hasEnabledConverters() ? (this.Hs.Or(this.Bs), this.be.Ht(0), this.be.Nt(this.Hs.texture, this.mr.offsetX, this.mr.offsetY, this.Hs.texture.width, this.Hs.texture.height)) : (this.be.Bt(), this.be.Nt(this.Bs, this.mr.offsetX, this.mr.offsetY, this.Bs.width, this.Bs.height)));
  }
  li() {
    this.Ze.ir(), this.Bs.resize(this.Ze.width, this.Ze.height), this.mr.ir(), this.Hs.ir(), this.be.Wt(), this.Ws !== "manual" && this.render();
  }
  hi() {
    if (this.Ws !== "auto" || !this.Qs) return;
    this.qs = performance.now();
    const e = (r) => {
      if (!this.Qs) return void (this.Xs = null);
      const s = r - this.qs;
      s >= this.Ys && (this.render(), this.qs = r - s % this.Ys), this.Qs && (this.Xs = requestAnimationFrame(e));
    };
    this.Xs = requestAnimationFrame(e);
  }
  ci() {
    const e = performance.now();
    if (this.Js > 0) {
      const r = e - this.Js;
      this.ti.push(r), this.ti.length > this.ei && this.ti.shift();
      const s = this.ti.reduce((i, o) => i + o, 0) / this.ti.length;
      this.Zs = 1e3 / s;
    }
    this.Js = e;
  }
  ui() {
    this.Xs && (cancelAnimationFrame(this.Xs), this.Xs = null);
  }
  renderMode(e) {
    this.Ws !== e && (this.ui(), this.Ws = e, e === "auto" && this.Qs && this.hi());
  }
  frameRate(e) {
    if (e === void 0) return this.Zs;
    this.Ns = e, this.Ys = 1e3 / e, this.Ws === "auto" && this.Qs && (this.ui(), this.hi());
  }
  noLoop() {
    this.Qs && (this.Qs = !1, this.Xs && (cancelAnimationFrame(this.Xs), this.Xs = null));
  }
  loop() {
    this.Qs || (this.Qs = !0, this.Ws === "auto" && this.hi());
  }
  redraw(e = 1) {
    if (x.m(typeof e == "number" && e > 0 && Number.isInteger(e), "Redraw count must be a positive integer.", { method: "redraw", providedValue: e })) for (let r = 0; r < e; r++) this.render();
  }
  isLooping() {
    return this.Ws === "auto" && this.Qs;
  }
  draw(e) {
    this.ii = e;
  }
  windowResized(e) {
    this.oi = e;
  }
  resizeCanvas(e, r) {
    this.si && (this.Ze.ir(e, r), this.Bs.resize(this.Ze.width, this.Ze.height), this.mr.ir(), this.Hs.ir(), this.be.Wt(), this.Ws !== "manual" && this.render());
  }
  destroy() {
    this.ri || (this.ui(), window.removeEventListener("resize", this.ni), this.lr && this.lr.disconnect(), this.Hs.A(), this.Se.A(), this.Bs.A(), this.be.A(), this.ri = !0);
  }
  get grid() {
    return this.mr;
  }
  get font() {
    return this.Se;
  }
  get mode() {
    return this.Ws;
  }
  get pipeline() {
    return this.Hs;
  }
  get frameCount() {
    return this.Ks;
  }
  get renderer() {
    return this.be;
  }
  set frameCount(e) {
    this.Ks = e;
  }
  get width() {
    return this.Ze.width;
  }
  get height() {
    return this.Ze.height;
  }
  get canvas() {
    return this.Ze;
  }
  get isDisposed() {
    return this.ri;
  }
}
class O {
  constructor() {
    throw new w("Textmode is a static class and cannot be instantiated.");
  }
  static async create(t, e = {}) {
    if (!(t == null || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || typeof t == "object")) throw new w("First parameter must be HTMLCanvasElement, HTMLVideoElement, or options object.");
    if (typeof e != "object") throw new w("Second parameter must be an options object.");
    if (t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement) return Z.create(t, e);
    {
      const r = t || {};
      return Z.create(null, r);
    }
  }
  static setErrorLevel(t) {
    x._(t);
  }
  static get version() {
    return "0.1.9";
  }
}
const Ot = Object.freeze(Object.defineProperty({ __proto__: null }, Symbol.toStringTag, { value: "Module" })), jt = Object.freeze(Object.defineProperty({ __proto__: null, DEFAULT_FRAMEBUFFER_OPTIONS: { filter: "nearest", wrap: "clamp", format: "rgba", type: "unsigned_byte" }, Framebuffer: K, Shader: J }, Symbol.toStringTag, { value: "Module" })), zt = O.create, Ht = O.setErrorLevel, Wt = O.version;
export {
  wt as TextmodeCanvas,
  Ct as TextmodeColorPalette,
  _t as TextmodeConversionPipeline,
  ot as TextmodeErrorLevel,
  xt as TextmodeFont,
  vt as TextmodeGrid,
  Z as Textmodifier,
  Nt as converters,
  zt as create,
  Ot as export,
  jt as rendering,
  Ht as setErrorLevel,
  O as textmode,
  Wt as version
};
