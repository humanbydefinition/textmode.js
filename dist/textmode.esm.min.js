var K = Object.defineProperty;
var q = (a, t, e) => t in a ? K(a, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : a[t] = e;
var c = (a, t, e) => q(a, typeof t != "symbol" ? t + "" : t, e);
class _ extends Error {
  constructor(t, e = {}) {
    super(_.i(t, e)), this.name = "TextmodeError";
  }
  static i(t, e) {
    let r = t;
    if (e && Object.keys(e).length > 0) {
      r += `

ðŸ“‹ Context:`;
      for (const [i, s] of Object.entries(e))
        r += `
  - ${i}: ${_.o(s)}`;
    }
    return r += `

`, r += "â†“".repeat(24) + `
`, r;
  }
  static o(t) {
    if (t === null) return "null";
    if (t === void 0) return "undefined";
    if (typeof t == "string") return `"${t}"`;
    if (typeof t == "number" || typeof t == "boolean") return t + "";
    if (Array.isArray(t)) return t.length === 0 ? "[]" : t.length <= 5 ? `[${t.map((e) => _.o(e)).join(", ")}]` : `[${t.slice(0, 3).map((e) => _.o(e)).join(", ")}, ... +${t.length - 3} more]`;
    if (typeof t == "object") {
      const e = Object.keys(t);
      return e.length === 0 ? "{}" : e.length <= 3 ? `{ ${e.map((r) => `${r}: ${_.o(t[r])}`).join(", ")} }` : `{ ${e.slice(0, 2).map((r) => `${r}: ${_.o(t[r])}`).join(", ")}, ... +${e.length - 2} more }`;
    }
    return t + "";
  }
}
var J = ((a) => (a[a.SILENT = 0] = "SILENT", a[a.WARNING = 1] = "WARNING", a[a.ERROR = 2] = "ERROR", a[a.THROW = 3] = "THROW", a))(J || {});
const A = class A {
  constructor() {
    c(this, "u", { globalLevel: 3 });
  }
  static p() {
    return A.l || (A.l = new A()), A.l;
  }
  _(t, e) {
    const r = "%c[textmode.js] Oops! (â•¯Â°â–¡Â°)â•¯ï¸µ Something went wrong in your code.", i = "color: #f44336; font-weight: bold; background: #ffebee; padding: 2px 6px; border-radius: 3px;";
    switch (this.u.globalLevel) {
      case 0:
        return !1;
      case 1:
        return console.group(r, i), console.warn(_.i(t, e)), console.groupEnd(), !1;
      case 2:
        return console.group(r, i), console.error(_.i(t, e)), console.groupEnd(), !1;
      default:
        throw new _(t, e);
    }
  }
  m(t, e, r) {
    return !!t || (this._(e, r), !1);
  }
  v(t) {
    this.u.globalLevel = t;
  }
};
c(A, "l", null);
let B = A;
const I = B.p(), Q = /* @__PURE__ */ new WeakMap();
function D(a, t) {
  Q.set(a, t);
}
function U(a) {
  return Q.get(a);
}
class $ {
  constructor(t, e, r = e, i = 1, s = {}) {
    c(this, "C");
    c(this, "$");
    c(this, "u");
    c(this, "R", null);
    c(this, "S");
    c(this, "M");
    c(this, "F", []);
    c(this, "G");
    c(this, "D", null);
    c(this, "P", []);
    this.C = e, this.$ = r, this.u = { filter: "nearest", wrap: "clamp", format: "rgba", type: "unsigned_byte", ...s }, this.S = t, this.G = Math.min(Math.max(1, i), 8);
    const n = t.getParameter(t.MAX_DRAW_BUFFERS), o = t.getParameter(t.MAX_COLOR_ATTACHMENTS);
    this.G = Math.min(this.G, n, o), this.M = t.createFramebuffer(), this.A(), this.I(), this.P = Array(this.G).fill(null);
  }
  A() {
    const t = this.S, e = this.u.filter === "linear" ? t.LINEAR : t.NEAREST, r = this.u.wrap === "repeat" ? t.REPEAT : t.CLAMP_TO_EDGE, i = this.u.type === "float" ? t.FLOAT : t.UNSIGNED_BYTE;
    for (let s = 0; s < this.G; s++) {
      const n = t.createTexture();
      t.bindTexture(t.TEXTURE_2D, n), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, e), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, e), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, r), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, r), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, this.C, this.$, 0, t.RGBA, i, null), this.F.push(n);
    }
    t.bindTexture(t.TEXTURE_2D, null);
  }
  I() {
    const t = this.S;
    if (t.bindFramebuffer(t.FRAMEBUFFER, this.M), this.G === 1) t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, this.F[0], 0);
    else {
      const r = [];
      for (let i = 0; i < this.G; i++) {
        const s = t.COLOR_ATTACHMENT0 + i;
        t.framebufferTexture2D(t.FRAMEBUFFER, s, t.TEXTURE_2D, this.F[i], 0), r.push(s);
      }
      t.drawBuffers(r);
    }
    const e = t.checkFramebufferStatus(t.FRAMEBUFFER);
    e !== t.FRAMEBUFFER_COMPLETE && console.error("GLFramebuffer is not complete:", e), t.bindFramebuffer(t.FRAMEBUFFER, null);
  }
  L(t) {
    const e = this.S;
    e.bindTexture(e.TEXTURE_2D, this.F[0]), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, 1), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t), e.bindTexture(e.TEXTURE_2D, null);
  }
  W(t, e) {
    this.C = t, this.$ = e, this.R = null, this.P = Array(this.G).fill(null);
    const r = this.S, i = this.u.type === "float" ? r.FLOAT : r.UNSIGNED_BYTE;
    for (const s of this.F) r.bindTexture(r.TEXTURE_2D, s), r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, this.C, this.$, 0, r.RGBA, i, null);
    r.bindTexture(r.TEXTURE_2D, null);
  }
  k(t) {
    const e = this.S;
    if (t < 0 || t >= this.G) throw Error(`GLFramebuffer: attachment index ${t} out of range (count=${this.G})`);
    const r = this.P[t];
    if (r) return r;
    const i = this.C, s = this.$, n = new Uint8Array(i * s * 4), o = e.getParameter(e.READ_FRAMEBUFFER_BINDING);
    e.bindFramebuffer(e.READ_FRAMEBUFFER, this.M), e.readBuffer(e.COLOR_ATTACHMENT0 + t), e.readPixels(0, 0, i, s, e.RGBA, e.UNSIGNED_BYTE, n), e.bindFramebuffer(e.READ_FRAMEBUFFER, o);
    const h = 4 * i, l = new Uint8Array(n.length);
    for (let d = 0; d < s; d++) {
      const u = (s - 1 - d) * h, f = d * h;
      l.set(n.subarray(u, u + h), f);
    }
    return this.P[t] = l, l;
  }
  U() {
    for (let t = 0; t < this.G; t++) this.k(t);
  }
  V() {
    const t = this.S;
    this.D = { framebuffer: t.getParameter(t.FRAMEBUFFER_BINDING), viewport: t.getParameter(t.VIEWPORT) }, t.bindFramebuffer(t.FRAMEBUFFER, this.M), this.P = Array(this.G).fill(null);
    for (let e = 0; e < this.G; e++) t.clearBufferfv(t.COLOR, e, new Float32Array([0, 0, 0, 0]));
    t.viewport(0, 0, this.C, this.$), D(t, [0, 0, this.C, this.$]);
  }
  O() {
    if (!this.D) return;
    const t = this.S;
    t.bindFramebuffer(t.FRAMEBUFFER, this.D.framebuffer), t.viewport(...this.D.viewport), D(t, this.D.viewport), this.D = null;
  }
  j() {
    const t = this.S;
    this.M && t.deleteFramebuffer(this.M);
    for (const e of this.F) t.deleteTexture(e);
    this.F = [], this.P = [];
  }
  get width() {
    return this.C;
  }
  get height() {
    return this.$;
  }
  get pixels() {
    return this.R;
  }
  get options() {
    return { ...this.u };
  }
  get framebuffer() {
    return this.M;
  }
  get texture() {
    return this.F[0];
  }
  get textures() {
    return [...this.F];
  }
  get attachmentCount() {
    return this.G;
  }
  getAttachmentPixels(t) {
    return this.P[t] ?? null;
  }
}
class G {
  constructor(t, e, r) {
    c(this, "S");
    c(this, "H");
    c(this, "X", /* @__PURE__ */ new Map());
    c(this, "Y", /* @__PURE__ */ new Map());
    c(this, "q", 0);
    c(this, "Z");
    this.S = t, this.H = this.N(e, r), this.Z = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), this.J();
  }
  J() {
    const t = this.S.getProgramParameter(this.H, this.S.ACTIVE_UNIFORMS);
    for (let e = 0; e < t; e++) {
      const r = this.S.getActiveUniform(this.H, e);
      if (r) {
        const i = this.S.getUniformLocation(this.H, r.name);
        i && (this.X.set(r.name, i), this.Y.set(r.name, r.type));
      }
    }
  }
  N(t, e) {
    const r = this.K(this.S.VERTEX_SHADER, t), i = this.K(this.S.FRAGMENT_SHADER, e), s = this.S.createProgram();
    if (this.S.attachShader(s, r), this.S.attachShader(s, i), this.S.linkProgram(s), !this.S.getProgramParameter(s, this.S.LINK_STATUS)) {
      const n = this.S.getProgramInfoLog(s);
      throw Error("Shader program link error: " + n);
    }
    return this.S.deleteShader(r), this.S.deleteShader(i), s;
  }
  K(t, e) {
    const r = this.S.createShader(t);
    if (this.S.shaderSource(r, e), this.S.compileShader(r), !this.S.getShaderParameter(r, this.S.COMPILE_STATUS)) {
      const i = this.S.getShaderInfoLog(r);
      throw this.S.deleteShader(r), Error("Shader compilation error: " + i);
    }
    return r;
  }
  tt() {
    this.S.useProgram(this.H), this.et();
  }
  et() {
    this.q = 0;
  }
  st(t) {
    for (const [e, r] of Object.entries(t)) this.it(e, r);
  }
  rt(t) {
    return this.X.has(t);
  }
  it(t, e) {
    if (this.S.getParameter(this.S.CURRENT_PROGRAM) !== this.H) return void console.warn(`Attempting to set uniform '${t}' on shader that is not currently bound`);
    const r = this.X.get(t);
    if (r) if (typeof e == "number") this.S.uniform1f(r, e);
    else if (typeof e == "boolean") this.S.uniform1i(r, e ? 1 : 0);
    else if (Array.isArray(e)) switch (e.length) {
      case 2:
        this.S.uniform2f(r, e[0], e[1]);
        break;
      case 3:
        this.S.uniform3f(r, e[0], e[1], e[2]);
        break;
      case 4:
        this.S.uniform4f(r, e[0], e[1], e[2], e[3]);
        break;
      default:
        console.warn(`Unsupported array length ${e.length} for uniform '${t}'`);
    }
    else if (e instanceof WebGLTexture) {
      const i = this.nt();
      this.S.uniform1i(r, i), this.S.activeTexture(this.S.TEXTURE0 + i), this.S.bindTexture(this.S.TEXTURE_2D, e);
    } else if (e instanceof $) {
      const i = this.nt();
      this.S.uniform1i(r, i), this.S.activeTexture(this.S.TEXTURE0 + i), this.S.bindTexture(this.S.TEXTURE_2D, e.texture);
    } else if (typeof e == "object" && "texture" in e) {
      const i = this.nt();
      this.S.uniform1i(r, i), this.S.activeTexture(this.S.TEXTURE0 + i), this.S.bindTexture(this.S.TEXTURE_2D, e.texture);
    } else console.warn(`Unsupported uniform type for '${t}':`, typeof e);
  }
  nt() {
    return this.q >= this.Z && console.warn(`Exceeded maximum texture units (${this.Z}). Texture may not render correctly.`), this.q++;
  }
  get ot() {
    return this.H;
  }
  j() {
    this.S.deleteProgram(this.H);
  }
}
class tt {
  constructor() {
    c(this, "ht", 1);
    c(this, "ct", 0);
    c(this, "lt", 0);
    c(this, "ut", 0);
    c(this, "ft", [0, 0, 0]);
    c(this, "dt", [1, 1, 1, 1]);
    c(this, "_t", [0, 0, 0, 1]);
    c(this, "gt", !1);
    c(this, "vt", !1);
    c(this, "xt", !1);
    c(this, "Ct", [0, 0]);
    c(this, "yt", [0, 0, 0, 1]);
    c(this, "wt", []);
  }
  $t() {
    this.wt.push({ lineWeight: this.ht, rotationX: this.ct, rotationY: this.lt, rotationZ: this.ut, charRotation: [...this.Ct], flipHorizontally: this.gt, flipVertically: this.vt, invert: this.xt, character: [...this.ft], charColor: [...this.dt], cellColor: [...this._t] });
  }
  bt() {
    const t = this.wt.pop();
    t ? (this.ht = t.lineWeight, this.ct = t.rotationX, this.lt = t.rotationY, this.ut = t.rotationZ, this.Ct = t.charRotation, this.gt = t.flipHorizontally, this.vt = t.flipVertically, this.xt = t.invert, this.ft = t.character, this.dt = t.charColor, this._t = t.cellColor) : console.warn("pop() called without matching push()");
  }
  zt() {
    this.wt = [], this.ct = 0, this.lt = 0, this.ut = 0;
  }
  Rt(t) {
    t.lineWeight = this.ht, t.rotationX = this.ct, t.rotationY = this.lt, t.rotationZ = this.ut, t.character[0] = this.ft[0], t.character[1] = this.ft[1], t.character[2] = this.ft[2], t.charColor[0] = this.dt[0], t.charColor[1] = this.dt[1], t.charColor[2] = this.dt[2], t.charColor[3] = this.dt[3], t.bgColor[0] = this._t[0], t.bgColor[1] = this._t[1], t.bgColor[2] = this._t[2], t.bgColor[3] = this._t[3], t.flipHorizontally = this.gt, t.flipVertically = this.vt, t.invert = this.xt, t.charRotation[0] = this.Ct[0], t.charRotation[1] = this.Ct[1];
  }
  get lineWeight() {
    return this.ht;
  }
  get canvasBackgroundColor() {
    return this.yt;
  }
  Tt(t) {
    this.ht = Math.abs(t);
  }
  St(t) {
    this.ct = t;
  }
  Mt(t) {
    this.lt = t;
  }
  Ft(t) {
    this.ut = t;
  }
  Gt(t) {
    this.ft = t;
  }
  Dt(t, e, r, i = 255) {
    this.dt = [t / 255, e / 255, r / 255, i / 255];
  }
  Pt(t, e, r, i = 255) {
    this._t = [t / 255, e / 255, r / 255, i / 255];
  }
  At(t) {
    this.gt = t;
  }
  Bt(t) {
    this.vt = t;
  }
  It(t) {
    this.xt = t;
  }
  Lt(t) {
    const e = 255 * t / 360, r = Math.floor(e) / 255, i = Math.round(e - Math.floor(e));
    this.Ct = [r, i];
  }
  Et(t, e, r, i) {
    this.yt = [t / 255, e / 255, r / 255, i / 255];
  }
}
var O = `#version 300 es
in vec2 a_position;in vec2 a_texCoord;in vec2 a_instancePosition;in vec2 a_instanceSize;in vec3 a_instanceCharacter;in vec4 a_instancePrimaryColor;in vec4 a_instanceSecondaryColor;in vec2 a_instanceRotation;in vec3 a_instanceTransform;in vec3 a_instanceGlobalRotation;in vec2 a_instanceRotationCenter;in vec2 a_instanceBezierCP1;in vec2 a_instanceBezierCP2;in vec2 a_instanceBezierStart;in vec2 a_instanceBezierEnd;in vec2 a_instanceArcAngles;uniform float u_aspectRatio;uniform vec2 u_viewportSize;out vec2 v_uv;out vec3 v_character;out vec4 v_primaryColor;out vec4 v_secondaryColor;out vec2 v_rotation;out vec3 v_transform;mat3 rotateX(float a){float s=sin(a),c=cos(a);return mat3(1,0,0,0,c,-s,0,s,c);}mat3 rotateY(float a){float s=sin(a),c=cos(a);return mat3(c,0,s,0,1,0,-s,0,c);}mat3 rotateZ(float a){float s=sin(a),c=cos(a);return mat3(c,-s,0,s,c,0,0,0,1);}vec2 evaluateBezier(float t,vec2 p0,vec2 p1,vec2 p2,vec2 p3){float u=1.-t,u2=u*u,t2=t*t;return u2*u*p0+3.*u2*t*p1+3.*u*t2*p2+t2*t*p3;}vec2 evaluateBezierDerivative(float t,vec2 p0,vec2 p1,vec2 p2,vec2 p3){float u=1.-t,u2=u*u,t2=t*t;return-3.*u2*p0+3.*u2*p1-6.*u*t*p1+6.*u*t*p2-3.*t2*p2+3.*t2*p3;}void main(){v_uv=a_texCoord;v_character=a_instanceCharacter;v_primaryColor=a_instancePrimaryColor;v_secondaryColor=a_instanceSecondaryColor;v_rotation=a_instanceRotation;v_transform=a_instanceTransform;vec2 worldPosition;bool isBezier=length(a_instanceBezierCP1)+length(a_instanceBezierCP2)+length(a_instanceBezierStart)+length(a_instanceBezierEnd)>0.;bool isArc=a_instanceArcAngles.x!=0.||a_instanceArcAngles.y!=0.;if(isBezier){float t=a_position.x;vec2 curvePoint=evaluateBezier(t,a_instanceBezierStart,a_instanceBezierCP1,a_instanceBezierCP2,a_instanceBezierEnd);vec2 tangent=evaluateBezierDerivative(t,a_instanceBezierStart,a_instanceBezierCP1,a_instanceBezierCP2,a_instanceBezierEnd);float tLen=length(tangent);tangent=tLen>0.?tangent/tLen:vec2(1,0);worldPosition=curvePoint+vec2(-tangent.y,tangent.x)*a_position.y*a_instanceSize.y;}else if(isArc){float s=a_instanceArcAngles.x,e=a_instanceArcAngles.y;s=mod(s,6.28318530718);if(s<0.)s+=6.28318530718;e=mod(e,6.28318530718);if(e<0.)e+=6.28318530718;float d=s-e;if(d<=0.)d+=6.28318530718;float angle=s-a_position.x*d;vec2 local=vec2(cos(angle),sin(angle))*a_position.y;worldPosition=local*a_instanceSize*.5+a_instanceSize*.5+a_instancePosition;}else{worldPosition=a_position*a_instanceSize+a_instancePosition;}vec2 ndc=(worldPosition/u_viewportSize)*2.-1.;ndc.y=-ndc.y;if(length(a_instanceGlobalRotation)>0.){vec3 pos3D=vec3(ndc-a_instanceRotationCenter,0);pos3D.x*=u_aspectRatio;if(a_instanceGlobalRotation.x!=0.)pos3D=rotateX(-a_instanceGlobalRotation.x)*pos3D;if(a_instanceGlobalRotation.y!=0.)pos3D=rotateY(-a_instanceGlobalRotation.y)*pos3D;if(a_instanceGlobalRotation.z!=0.)pos3D=rotateZ(-a_instanceGlobalRotation.z)*pos3D;pos3D.x/=u_aspectRatio;ndc=pos3D.xy+a_instanceRotationCenter;}gl_Position=vec4(ndc,0,1);}`, x = ((a) => (a.RECTANGLE = "rectangle", a.LINE = "line", a.ELLIPSE = "ellipse", a.ARC = "arc", a.TRIANGLE = "triangle", a.BEZIER_CURVE = "bezier_curve", a.CUSTOM = "custom", a))(x || {});
class et {
  constructor(t) {
    c(this, "S");
    c(this, "Wt", /* @__PURE__ */ new Map());
    this.S = t;
  }
  kt(t, e, r, i) {
    const s = this.S;
    let n = this.Wt.get(t);
    n || (n = /* @__PURE__ */ new Map(), this.Wt.set(t, n));
    let o = n.get(e) || null;
    if (!o) {
      o = s.createVertexArray(), n.set(e, o), s.bindVertexArray(o), s.bindBuffer(s.ARRAY_BUFFER, i);
      const h = s.getAttribLocation(t, "a_position");
      h !== -1 && (s.enableVertexAttribArray(h), s.vertexAttribPointer(h, r.attributes.position.size, s.FLOAT, !1, r.stride, r.attributes.position.offset), s.vertexAttribDivisor(h, 0));
      const l = s.getAttribLocation(t, "a_texCoord");
      l !== -1 && (s.enableVertexAttribArray(l), s.vertexAttribPointer(l, r.attributes.texCoord.size, s.FLOAT, !1, r.stride, r.attributes.texCoord.offset), s.vertexAttribDivisor(l, 0));
    }
    s.bindVertexArray(o);
  }
  Ut() {
    this.S.bindVertexArray(null);
  }
  j() {
    const t = this.S;
    for (const [, e] of this.Wt) for (const [, r] of e) r && t.deleteVertexArray(r);
    this.Wt.clear();
  }
}
class rt {
  constructor(t) {
    c(this, "Vt");
    c(this, "S");
    c(this, "Ot", null);
    c(this, "jt", null);
    c(this, "Ht", null);
    this.S = t, this.Vt = new et(t);
  }
  Xt(t, e, r) {
    const { shader: i } = t, s = U(this.S) || this.S.getParameter(this.S.VIEWPORT), n = { u_aspectRatio: s[2] / s[3], u_viewportSize: [s[2], s[3]] }, o = {};
    for (const [u, f] of Object.entries(n)) i.rt(u) && (o[u] = f);
    Object.keys(o).length > 0 && i.st(o);
    const h = (u) => {
      if (!u || !u.Yt()) return;
      const f = u.unitGeometry, g = u.unitBuffer;
      try {
        this.Vt.kt(i.ot, u.type + "", f, g), u.batch.qt(i), u.batch.Zt(f.primitiveType, f.vertexCount);
      } finally {
        u.batch.Nt(i), this.Vt.Ut(), u.Qt();
      }
    };
    let l = null, d = null;
    for (const u of e) {
      if (u.type === x.CUSTOM) {
        d && (h(d), l = null, d = null), this.Jt(t, u.params, u.state, r.get(x.RECTANGLE) || null);
        continue;
      }
      l !== null && u.type !== l && (h(d), l = null, d = null);
      let f = d;
      f && u.type === l || (f = r.get(u.type) || null, d = f, l = u.type), f && f.Kt(u.params, u.state);
    }
    h(d);
  }
  Jt(t, e, r, i) {
    if (!i) return;
    const { x: s, y: n, width: o, height: h, shader: l, uniforms: d } = e, u = this.S;
    l.tt(), i.Qt();
    const f = this.te(Math.max(1, Math.floor(o)), Math.max(1, Math.floor(h)));
    f.V(), l.tt(), d && Object.keys(d).length && l.st(d);
    {
      const y = U(u) || u.getParameter(u.VIEWPORT);
      l.rt("u_aspectRatio") && l.it("u_aspectRatio", y[2] / y[3]), l.rt("u_viewportSize") && l.it("u_viewportSize", [y[2], y[3]]);
    }
    const g = { ...r, rotationX: 0, rotationY: 0, rotationZ: 0 };
    if (i.Kt({ x: 0, y: 0, width: f.width, height: f.height }, g), i.Yt()) {
      const y = i.unitGeometry, P = i.unitBuffer;
      try {
        this.Vt.kt(l.ot, i.type + "", y, P), i.batch.qt(l), i.batch.Zt(y.primitiveType, y.vertexCount);
      } finally {
        i.batch.Nt(l), this.Vt.Ut(), i.Qt();
      }
    }
    f.O();
    const p = this.ee();
    p.tt(), p.st({ u_src0: f.textures[0], u_src1: f.textures[1], u_src2: f.textures[2], u_src3: f.textures[3], u_src4: f.textures[4], u_srcSize: [f.width, f.height] });
    const m = U(u) || u.getParameter(u.VIEWPORT);
    p.rt("u_aspectRatio") && p.it("u_aspectRatio", m[2] / m[3]), p.rt("u_viewportSize") && p.it("u_viewportSize", [m[2], m[3]]);
    const R = Math.floor(s), v = Math.floor(n), E = Math.max(1, Math.floor(o)), b = Math.max(1, Math.floor(h));
    if (i.Kt({ x: R, y: v, width: E, height: b }, r), i.Yt()) {
      const y = i.unitGeometry, P = i.unitBuffer;
      try {
        this.Vt.kt(p.ot, i.type + "", y, P), i.batch.qt(p), i.batch.Zt(y.primitiveType, y.vertexCount);
      } finally {
        i.batch.Nt(p), this.Vt.Ut(), i.Qt();
      }
    }
    t.shader.tt();
  }
  ee() {
    return this.Ot || (this.Ot = new G(this.S, O, `#version 300 es
precision highp float;in vec2 v_uv;uniform sampler2D u_src0;uniform sampler2D u_src1;uniform sampler2D u_src2;uniform sampler2D u_src3;uniform sampler2D u_src4;uniform vec2 u_srcSize;layout(location=0)out vec4 o_character;layout(location=1)out vec4 o_primaryColor;layout(location=2)out vec4 o_secondaryColor;layout(location=3)out vec4 o_rotation;layout(location=4)out vec4 o_transform;void main(){vec2 uvTex=v_uv*u_srcSize;vec2 uvQ=(floor(uvTex)+0.5f)/u_srcSize;o_character=texture(u_src0,uvQ);o_primaryColor=texture(u_src1,uvQ);o_secondaryColor=texture(u_src2,uvQ);o_rotation=texture(u_src3,uvQ);o_transform=texture(u_src4,uvQ);}`)), this.Ot;
  }
  te(t, e) {
    return this.jt && this.Ht && this.Ht.w === t && this.Ht.h === e || (this.jt && this.jt.j(), this.jt = new $(this.S, t, e, 5), this.Ht = { w: t, h: e }), this.jt;
  }
}
class it {
  constructor() {
    c(this, "se", []);
    c(this, "ie", 1);
    c(this, "re", 0);
  }
  ne(t) {
    if (this.re >= this.se.length) {
      const r = { id: this.ie++, type: t, params: {}, state: { lineWeight: 1, rotationX: 0, rotationY: 0, rotationZ: 0, character: [0, 0, 0], charColor: [1, 1, 1, 1], bgColor: [0, 0, 0, 1], flipHorizontally: !1, flipVertically: !1, invert: !1, charRotation: [0, 0] } };
      this.se.push(r);
    }
    const e = this.se[this.re];
    switch (e.id = this.ie++, e.type = t, t) {
      case x.RECTANGLE:
      case x.ELLIPSE:
        e.params && "width" in e.params || (e.params = { x: 0, y: 0, width: 0, height: 0 });
        break;
      case x.CUSTOM:
        e.params && "shader" in e.params || (e.params = { x: 0, y: 0, width: 0, height: 0, shader: void 0, uniforms: {} });
        break;
      case x.ARC:
        e.params && "start" in e.params || (e.params = { x: 0, y: 0, width: 0, height: 0, start: 0, stop: 0 });
        break;
      case x.LINE:
        e.params && "x2" in e.params || (e.params = { x1: 0, y1: 0, x2: 0, y2: 0, thickness: void 0 });
        break;
      case x.TRIANGLE:
        e.params && "x3" in e.params || (e.params = { x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 });
        break;
      case x.BEZIER_CURVE:
        e.params && "cp2y" in e.params || (e.params = { x1: 0, y1: 0, cp1x: 0, cp1y: 0, cp2x: 0, cp2y: 0, x2: 0, y2: 0, thickness: void 0 });
        break;
      default:
        e.params || (e.params = {});
    }
    return this.re++, e;
  }
  oe(t, e, r, i, s) {
    const n = this.ne(x.RECTANGLE);
    return n.params.x = t, n.params.y = e, n.params.width = r, n.params.height = i, s.Rt(n.state), n.id;
  }
  ae(t, e, r, i, s, n, o) {
    const h = this.ne(x.CUSTOM);
    return h.params.x = t, h.params.y = e, h.params.width = r, h.params.height = i, h.params.shader = s, h.params.uniforms = n, o.Rt(h.state), h.id;
  }
  he(t, e, r, i, s, n) {
    const o = this.ne(x.LINE);
    return o.params.x1 = t, o.params.y1 = e, o.params.x2 = r, o.params.y2 = i, o.params.thickness = s, n.Rt(o.state), o.id;
  }
  ce(t, e, r, i, s) {
    const n = this.ne(x.ELLIPSE);
    return n.params.x = t, n.params.y = e, n.params.width = r, n.params.height = i, s.Rt(n.state), n.id;
  }
  le(t, e, r, i, s, n, o) {
    const h = this.ne(x.ARC);
    return h.params.x = t, h.params.y = e, h.params.width = r, h.params.height = i, h.params.start = s, h.params.stop = n, o.Rt(h.state), h.id;
  }
  ue(t, e, r, i, s, n, o) {
    const h = this.ne(x.TRIANGLE);
    return h.params.x1 = t, h.params.y1 = e, h.params.x2 = r, h.params.y2 = i, h.params.x3 = s, h.params.y3 = n, o.Rt(h.state), h.id;
  }
  fe(t, e, r, i, s, n, o, h, l, d) {
    const u = this.ne(x.BEZIER_CURVE);
    return u.params.x1 = t, u.params.y1 = e, u.params.cp1x = r, u.params.cp1y = i, u.params.cp2x = s, u.params.cp2y = n, u.params.x2 = o, u.params.y2 = h, u.params.thickness = l, d.Rt(u.state), u.id;
  }
  get length() {
    return this.re;
  }
  get isEmpty() {
    return this.re === 0;
  }
  de() {
    this.re = 0;
  }
  [Symbol.iterator]() {
    let t = 0;
    const e = this.re, r = this.se;
    return { next: () => t < e ? { value: r[t++], done: !1 } : { value: void 0, done: !0 } };
  }
}
const T = class T {
  static pe(t, e, r = 0) {
    var n, o, h, l, d, u, f, g, p, m;
    const i = e || new Float32Array(T.FLOATS_PER_INSTANCE);
    let s = r;
    return i[s++] = t.position[0], i[s++] = t.position[1], i[s++] = t.size[0], i[s++] = t.size[1], i[s++] = t.character[0], i[s++] = t.character[1], i[s++] = t.character[2], i[s++] = t.primaryColor[0], i[s++] = t.primaryColor[1], i[s++] = t.primaryColor[2], i[s++] = t.primaryColor[3], i[s++] = t.secondaryColor[0], i[s++] = t.secondaryColor[1], i[s++] = t.secondaryColor[2], i[s++] = t.secondaryColor[3], i[s++] = t.rotation[0], i[s++] = t.rotation[1], i[s++] = t.transform[0], i[s++] = t.transform[1], i[s++] = t.transform[2], i[s++] = t.globalRotationX, i[s++] = t.globalRotationY, i[s++] = t.globalRotationZ, i[s++] = t.rotationCenter[0], i[s++] = t.rotationCenter[1], i[s++] = ((n = t.arcAngles) == null ? void 0 : n[0]) || 0, i[s++] = ((o = t.arcAngles) == null ? void 0 : o[1]) || 0, i[s++] = ((h = t.bezierControlPoint1) == null ? void 0 : h[0]) || 0, i[s++] = ((l = t.bezierControlPoint1) == null ? void 0 : l[1]) || 0, i[s++] = ((d = t.bezierControlPoint2) == null ? void 0 : d[0]) || 0, i[s++] = ((u = t.bezierControlPoint2) == null ? void 0 : u[1]) || 0, i[s++] = ((f = t.bezierStartPoint) == null ? void 0 : f[0]) || 0, i[s++] = ((g = t.bezierStartPoint) == null ? void 0 : g[1]) || 0, i[s++] = ((p = t.bezierEndPoint) == null ? void 0 : p[0]) || 0, i[s++] = ((m = t.bezierEndPoint) == null ? void 0 : m[1]) || 0, i;
  }
  static _e(t) {
    const e = t.length * T.FLOATS_PER_INSTANCE, r = new Float32Array(e);
    for (let i = 0; i < t.length; i++) {
      const s = i * T.FLOATS_PER_INSTANCE;
      T.pe(t[i], r, s);
    }
    return r;
  }
};
c(T, "BYTES_PER_INSTANCE", 140), c(T, "FLOATS_PER_INSTANCE", 35);
let F = T;
const C = class C {
};
c(C, "STRIDE", F.BYTES_PER_INSTANCE), c(C, "ATTRIBUTES", { a_instancePosition: { location: -1, size: 2, type: WebGL2RenderingContext.FLOAT, normalized: !1, stride: C.STRIDE, offset: 0, divisor: 1 }, a_instanceSize: { location: -1, size: 2, type: WebGL2RenderingContext.FLOAT, normalized: !1, stride: C.STRIDE, offset: 8, divisor: 1 }, a_instanceCharacter: { location: -1, size: 3, type: WebGL2RenderingContext.FLOAT, normalized: !1, stride: C.STRIDE, offset: 16, divisor: 1 }, a_instancePrimaryColor: { location: -1, size: 4, type: WebGL2RenderingContext.FLOAT, normalized: !1, stride: C.STRIDE, offset: 28, divisor: 1 }, a_instanceSecondaryColor: { location: -1, size: 4, type: WebGL2RenderingContext.FLOAT, normalized: !1, stride: C.STRIDE, offset: 44, divisor: 1 }, a_instanceRotation: { location: -1, size: 2, type: WebGL2RenderingContext.FLOAT, normalized: !1, stride: C.STRIDE, offset: 60, divisor: 1 }, a_instanceTransform: { location: -1, size: 3, type: WebGL2RenderingContext.FLOAT, normalized: !1, stride: C.STRIDE, offset: 68, divisor: 1 }, a_instanceGlobalRotation: { location: -1, size: 3, type: WebGL2RenderingContext.FLOAT, normalized: !1, stride: C.STRIDE, offset: 80, divisor: 1 }, a_instanceRotationCenter: { location: -1, size: 2, type: WebGL2RenderingContext.FLOAT, normalized: !1, stride: C.STRIDE, offset: 92, divisor: 1 }, a_instanceArcAngles: { location: -1, size: 2, type: WebGL2RenderingContext.FLOAT, normalized: !1, stride: C.STRIDE, offset: 100, divisor: 1 }, a_instanceBezierCP1: { location: -1, size: 2, type: WebGL2RenderingContext.FLOAT, normalized: !1, stride: C.STRIDE, offset: 108, divisor: 1 }, a_instanceBezierCP2: { location: -1, size: 2, type: WebGL2RenderingContext.FLOAT, normalized: !1, stride: C.STRIDE, offset: 116, divisor: 1 }, a_instanceBezierStart: { location: -1, size: 2, type: WebGL2RenderingContext.FLOAT, normalized: !1, stride: C.STRIDE, offset: 124, divisor: 1 }, a_instanceBezierEnd: { location: -1, size: 2, type: WebGL2RenderingContext.FLOAT, normalized: !1, stride: C.STRIDE, offset: 132, divisor: 1 } });
let M = C;
class st {
  constructor(t, e = 1e3, r = 1.5) {
    c(this, "S");
    c(this, "ge", []);
    c(this, "me");
    c(this, "ve");
    c(this, "xe", null);
    c(this, "Ce", !0);
    c(this, "ye", 0);
    c(this, "we", /* @__PURE__ */ new Map());
    c(this, "$e", null);
    this.S = t, this.me = e, this.ve = r, this.be();
  }
  Kt(t) {
    const e = this.ge.length;
    return this.ge.push(t), this.Ce = !0, e;
  }
  get count() {
    return this.ge.length;
  }
  get isEmpty() {
    return this.ge.length === 0;
  }
  clear() {
    this.ge.length = 0, this.Ce = !0;
  }
  ze(t) {
    if (t <= this.me) return;
    const e = Math.ceil(t * this.ve);
    this.me = e, this.be();
  }
  be() {
    const t = this.S;
    this.xe && t.deleteBuffer(this.xe), this.xe = t.createBuffer();
    const e = this.me * F.BYTES_PER_INSTANCE;
    t.bindBuffer(t.ARRAY_BUFFER, this.xe), t.bufferData(t.ARRAY_BUFFER, e, t.DYNAMIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, null), this.Ce = !0, this.ye = 0;
  }
  Re() {
    if (!this.Ce || this.ge.length === 0) return;
    const t = this.S, e = this.ge.length;
    this.ze(e), (!this.$e || this.$e.length < e * F.FLOATS_PER_INSTANCE) && (this.$e = new Float32Array(e * F.FLOATS_PER_INSTANCE));
    const r = F._e(this.ge);
    t.bindBuffer(t.ARRAY_BUFFER, this.xe), e <= this.ye ? t.bufferSubData(t.ARRAY_BUFFER, 0, r) : t.bufferData(t.ARRAY_BUFFER, r, t.DYNAMIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, null), this.Ce = !1, this.ye = e;
  }
  Te(t) {
    let e = this.we.get(t);
    if (!e) {
      e = /* @__PURE__ */ new Map();
      const r = this.S;
      for (const i in M.ATTRIBUTES) {
        const s = r.getAttribLocation(t, i);
        s !== -1 && e.set(i, s);
      }
      this.we.set(t, e);
    }
    return e;
  }
  qt(t) {
    if (!this.xe || this.ge.length === 0) return;
    const e = this.S, r = t.ot;
    this.Re();
    const i = this.Te(r);
    e.bindBuffer(e.ARRAY_BUFFER, this.xe);
    for (const [s, n] of i) {
      const o = M.ATTRIBUTES[s];
      o && (e.enableVertexAttribArray(n), e.vertexAttribPointer(n, o.size, o.type, o.normalized, o.stride, o.offset), e.vertexAttribDivisor(n, o.divisor));
    }
  }
  Nt(t) {
    const e = this.S, r = this.Te(t.ot);
    for (const [, i] of r) e.disableVertexAttribArray(i), e.vertexAttribDivisor(i, 0);
  }
  Zt(t, e) {
    this.ge.length !== 0 && this.S.drawArraysInstanced(t, 0, e, this.ge.length);
  }
  j() {
    const t = this.S;
    this.xe && (t.deleteBuffer(this.xe), this.xe = null), this.ge.length = 0, this.we.clear(), this.$e = null;
  }
}
class L {
  constructor(t, e, r, i) {
    c(this, "S");
    c(this, "Se");
    c(this, "Me");
    c(this, "Fe");
    c(this, "Ge", null);
    this.S = t, this.Se = e, this.Me = r, this.Fe = i;
    const s = this.S.createBuffer();
    if (!s) throw Error("Failed to create unit geometry buffer");
    this.S.bindBuffer(this.S.ARRAY_BUFFER, s), this.S.bufferData(this.S.ARRAY_BUFFER, this.Fe.vertices, this.S.STATIC_DRAW), this.S.bindBuffer(this.S.ARRAY_BUFFER, null), this.Ge = s;
  }
  get type() {
    return this.Me;
  }
  get unitGeometry() {
    return this.Fe;
  }
  get unitBuffer() {
    return this.Ge;
  }
  get batch() {
    return this.Se;
  }
  Qt() {
    this.Se.clear();
  }
  Yt() {
    return !this.Se.isEmpty;
  }
  j() {
    this.Se.j(), this.Ge && (this.S.deleteBuffer(this.Ge), this.Ge = null);
  }
  De(t, e, r, i, s) {
    const n = this.Pe(t, e, r, i, s.rotationX || 0, s.rotationY || 0, s.rotationZ || 0);
    return { position: [t, e], size: [r, i], character: s.character || [0, 0, 0], primaryColor: s.charColor || [1, 1, 1, 1], secondaryColor: s.bgColor || [0, 0, 0, 1], rotation: s.charRotation || [0, 0], transform: [s.invert ? 1 : 0, s.flipHorizontally ? 1 : 0, s.flipVertically ? 1 : 0], globalRotationX: n.radiansX, globalRotationY: n.radiansY, globalRotationZ: n.radiansZ, rotationCenter: [n.centerX, n.centerY] };
  }
  Ae(t, e) {
    const r = U(this.S) || [0, 0, this.S.canvas.width, this.S.canvas.height];
    return { nx: t / r[2] * 2 - 1, ny: 1 - e / r[3] * 2 };
  }
  Be(t, e, r) {
    const i = this.Ae(e, r);
    t.rotationCenter = [i.nx, i.ny];
  }
  Pe(t, e, r, i, s, n, o) {
    const h = U(this.S) || [0, 0, this.S.canvas.width, this.S.canvas.height], l = h[2], d = h[3];
    return { centerX: (t + r / 2) / l * 2 - 1, centerY: 1 - (e + i / 2) / d * 2, radiansX: -s * Math.PI / 180, radiansY: -n * Math.PI / 180, radiansZ: -o * Math.PI / 180, aspectRatio: l / d };
  }
}
const nt = { vertices: new Float32Array([0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1]), vertexCount: 6, primitiveType: WebGL2RenderingContext.TRIANGLES, stride: 16, attributes: { position: { size: 2, offset: 0 }, texCoord: { size: 2, offset: 8 } } };
class ot extends L {
  constructor(t, e) {
    super(t, e, x.RECTANGLE, nt);
  }
  Kt(t, e) {
    const r = this.De(t.x, t.y, t.width, t.height, e);
    return this.Se.Kt(r);
  }
}
const at = { vertices: new Float32Array([0, -0.5, 0, 0, 1, -0.5, 1, 0, 0, 0.5, 0, 1, 0, 0.5, 0, 1, 1, -0.5, 1, 0, 1, 0.5, 1, 1]), vertexCount: 6, primitiveType: WebGL2RenderingContext.TRIANGLES, stride: 16, attributes: { position: { size: 2, offset: 0 }, texCoord: { size: 2, offset: 8 } } };
class ht extends L {
  constructor(t, e) {
    super(t, e, x.LINE, at);
  }
  Kt(t, e) {
    const r = t.x2 - t.x1, i = t.y2 - t.y1, s = Math.hypot(r, i), n = Math.atan2(i, r), o = t.thickness || e.lineWeight || 1, h = t.x1 + r / 2, l = t.y1 + i / 2, d = h - s / 2, u = l, f = { character: e.character, charColor: e.charColor, bgColor: e.bgColor, charRotation: e.charRotation, flipHorizontally: e.flipHorizontally, flipVertically: e.flipVertically, invert: e.invert, rotationX: e.rotationX || 0, rotationY: e.rotationY || 0, rotationZ: (e.rotationZ || 0) + 180 * n / Math.PI, lineWeight: o }, g = this.De(d, u, s, o, f);
    return this.Be(g, h, l), this.Se.Kt(g);
  }
}
const ct = { vertices: function(a = 32) {
  const t = [], e = 2 * Math.PI / a;
  for (let r = 0; r < a; r++) {
    const i = r * e, s = (r + 1) % a * e, n = Math.cos(i), o = Math.sin(i), h = 0.5 * (n + 1), l = 0.5 * (o + 1), d = Math.cos(s), u = Math.sin(s), f = 0.5 * (d + 1), g = 0.5 * (u + 1);
    t.push(0, 0, 0.5, 0.5, n, o, h, l, d, u, f, g);
  }
  return new Float32Array(t);
}(32), vertexCount: 96, primitiveType: WebGL2RenderingContext.TRIANGLES, stride: 16, attributes: { position: { size: 2, offset: 0 }, texCoord: { size: 2, offset: 8 } } };
class lt extends L {
  constructor(t, e) {
    super(t, e, x.ELLIPSE, ct);
  }
  Kt(t, e) {
    const r = this.De(t.x, t.y, t.width, t.height, e);
    return this.Be(r, t.x, t.y), this.Se.Kt(r);
  }
}
let ut = { vertices: function(a) {
  const t = [];
  for (let e = 0; e < a; e++) {
    const r = e / a, i = (e + 1) / a;
    t.push(r, 0, r, 0, r, 1, r, 1, i, 1, i, 1);
  }
  return new Float32Array(t);
}(32), vertexCount: 96, primitiveType: WebGL2RenderingContext.TRIANGLES, stride: 16, attributes: { position: { size: 2, offset: 0 }, texCoord: { size: 2, offset: 8 } } };
class ft extends L {
  constructor(t, e) {
    super(t, e, x.ARC, ut);
  }
  Kt(t, e) {
    const r = t.x - t.width / 2, i = t.y - t.height / 2, s = t.start * Math.PI / 180, n = t.stop * Math.PI / 180, o = this.De(r, i, t.width, t.height, e);
    return this.Be(o, t.x, t.y), o.arcAngles = [s, n], this.Se.Kt(o);
  }
}
const dt = { vertices: new Float32Array([0, 0, 0, 0, 1, 0, 1, 0, 0.5, 1, 0.5, 1]), vertexCount: 3, primitiveType: WebGL2RenderingContext.TRIANGLES, stride: 16, attributes: { position: { size: 2, offset: 0 }, texCoord: { size: 2, offset: 8 } } };
class pt extends L {
  constructor(t, e) {
    super(t, e, x.TRIANGLE, dt);
  }
  Kt(t, e) {
    const r = Math.min(t.x1, t.x2, t.x3), i = Math.max(t.x1, t.x2, t.x3), s = Math.min(t.y1, t.y2, t.y3), n = i - r, o = Math.max(t.y1, t.y2, t.y3) - s, h = this.De(r, s, n, o, e), l = r + 0.5 * n, d = s + o * (1 / 3);
    return this.Be(h, l, d), this.Se.Kt(h);
  }
}
function V(a, t, e, r, i) {
  const s = 1 - a, n = s * s, o = a * a;
  return n * s * t + 3 * n * a * e + 3 * s * o * r + o * a * i;
}
const gt = { vertices: function(a = 16) {
  const t = [];
  for (let e = 0; e < a; e++) {
    const r = e / a, i = (e + 1) / a;
    t.push(r, -0.5, r, 0), t.push(i, -0.5, i, 0), t.push(r, 0.5, r, 1), t.push(r, 0.5, r, 1), t.push(i, -0.5, i, 0), t.push(i, 0.5, i, 1);
  }
  return new Float32Array(t);
}(16), vertexCount: 96, primitiveType: WebGL2RenderingContext.TRIANGLES, stride: 16, attributes: { position: { size: 2, offset: 0 }, texCoord: { size: 2, offset: 8 } } };
class mt extends L {
  constructor(t, e) {
    super(t, e, x.BEZIER_CURVE, gt);
  }
  Kt(t, e) {
    const r = e.lineWeight || 1, i = V(0.5, t.x1, t.cp1x, t.cp2x, t.x2), s = V(0.5, t.y1, t.cp1y, t.cp2y, t.y2), n = { character: e.character, charColor: e.charColor, bgColor: e.bgColor, charRotation: e.charRotation, flipHorizontally: e.flipHorizontally, flipVertically: e.flipVertically, invert: e.invert, rotationX: e.rotationX || 0, rotationY: e.rotationY || 0, rotationZ: e.rotationZ || 0, lineWeight: r }, o = this.De(0, 0, 1, r, n);
    return this.Be(o, i, s), o.bezierStartPoint = [t.x1, t.y1], o.bezierControlPoint1 = [t.cp1x, t.cp1y], o.bezierControlPoint2 = [t.cp2x, t.cp2y], o.bezierEndPoint = [t.x2, t.y2], this.Se.Kt(o);
  }
}
class xt {
  constructor(t) {
    c(this, "S");
    c(this, "Ie", null);
    c(this, "Le", null);
    c(this, "Ee", {});
    c(this, "We", null);
    c(this, "ke", /* @__PURE__ */ new Map());
    c(this, "Ue");
    c(this, "Ve");
    c(this, "Oe");
    this.S = t, this.Oe = new tt(), this.Ue = new rt(t), this.Ve = new it(), this.We = t.createBuffer(), D(this.S, [0, 0, this.S.canvas.width, this.S.canvas.height]);
  }
  je(t) {
    let e = this.ke.get(t);
    if (e) return e;
    const r = new st(this.S);
    return e = (0, { [x.RECTANGLE]: () => new ot(this.S, r), [x.LINE]: () => new ht(this.S, r), [x.ELLIPSE]: () => new lt(this.S, r), [x.ARC]: () => new ft(this.S, r), [x.TRIANGLE]: () => new pt(this.S, r), [x.BEZIER_CURVE]: () => new mt(this.S, r) }[t])(), this.ke.set(t, e), e;
  }
  He(t) {
    this.Ie !== t && (this.Ie = t, t.tt());
  }
  Xe(t, e) {
    return new G(this.S, t, e);
  }
  Ye(t) {
    this.Le = t, t && (this.Ee = {});
  }
  qe(t, e) {
    this.Ee[t] = e;
  }
  Ze(t) {
    Object.assign(this.Ee, t);
  }
  Ne(t) {
    return new G(this.S, O, t);
  }
  Qe(t, e, r, i) {
    var m;
    const s = this.S, n = s.canvas.width, o = s.canvas.height, h = t / n * 2 - 1, l = (t + r) / n * 2 - 1, d = 1 - e / o * 2, u = 1 - (e + i) / o * 2, f = new Float32Array([h, u, l, u, h, d, l, u, l, d, h, d]);
    s.bindBuffer(s.ARRAY_BUFFER, this.We), s.bufferData(s.ARRAY_BUFFER, f, s.DYNAMIC_DRAW);
    const g = ((m = this.Ie) == null ? void 0 : m.ot) || s.getParameter(s.CURRENT_PROGRAM), p = g ? s.getAttribLocation(g, "a_position") : -1;
    p !== -1 && (s.enableVertexAttribArray(p), s.vertexAttribPointer(p, 2, s.FLOAT, !1, 8, 0)), s.drawArrays(s.TRIANGLES, 0, 6), p !== -1 && s.disableVertexAttribArray(p);
  }
  Je(t, e, r, i) {
    this.Le ? (this.Ve.ae(t, e, r, i, this.Le, { ...this.Ee }, this.Oe), this.Le = null, this.Ee = {}) : this.Ve.oe(t, e, r, i, this.Oe);
  }
  Ke(t, e, r, i) {
    this.Ve.he(t, e, r, i, this.Oe.lineWeight, this.Oe);
  }
  ts(t, e, r, i) {
    this.Ve.ce(t, e, r, i, this.Oe);
  }
  es(t, e, r, i, s, n) {
    this.Ve.ue(t, e, r, i, s, n, this.Oe);
  }
  ss(t, e, r, i, s, n, o, h) {
    const l = this.Oe.lineWeight;
    this.Ve.fe(t, e, r, i, s, n, o, h, l, this.Oe);
  }
  rs(t, e, r = 1, i = {}) {
    return new $(this.S, t, e, r, i);
  }
  ns(t, e, r, i, s, n) {
    this.Ve.le(t, e, r, i, s, n, this.Oe);
  }
  hs(t, e = t, r = t, i = 255) {
    this.state.Et(t, e, r, i), this.de(t / 255, e / 255, r / 255, i / 255);
  }
  de(t = 0, e = 0, r = 0, i = 0) {
    this.S.clearColor(t, e, r, i), this.S.clear(this.S.COLOR_BUFFER_BIT);
  }
  cs() {
    this.S.viewport(0, 0, this.S.canvas.width, this.S.canvas.height), D(this.S, [0, 0, this.S.canvas.width, this.S.canvas.height]);
  }
  get context() {
    return this.S;
  }
  get state() {
    return this.Oe;
  }
  ls(t) {
    const e = t, r = U(this.S) ?? this.S.getParameter(this.S.VIEWPORT), i = { shader: e, gl: this.S, viewport: r };
    this.He(e);
    const s = /* @__PURE__ */ new Set();
    for (const n of this.Ve) n.type === x.CUSTOM ? s.add(x.RECTANGLE) : s.add(n.type);
    for (const n of s) n !== x.CUSTOM && this.je(n);
    this.Ue.Xt(i, this.Ve, this.ke), this.Ve.de();
  }
  j() {
    this.S.deleteBuffer(this.We), this.Ve.de();
    for (const t of this.ke.values()) t.j();
  }
}
const S = { readShort: (a, t) => (S.t.uint16[0] = a[t] << 8 | a[t + 1], S.t.int16[0]), readUshort: (a, t) => a[t] << 8 | a[t + 1], readUshorts(a, t, e) {
  const r = [];
  for (let i = 0; i < e; i++) r.push(S.readUshort(a, t + 2 * i));
  return r;
}, readUint(a, t) {
  const e = S.t.uint8;
  return e[3] = a[t], e[2] = a[t + 1], e[1] = a[t + 2], e[0] = a[t + 3], S.t.uint32[0];
}, readASCII(a, t, e) {
  let r = "";
  for (let i = 0; i < e; i++) r += String.fromCharCode(a[t + i]);
  return r;
}, t: (() => {
  const a = new ArrayBuffer(8);
  return { uint8: new Uint8Array(a), int16: new Int16Array(a), uint16: new Uint16Array(a), uint32: new Uint32Array(a) };
})() }, yt = { parseTab(a, t, e) {
  const r = { tables: [], ids: {}, off: t };
  a = new Uint8Array(a.buffer, t, e), t = 0;
  const i = S, s = i.readUshort, n = s(a, t += 2);
  t += 2;
  const o = [];
  for (let h = 0; h < n; h++) {
    const l = s(a, t), d = s(a, t += 2);
    t += 2;
    const u = i.readUint(a, t);
    t += 4;
    const f = `p${l}e${d}`;
    let g = o.indexOf(u);
    if (g === -1) {
      let p;
      g = r.tables.length, o.push(u);
      const m = s(a, u);
      p = m === 4 ? this.parse4(a, u) : m === 12 ? this.parse12(a, u) : { format: m }, r.tables.push(p);
    }
    r.ids[f] != null && console.warn("Multiple tables for one platform+encoding: " + f), r.ids[f] = g;
  }
  return r;
}, parse4(a, t) {
  const e = S, r = e.readUshort, i = e.readUshorts, s = t, n = r(a, t += 2);
  t += 2;
  const o = r(a, t += 2) >>> 1, h = { format: 4, searchRange: r(a, t += 2), entrySelector: 0, rangeShift: 0, endCount: [], startCount: [], idDelta: [], idRangeOffset: [], glyphIdArray: [] };
  t += 2, h.entrySelector = r(a, t), t += 2, h.rangeShift = r(a, t), t += 2, h.endCount = i(a, t, o), t += 2 * o, t += 2, h.startCount = i(a, t, o), t += 2 * o;
  for (let l = 0; l < o; l++) h.idDelta.push(e.readShort(a, t)), t += 2;
  return h.idRangeOffset = i(a, t, o), t += 2 * o, h.glyphIdArray = i(a, t, s + n - t >> 1), h;
}, parse12(a, t) {
  const e = S.readUint;
  e(a, t += 4), e(a, t += 4);
  const r = e(a, t += 4);
  t += 4;
  const i = new Uint32Array(3 * r);
  for (let s = 0; s < 3 * r; s += 3) i[s] = e(a, t + (s << 2)), i[s + 1] = e(a, t + (s << 2) + 4), i[s + 2] = e(a, t + (s << 2) + 8);
  return { format: 12, groups: i };
} }, Ct = { parseTab(a, t, e) {
  const r = S;
  t += 18;
  const i = r.readUshort(a, t);
  t += 2, t += 16;
  const s = r.readShort(a, t);
  t += 2;
  const n = r.readShort(a, t);
  t += 2;
  const o = r.readShort(a, t);
  t += 2;
  const h = r.readShort(a, t);
  return t += 2, t += 6, { unitsPerEm: i, xMin: s, yMin: n, xMax: o, yMax: h, indexToLocFormat: r.readShort(a, t) };
} }, vt = { parseTab(a, t, e) {
  const r = S;
  t += 4;
  const i = ["ascender", "descender", "lineGap", "advanceWidthMax", "minLeftSideBearing", "minRightSideBearing", "xMaxExtent", "caretSlopeRise", "caretSlopeRun", "caretOffset", "res0", "res1", "res2", "res3", "metricDataFormat", "numberOfHMetrics"], s = {};
  for (let n = 0; n < i.length; n++) {
    const o = i[n], h = o === "advanceWidthMax" || o === "numberOfHMetrics" ? r.readUshort : r.readShort;
    s[o] = h(a, t + 2 * n);
  }
  return s;
} }, St = { parseTab(a, t, e, r) {
  const i = S, s = [], n = [], o = r.maxp.numGlyphs, h = r.hhea.numberOfHMetrics;
  let l = 0, d = 0, u = 0;
  for (; u < h; ) l = i.readUshort(a, t + (u << 2)), d = i.readShort(a, t + (u << 2) + 2), s.push(l), n.push(d), u++;
  for (; u < o; ) s.push(l), n.push(d), u++;
  return { aWidth: s, lsBearing: n };
} }, X = { cmap: yt, head: Ct, hhea: vt, maxp: { parseTab(a, t, e) {
  const r = S;
  return r.readUint(a, t), t += 4, { numGlyphs: r.readUshort(a, t) };
} }, hmtx: St, loca: { parseTab(a, t, e, r) {
  const i = S, s = [], n = r.head.indexToLocFormat, o = r.maxp.numGlyphs + 1;
  if (n === 0) for (let h = 0; h < o; h++) s.push(i.readUshort(a, t + (h << 1)) << 1);
  else if (n === 1) for (let h = 0; h < o; h++) s.push(i.readUint(a, t + (h << 2)));
  return s;
} }, glyf: { parseTab(a, t, e, r) {
  const i = [], s = r.maxp.numGlyphs;
  for (let n = 0; n < s; n++) i.push(null);
  return i;
}, us(a, t) {
  const e = S, r = a.fs, i = a.loca;
  if (i[t] === i[t + 1]) return null;
  const s = w.findTable(r, "glyf", a.ds);
  if (!s) return null;
  let n = s[0] + i[t];
  const o = {};
  if (o.noc = e.readShort(r, n), n += 2, o.xMin = e.readShort(r, n), n += 2, o.yMin = e.readShort(r, n), n += 2, o.xMax = e.readShort(r, n), n += 2, o.yMax = e.readShort(r, n), n += 2, o.xMin >= o.xMax || o.yMin >= o.yMax) return null;
  if (o.noc > 0) {
    o.endPts = [];
    for (let f = 0; f < o.noc; f++) o.endPts.push(e.readUshort(r, n)), n += 2;
    const h = e.readUshort(r, n);
    if (n += 2, r.length - n < h) return null;
    n += h;
    const l = o.endPts[o.noc - 1] + 1;
    o.flags = [];
    for (let f = 0; f < l; f++) {
      const g = r[n];
      if (n++, o.flags.push(g), 8 & g) {
        const p = r[n];
        n++;
        for (let m = 0; m < p; m++) o.flags.push(g), f++;
      }
    }
    o.xs = [];
    for (let f = 0; f < l; f++) {
      const g = o.flags[f], p = !!(16 & g);
      2 & g ? (o.xs.push(p ? r[n] : -r[n]), n++) : p ? o.xs.push(0) : (o.xs.push(e.readShort(r, n)), n += 2);
    }
    o.ys = [];
    for (let f = 0; f < l; f++) {
      const g = o.flags[f], p = !!(32 & g);
      4 & g ? (o.ys.push(p ? r[n] : -r[n]), n++) : p ? o.ys.push(0) : (o.ys.push(e.readShort(r, n)), n += 2);
    }
    let d = 0, u = 0;
    for (let f = 0; f < l; f++) d += o.xs[f], u += o.ys[f], o.xs[f] = d, o.ys[f] = u;
  } else o.parts = [], o.endPts = [], o.flags = [], o.xs = [], o.ys = [];
  return o;
} } }, w = { parse: (a) => [((t, e, r, i) => {
  const s = X, n = { fs: t, ps: e, ds: r };
  for (const o in s) {
    const h = o, l = w.findTable(t, h, r);
    if (l) {
      const [d, u] = l;
      let f = i[d];
      f == null && (f = s[h].parseTab(t, d, u, n), i[d] = f), n[h] = f;
    }
  }
  return n;
})(new Uint8Array(a), 0, 0, {})], findTable(a, t, e) {
  const r = S, i = r.readUshort(a, e + 4);
  let s = e + 12;
  for (let n = 0; n < i; n++) {
    const o = r.readASCII(a, s, 4);
    r.readUint(a, s + 4);
    const h = r.readUint(a, s + 8), l = r.readUint(a, s + 12);
    if (o === t) return [h, l];
    s += 16;
  }
  return null;
}, T: X, B: S };
class z {
  constructor() {
    c(this, "_s", /* @__PURE__ */ new Map());
    c(this, "gs", /* @__PURE__ */ new Map());
  }
  vs(t, e) {
    const r = `${this.Cs(t)}_${e}`;
    if (this._s.has(r)) return this._s.get(r);
    const i = t.cmap;
    if (!i || !i.tables) return this._s.set(r, 0), 0;
    let s = 0;
    for (const n of i.tables) if (n.format === 4 ? s = this.ws(e, n) : n.format === 12 && (s = this.$s(e, n)), s > 0) break;
    return this._s.set(r, s), s;
  }
  bs(t, e) {
    const r = e.codePointAt(0);
    return r === void 0 ? 0 : this.vs(t, r);
  }
  zs(t, e) {
    const r = t.hmtx;
    return r && r.aWidth && r.aWidth.length !== 0 ? e < r.aWidth.length ? r.aWidth[e] : r.aWidth[r.aWidth.length - 1] : 0;
  }
  Rs(t, e) {
    const r = e / t.head.unitsPerEm, i = t.hhea.ascender * r, s = t.hhea.descender * r, n = t.hhea.lineGap * r;
    return { ascender: i, descender: s, lineGap: n, lineHeight: i - s + n, unitsPerEm: t.head.unitsPerEm, scale: r };
  }
  Ts() {
    this._s.clear(), this.gs.clear();
  }
  Cs(t) {
    return `${t.ds}_${t.fs.length}`;
  }
  ws(t, e) {
    const r = e.endCount.length;
    let i = -1;
    for (let s = 0; s < r; s++) if (t <= e.endCount[s]) {
      i = s;
      break;
    }
    if (i === -1 || t < e.startCount[i]) return 0;
    if (e.idRangeOffset[i] === 0) return t + e.idDelta[i] & 65535;
    {
      const s = e.idRangeOffset[i] / 2 + (t - e.startCount[i]) - (r - i);
      if (s >= 0 && s < e.glyphIdArray.length) {
        const n = e.glyphIdArray[s];
        return n === 0 ? 0 : n + e.idDelta[i] & 65535;
      }
    }
    return 0;
  }
  $s(t, e) {
    const r = e.groups.length / 3;
    for (let i = 0; i < r; i++) {
      const s = e.groups[3 * i], n = e.groups[3 * i + 1], o = e.groups[3 * i + 2];
      if (t >= s && t <= n) return o + (t - s);
    }
    return 0;
  }
}
class Rt {
  constructor(t) {
    c(this, "Ss");
    this.Ss = t;
  }
  Ms(t) {
    var r;
    const e = [];
    return (r = t.cmap) != null && r.tables ? (t.cmap.tables.forEach((i) => {
      if (i.format === 4) {
        const s = this.Fs(i);
        e.push(...s);
      } else if (i.format === 12) {
        const s = this.Gs(i);
        e.push(...s);
      }
    }), [...new Set(e)]) : [];
  }
  Ds(t, e) {
    return this.Ss.bs(t, e) > 0;
  }
  Ps(t, e) {
    for (const r of e) if (!this.Ds(t, r)) return !1;
    return !0;
  }
  As(t, e) {
    return e.filter((r) => this.Ds(t, r));
  }
  Bs(t) {
    return t.filter((e) => this.Is(e));
  }
  Fs(t) {
    const e = [];
    if (!(t.startCount && t.endCount && t.idRangeOffset && t.idDelta)) return e;
    for (let r = 0; r < t.startCount.length; r++) {
      const i = t.startCount[r], s = t.endCount[r];
      if (i !== 65535 || s !== 65535) {
        for (let n = i; n <= s; n++)
          if (this.Ls(t, n, r) > 0) try {
            const o = String.fromCodePoint(n);
            e.push(o);
          } catch {
          }
      }
    }
    return e;
  }
  Gs(t) {
    const e = [];
    if (!t.groups) return e;
    for (let r = 0; r < t.groups.length; r += 3) {
      const i = t.groups[r], s = t.groups[r + 1], n = t.groups[r + 2];
      for (let o = i; o <= s; o++)
        if (n + (o - i) > 0) try {
          const h = String.fromCodePoint(o);
          e.push(h);
        } catch {
        }
    }
    return e;
  }
  Ls(t, e, r) {
    if (t.idRangeOffset[r] === 0) return e + t.idDelta[r] & 65535;
    {
      const i = t.idRangeOffset[r] / 2 + (e - t.startCount[r]) - (t.startCount.length - r);
      if (i >= 0 && t.glyphIdArray && i < t.glyphIdArray.length) {
        const s = t.glyphIdArray[i];
        if (s !== 0) return s + t.idDelta[r] & 65535;
      }
    }
    return 0;
  }
  Is(t) {
    const e = t.codePointAt(0) || 0;
    return !(e >= 0 && e <= 31 && e !== 9 && e !== 10 && e !== 13 || e >= 127 && e <= 159);
  }
}
class Et {
  constructor() {
    c(this, "Es");
    const t = new z();
    this.Es = new Rt(t);
  }
  extractCharacters(t) {
    return this.Es.Ms(t);
  }
  filterProblematicCharacters(t) {
    return this.Es.Bs(t);
  }
  characterExists(t, e) {
    return this.Es.Ds(t, e);
  }
  allCharactersExist(t, e) {
    return this.Es.Ps(t, e);
  }
}
class _t {
  constructor(t) {
    c(this, "Ws");
    c(this, "ks");
    c(this, "Us");
    c(this, "Vs");
    this.Us = t, this.Vs = new z(), this.Ws = document.createElement("canvas"), this.ks = this.Ws.getContext("2d", { willReadFrequently: !0, alpha: !1 });
  }
  createTextureAtlas(t, e, r, i) {
    const s = t.length, n = Math.ceil(Math.sqrt(s)), o = Math.ceil(s / n), h = e.width * n, l = e.height * o, d = typeof i == "object" ? i : null;
    this.Os(h, l), this.js(t, e, n, r, d);
    const u = this.Us.rs(h, l, 1, { filter: "nearest" });
    return u.L(this.Ws), { framebuffer: u, columns: n, rows: o };
  }
  Os(t, e) {
    this.Ws.width = t, this.Ws.height = e, this.Ws.style.width = t + "px", this.Ws.style.height = t + "px", this.ks.imageSmoothingEnabled = !1, this.Ws.style.imageRendering = "pixelated", this.ks.fillStyle = "black", this.ks.fillRect(0, 0, t, e), this.ks.textBaseline = "top", this.ks.textAlign = "left", this.ks.fillStyle = "white";
  }
  js(t, e, r, i, s) {
    const n = i / s.head.unitsPerEm;
    for (let o = 0; o < t.length; o++) {
      const h = o % r, l = Math.floor(o / r), d = t[o].character, u = this.Hs(s, d);
      if (!u) continue;
      const f = d.codePointAt(0) || 0, g = this.Vs.vs(s, f), p = this.Xs(s, g) * n, m = h * e.width, R = l * e.height, v = m + 0.5 * e.width, E = R + 0.5 * e.height, b = Math.round(v - 0.5 * e.width), y = Math.round(E - 0.5 * i), P = b + 0.5 * (e.width - p), Z = y + s.hhea.ascender * n;
      this.Ys(u, P, Z, n);
    }
  }
  Hs(t, e) {
    const r = e.codePointAt(0) || 0, i = this.Vs.vs(t, r);
    if (i === 0) return null;
    if (t.glyf && t.glyf[i] !== null) return t.glyf[i];
    if (w && w.T && w.T.glyf) {
      const s = w.T.glyf.us(t, i);
      return t.glyf && s && (t.glyf[i] = s), s;
    }
    return null;
  }
  Xs(t, e) {
    const r = t.hmtx;
    return r && r.aWidth ? e < r.aWidth.length ? r.aWidth[e] : r.aWidth[r.aWidth.length - 1] : 0;
  }
  Ys(t, e, r, i) {
    if (!t || !t.xs || t.noc === 0) return;
    const { xs: s, ys: n, endPts: o, flags: h } = t;
    if (!(s && n && o && h)) return;
    this.ks.beginPath();
    let l = 0;
    for (let d = 0; d < o.length; d++) {
      const u = o[d];
      if (!(u < l)) {
        if (u >= l) {
          const f = e + s[l] * i, g = r - n[l] * i;
          this.ks.moveTo(f, g);
          let p = l + 1;
          for (; p <= u; )
            if (1 & h[p]) {
              const m = e + s[p] * i, R = r - n[p] * i;
              this.ks.lineTo(m, R), p++;
            } else {
              const m = e + s[p] * i, R = r - n[p] * i;
              let v = p + 1 > u ? l : p + 1;
              if (1 & h[v]) {
                const E = e + s[v] * i, b = r - n[v] * i;
                this.ks.quadraticCurveTo(m, R, E, b), p = v + 1;
              } else {
                const E = (m + (e + s[v] * i)) / 2, b = (R + (r - n[v] * i)) / 2;
                this.ks.quadraticCurveTo(m, R, E, b), p = v;
              }
            }
          this.ks.closePath();
        }
        l = u + 1;
      }
    }
    this.ks.fill();
  }
}
class bt {
  constructor() {
    c(this, "Ss");
    this.Ss = new z();
  }
  calculateMaxGlyphDimensions(t, e, r) {
    let i = 0;
    const s = this.Ss.Rs(r, e), n = s.lineHeight;
    for (const o of t) {
      const h = this.Ss.bs(r, o);
      if (h === 0) continue;
      const l = this.Ss.zs(r, h) * s.scale;
      i = Math.max(i, l);
    }
    return { width: Math.ceil(i), height: Math.ceil(n) };
  }
  getCharacterAdvanceWidth(t, e, r) {
    const i = this.Ss.Rs(r, e), s = this.Ss.bs(r, t);
    return this.Ss.zs(r, s) * i.scale;
  }
  getFontMetrics(t, e) {
    return this.Ss.Rs(e, t);
  }
  Ts() {
    this.Ss.Ts();
  }
}
class wt {
  constructor() {
    c(this, "Vs");
    this.Vs = new z();
  }
  createCharacterObjects(t, e) {
    return t.map((r, i) => {
      const s = r.codePointAt(0) || 0, n = this.qs(i);
      let o = 0;
      if (e.hmtx && e.hmtx.aWidth) {
        const h = this.Vs.vs(e, s);
        h > 0 && e.hmtx.aWidth[h] !== void 0 && (o = e.hmtx.aWidth[h]);
      }
      return { character: r, unicode: s, color: n, advanceWidth: o };
    });
  }
  qs(t) {
    return [t % 256 / 255, Math.floor(t / 256) % 256 / 255, Math.floor(t / 65536) % 256 / 255];
  }
  Zs(t, e) {
    if (!I.m(typeof t == "string", "Character must be a string.", { method: "getCharacterColor", providedValue: t })) return [0, 0, 0];
    const r = e.find((i) => i.character === t);
    return r ? r.color : [0, 0, 0];
  }
  Ns(t, e) {
    return I.m(typeof t == "string" && t.length > 0, "Characters must be a string with at least one character.", { method: "getCharacterColors", providedValue: t }) ? Array.from(t).map((r) => this.Zs(r, e) || [0, 0, 0]) : [[0, 0, 0]];
  }
}
class Tt {
  constructor(t, e = 16) {
    c(this, "Qs");
    c(this, "Js", []);
    c(this, "Ks");
    c(this, "ti", 16);
    c(this, "ei", 0);
    c(this, "si", 0);
    c(this, "ii", { width: 0, height: 0 });
    c(this, "ri");
    c(this, "ni");
    c(this, "oi");
    c(this, "ai");
    c(this, "hi");
    this.ti = e, this.ni = new Et(), this.oi = new _t(t), this.ai = new bt(), this.hi = new wt();
  }
  async ci(t) {
    let e;
    if (!t) throw new _("Embedded font not available. This appears to be a minified build - please provide `fontSource`.");
    {
      const r = await fetch(t);
      if (!r.ok) throw new _(`Failed to load font file: ${r.status} ${r.statusText}`);
      e = await r.arrayBuffer();
    }
    await this.li(e), this.Qs = w.parse(e)[0], await this.ui();
  }
  fi(t) {
    if (t === void 0) return this.ti;
    this.ti = t, this.ii = this.ai.calculateMaxGlyphDimensions(this.Js.map((r) => r.character), this.ti, this.Qs);
    const e = this.oi.createTextureAtlas(this.Js, this.ii, this.ti, this.Qs);
    this.Ks = e.framebuffer, this.ei = e.columns, this.si = e.rows;
  }
  async di(t) {
    try {
      const e = await fetch(t);
      if (!e.ok) throw new _(`Failed to load font file: ${e.status} ${e.statusText}`);
      const r = await e.arrayBuffer();
      await this.li(r);
      const i = w.parse(r);
      if (!i || i.length === 0) throw Error("Failed to parse font file");
      this.Qs = i[0], await this.ui();
    } catch (e) {
      throw new _("Failed to load font: " + (e instanceof Error ? e.message : "Unknown error"), e);
    }
  }
  async li(t) {
    const e = Date.now();
    this.ri = new FontFace("CustomFont_" + e, t), await this.ri.load(), document.fonts.add(this.ri);
  }
  async ui() {
    const t = this.ni.extractCharacters(this.Qs), e = this.ni.filterProblematicCharacters(t);
    this.Js = this.hi.createCharacterObjects(e, this.Qs), this.ii = this.ai.calculateMaxGlyphDimensions(e, this.ti, this.Qs);
    const r = this.oi.createTextureAtlas(this.Js, this.ii, this.ti, this.Qs);
    this.Ks = r.framebuffer, this.ei = r.columns, this.si = r.rows;
  }
  Zs(t) {
    return this.hi.Zs(t, this.Js);
  }
  Ns(t) {
    return this.hi.Ns(t, this.Js);
  }
  j() {
    this.Ks.j(), document.fonts.delete(this.ri);
  }
  get fontFramebuffer() {
    return this.Ks;
  }
  get characters() {
    return this.Js;
  }
  get textureColumns() {
    return this.ei;
  }
  get textureRows() {
    return this.si;
  }
  get maxGlyphDimensions() {
    return this.ii;
  }
  get fontSize() {
    return this.ti;
  }
  get font() {
    return this.Qs;
  }
}
class At {
  constructor(t, e, r) {
    c(this, "pi");
    c(this, "_i");
    c(this, "C");
    c(this, "$");
    c(this, "gi");
    c(this, "mi");
    c(this, "xi");
    c(this, "Ci");
    c(this, "yi");
    this.xi = t, this.Ci = e, this.yi = r, this.zt();
  }
  zt() {
    this.pi = Math.floor(this.xi.width / this.Ci), this._i = Math.floor(this.xi.height / this.yi), this.C = this.pi * this.Ci, this.$ = this._i * this.yi, this.gi = Math.floor((this.xi.width - this.C) / 2), this.mi = Math.floor((this.xi.height - this.$) / 2);
  }
  wi(t, e) {
    this.Ci = t, this.yi = e, this.zt();
  }
  get cellWidth() {
    return this.Ci;
  }
  get cellHeight() {
    return this.yi;
  }
  get cols() {
    return this.pi;
  }
  get rows() {
    return this._i;
  }
  get width() {
    return this.C;
  }
  get height() {
    return this.$;
  }
  get offsetX() {
    return this.gi;
  }
  get offsetY() {
    return this.mi;
  }
}
class Ft {
  constructor(t = {}) {
    c(this, "xi");
    c(this, "$i");
    c(this, "bi");
    t.canvas ? (this.xi = t.canvas, this.bi = !1) : (this.xi = this.zi(t.width, t.height), this.bi = !0), this.xi.style.imageRendering = "pixelated";
  }
  zi(t, e) {
    const r = document.createElement("canvas");
    return r.className = "textmodeCanvas", r.style.imageRendering = "pixelated", r.width = t || 800, r.height = e || 600, document.body.appendChild(r), r;
  }
  W(t, e) {
    this.xi.width = t ?? this.xi.width, this.xi.height = e ?? this.xi.height;
  }
  Ri() {
    const t = this.xi.getContext("webgl2", { alpha: !0, premultipliedAlpha: !1, preserveDrawingBuffer: !0, antialias: !1, depth: !1, stencil: !1, powerPreference: "high-performance" });
    if (!t) throw new _("`textmode.js` requires WebGL2 support.");
    return t;
  }
  j() {
    this.$i && this.$i.disconnect();
    const t = this.xi.getContext("webgl") || this.xi.getContext("webgl2");
    if (t) {
      const e = t.getExtension("WEBGL_lose_context");
      e && e.loseContext();
    }
    this.bi && this.xi.parentNode && this.xi.parentNode.removeChild(this.xi);
  }
  get canvas() {
    return this.xi;
  }
  get width() {
    return this.xi.width;
  }
  get height() {
    return this.xi.height;
  }
}
class Ut {
  constructor(t = 60) {
    c(this, "Ti");
    c(this, "Si");
    c(this, "Mi", null);
    c(this, "Fi", 0);
    c(this, "Gi", !0);
    c(this, "Di", 0);
    c(this, "Pi", 0);
    c(this, "Ai", []);
    c(this, "Bi", 10);
    c(this, "Ii", 0);
    this.Ti = t, this.Si = 1e3 / t;
  }
  start(t) {
    if (!this.Gi) return;
    this.Fi = performance.now();
    const e = (r) => {
      if (!this.Gi) return void (this.Mi = null);
      const i = r - this.Fi;
      i >= this.Si && (t(), this.Fi = r - i % this.Si), this.Gi && (this.Mi = requestAnimationFrame(e));
    };
    this.Mi = requestAnimationFrame(e);
  }
  stop() {
    this.Mi && (cancelAnimationFrame(this.Mi), this.Mi = null);
  }
  pause() {
    this.Gi && (this.Gi = !1, this.stop());
  }
  resume(t) {
    this.Gi || (this.Gi = !0, this.start(t));
  }
  frameRate(t, e) {
    if (t === void 0) return this.Di;
    this.Ti = t, this.Si = 1e3 / t, this.Gi && e && (this.stop(), this.start(e));
  }
  measureFrameRate() {
    const t = performance.now();
    if (this.Pi > 0) {
      const e = t - this.Pi;
      this.Ai.push(e), this.Ai.length > this.Bi && this.Ai.shift();
      const r = this.Ai.reduce((i, s) => i + s, 0) / this.Ai.length;
      this.Di = 1e3 / r;
    }
    this.Pi = t;
  }
  get isLooping() {
    return this.Gi;
  }
  get frameRateLimit() {
    return this.Ti;
  }
  get currentFrameRate() {
    return this.Di;
  }
  get frameCount() {
    return this.Ii;
  }
  set frameCount(t) {
    this.Ii = t;
  }
  incrementFrame() {
    this.Ii++;
  }
  resetFrameCount() {
    this.Ii = 0;
  }
}
const Lt = (a) => class extends a {
  rotate(t = 0, e = 0, r = 0) {
    this.Us.state.St(t), this.Us.state.Mt(e), this.Us.state.Ft(r);
  }
  rotateX(t) {
    this.Us.state.St(t);
  }
  rotateY(t) {
    this.Us.state.Mt(t);
  }
  rotateZ(t) {
    this.Us.state.Ft(t);
  }
  push() {
    this.Us.state.$t();
  }
  pop() {
    this.Us.state.bt();
  }
  rect(t, e, r = 1, i = 1) {
    this.Us.Je(t, e, r, i);
  }
  line(t, e, r, i) {
    this.Us.Ke(t, e, r, i);
  }
  lineWeight(t) {
    this.Us.state.Tt(t);
  }
  background(t, e = t, r = t, i = 255) {
    this.Us.hs(t, e, r, i);
  }
  char(t) {
    this.Us.state.Gt(this.Qs.Zs(t));
  }
  charColor(t, e, r) {
    this.Us.state.Dt(t, e, r);
  }
  cellColor(t, e, r) {
    this.Us.state.Pt(t, e, r);
  }
  flipX(t) {
    this.Us.state.At(t);
  }
  flipY(t) {
    this.Us.state.Bt(t);
  }
  charRotation(t) {
    this.Us.state.Lt(t);
  }
  invert(t) {
    this.Us.state.It(t);
  }
  clear() {
    this.Us.hs(0, 0, 0, 0);
  }
  ellipse(t, e, r, i) {
    this.Us.ts(t, e, r / 2, i / 2);
  }
  triangle(t, e, r, i, s, n) {
    this.Us.es(t, e, r, i, s, n);
  }
  bezierCurve(t, e, r, i, s, n, o, h) {
    this.Us.ss(t, e, r, i, s, n, o, h);
  }
  arc(t, e, r, i, s, n) {
    this.Us.ns(t, e, r, i, s, n);
  }
  shader(t) {
    this.Us.Ye(t);
  }
  setUniform(t, e) {
    this.Us.qe(t, e);
  }
  setUniforms(t) {
    this.Us.Ze(t);
  }
  createFilterShader(t) {
    return this.Us.Ne(t);
  }
};
class W {
  Li(t) {
    const e = t.k(0), r = t.k(1), i = t.k(2), s = t.k(3);
    return { characterPixels: e, primaryColorPixels: r, secondaryColorPixels: i, transformPixels: t.k(4), rotationPixels: s };
  }
  Ei(t, e) {
    return t[e] + (t[e + 1] << 8);
  }
  Wi(t, e) {
    return { r: t[e], g: t[e + 1], b: t[e + 2], a: t[e + 3] };
  }
}
class k {
  ki(t, e) {
    return new Blob([t], { type: e });
  }
  Ui(t, e, r) {
    try {
      const i = this.ki(t, r), s = URL.createObjectURL(i), n = document.createElement("a");
      n.href = s, n.download = e, n.style.display = "none", n.rel = "noopener", document.body.appendChild(n), n.click(), document.body.removeChild(n), URL.revokeObjectURL(s);
    } catch (i) {
      throw console.error("Failed to download file:", i), Error("File download failed: " + (i instanceof Error ? i.message : "Unknown error"));
    }
  }
  Vi() {
    return (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace(/:/g, "-");
  }
  Oi() {
    const t = /* @__PURE__ */ new Date();
    return { date: t.toISOString().split("T")[0], time: t.toTimeString().split(" ")[0].replace(/:/g, "-") };
  }
  ji(t) {
    return t.replace(/[<>:"/\\|?*]/g, "_").replace(/\s+/g, "_").replace(/_{2,}/g, "_").replace(/^_+|_+$/g, "").substring(0, 255);
  }
  Hi() {
    return "textmode-export-" + this.Vi();
  }
}
class Pt extends W {
  Xi(t, e, r) {
    const i = t[r] === 255, s = t[r + 1] === 255, n = t[r + 2] === 255, o = e[r], h = e[r + 1];
    return { isInverted: i, flipHorizontal: s, flipVertical: n, rotation: Math.round(360 * (o + h / 255) / 255 * 100) / 100 };
  }
  Yi(t, e, r) {
    return { x: t, y: e, cellX: t * r.cellWidth, cellY: e * r.cellHeight };
  }
  qi(t, e) {
    const r = [];
    let i = 0;
    for (let s = 0; s < e.rows; s++) for (let n = 0; n < e.cols; n++) {
      const o = 4 * i, h = this.Ei(t.characterPixels, o);
      let l = this.Wi(t.primaryColorPixels, o), d = this.Wi(t.secondaryColorPixels, o);
      const u = this.Xi(t.transformPixels, t.rotationPixels, o);
      if (u.isInverted) {
        const g = l;
        l = d, d = g;
      }
      const f = this.Yi(n, s, e);
      r.push({ charIndex: h, primaryColor: l, secondaryColor: d, transform: u, position: f }), i++;
    }
    return r;
  }
}
class It {
  Zi(t, e) {
    const r = t.cmap;
    for (const i of r.tables) if (i.format === 4) {
      const s = i;
      for (let n = 0; n < s.startCount.length; n++) if (e >= s.startCount[n] && e <= s.endCount[n]) {
        if (s.idRangeOffset[n] === 0) return e + s.idDelta[n] & 65535;
        {
          const o = s.idRangeOffset[n] / 2 + (e - s.startCount[n]) - (s.startCount.length - n);
          if (o >= 0 && o < s.glyphIdArray.length) {
            const h = s.glyphIdArray[o];
            if (h !== 0) return h + s.idDelta[n] & 65535;
          }
        }
      }
    } else if (i.format === 12) {
      const s = i;
      for (let n = 0; n < s.groups.length; n += 3) {
        const o = s.groups[n], h = s.groups[n + 1], l = s.groups[n + 2];
        if (e >= o && e <= h) return l + (e - o);
      }
    }
    return 0;
  }
  Ni(t, e, r, i, s) {
    const n = s / t.head.unitsPerEm;
    return { getBoundingBox: () => ({ x1: r + e.xMin * n, y1: i + -e.yMax * n, x2: r + e.xMax * n, y2: i + -e.yMin * n }), toSVG: () => this.Qi(e, r, i, n) };
  }
  Qi(t, e, r, i) {
    if (!t || !t.xs) return "";
    const { xs: s, ys: n, endPts: o, flags: h } = t;
    if (!(s && n && o && h)) return "";
    let l = "", d = 0;
    for (let u = 0; u < o.length; u++) {
      const f = o[u];
      if (!(f < d)) {
        if (f >= d) {
          const g = e + s[d] * i, p = r - n[d] * i;
          l += `M${g.toFixed(2)},${p.toFixed(2)}`;
          let m = d + 1;
          for (; m <= f; )
            if (1 & h[m]) {
              const R = e + s[m] * i, v = r - n[m] * i;
              l += `L${R.toFixed(2)},${v.toFixed(2)}`, m++;
            } else {
              const R = e + s[m] * i, v = r - n[m] * i;
              let E = m + 1 > f ? d : m + 1;
              if (1 & h[E]) {
                const b = e + s[E] * i, y = r - n[E] * i;
                l += `Q${R.toFixed(2)},${v.toFixed(2)} ${b.toFixed(2)},${y.toFixed(2)}`, m = E + 1;
              } else {
                const b = (R + (e + s[E] * i)) / 2, y = (v + (r - n[E] * i)) / 2;
                l += `Q${R.toFixed(2)},${v.toFixed(2)} ${b.toFixed(2)},${y.toFixed(2)}`, m = E;
              }
            }
          l += "Z";
        }
        d = f + 1;
      }
    }
    return l;
  }
  Ji(t, e, r, i, s) {
    const n = t.codePointAt(0) || 0, o = this.Zi(e, n);
    let h = null;
    return e.glyf && e.glyf[o] !== null ? h = e.glyf[o] : (h = w.T.glyf.us(e, o), e.glyf[o] = h), this.Ni(e, h, r, i, s);
  }
  Ki(t, e, r, i, s, n, o, h) {
    const l = r + (s - h * (o / e.head.unitsPerEm)) / 2, d = i + (n + 0.7 * o) / 2;
    return this.Ji(t, e, l, d, o).toSVG() || null;
  }
}
class Dt {
  constructor() {
    c(this, "tr");
    this.tr = new It();
  }
  er(t) {
    return `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="${t.width}" height="${t.height}" viewBox="0 0 ${t.width} ${t.height}" 
     xmlns="http://www.w3.org/2000/svg" version="1.1">
<title>textmode art generated via textmode.js</title>
<desc>textmode art visualization generated by textmode.js library</desc>`;
  }
  sr() {
    return `
</g>
</svg>`;
  }
  ir(t, e) {
    if (!e.includeBackgroundRectangles) return "";
    const r = e.backgroundColor, i = `rgba(${r[0]},${r[1]},${r[2]},${r[3] / 255})`;
    return `
<rect width="${t.width}" height="${t.height}" fill="${i}" />`;
  }
  rr(t) {
    return `rgba(${t.r},${t.g},${t.b},${t.a / 255})`;
  }
  nr(t, e) {
    const { transform: r, position: i } = t, s = i.cellX + e.cellWidth / 2, n = i.cellY + e.cellHeight / 2, o = [];
    if (r.flipHorizontal || r.flipVertical) {
      const h = r.flipHorizontal ? -1 : 1, l = r.flipVertical ? -1 : 1;
      o.push(`translate(${s} ${n})`), o.push(`scale(${h} ${l})`), o.push(`translate(${-s} ${-n})`);
    }
    return r.rotation && o.push(`rotate(${r.rotation} ${s} ${n})`), o.length ? ` transform="${o.join(" ")}"` : "";
  }
  ar(t, e, r) {
    if (!r.includeBackgroundRectangles || t.secondaryColor.a === 0) return "";
    const { position: i } = t, s = this.rr(t.secondaryColor);
    return r.drawMode === "stroke" ? `
  <rect x="${i.cellX}" y="${i.cellY}" width="${e.cellWidth}" height="${e.cellHeight}" stroke="${s}" fill="none" stroke-width="${r.strokeWidth}" />` : `
  <rect x="${i.cellX}" y="${i.cellY}" width="${e.cellWidth}" height="${e.cellHeight}" fill="${s}" />`;
  }
  Ji(t, e, r, i) {
    const s = r.characters[t.charIndex];
    if (!s) return "";
    const n = this.tr.Ki(s.character, r.font, t.position.cellX, t.position.cellY, e.cellWidth, e.cellHeight, r.fontSize, s.advanceWidth);
    if (!n) return "";
    const o = this.rr(t.primaryColor);
    return i.drawMode === "stroke" ? `
    <path id="${`path-${t.charIndex}-${t.position.cellX}-${t.position.cellY}`.replace(/\./g, "-")}" d="${n}" stroke="${o}" stroke-width="${i.strokeWidth}" fill="none" />` : `
    <path d="${n}" fill="${o}" />`;
  }
  hr(t, e, r, i) {
    let s = "";
    s += this.ar(t, e, i);
    const n = this.nr(t, e), o = this.Ji(t, e, r, i);
    return o && (n ? (s += `
  <g${n}>`, s += o, s += `
  </g>`) : s += o), s;
  }
  cr(t, e, r, i) {
    let s = this.er(e);
    s += this.ir(e, i), s += `
<g id="ascii-cells">`;
    for (const n of t) s += this.hr(n, e, r, i);
    return s += this.sr(), s;
  }
  lr(t) {
    return t.replace(/<path[^>]*d=""[^>]*\/>/g, "").replace(/\n\s*\n/g, `
`).replace(/[ \t]+$/gm, "");
  }
}
class Mt extends k {
  ur(t) {
    return this.ki(t, "image/svg+xml;charset=utf-8");
  }
  dr(t, e) {
    this.Ui(t, this.ji(e) + ".svg", "image/svg+xml;charset=utf-8");
  }
  pr(t, e) {
    this.dr(t, e || this.Hi());
  }
}
class j {
  constructor() {
    c(this, "_r");
    c(this, "gr");
    c(this, "mr");
    this._r = new Pt(), this.gr = new Dt(), this.mr = new Mt();
  }
  vr(t) {
    return { includeBackgroundRectangles: t.includeBackgroundRectangles ?? !0, drawMode: t.drawMode ?? "fill", strokeWidth: t.strokeWidth ?? 1, backgroundColor: t.backgroundColor ?? [0, 0, 0, 0], filename: t.filename || this.mr.Hi() };
  }
  Cr(t, e = {}) {
    const r = this._r.qi(this._r.Li(t.pipeline), t.grid), i = this.gr.cr(r, t.grid, t.font, this.vr(e));
    return this.gr.lr(i);
  }
  pr(t, e = {}) {
    this.mr.pr(this.Cr(t, e), e.filename);
  }
}
class zt extends W {
  yr(t, e, r, i = " ") {
    var o;
    const s = [];
    let n = 0;
    for (let h = 0; h < e.rows; h++) {
      const l = [];
      for (let d = 0; d < e.cols; d++) {
        const u = 4 * n, f = this.Ei(t.characterPixels, u), g = ((o = r.characters[f]) == null ? void 0 : o.character) || i;
        l.push(g), n++;
      }
      s.push(l);
    }
    return s;
  }
}
class Bt {
  wr(t, e) {
    const r = [];
    for (const s of t) {
      let n = s.join("");
      e.preserveTrailingSpaces || (n = n.replace(/\s+$/, "")), r.push(n);
    }
    const i = e.lineEnding === "crlf" ? `\r
` : `
`;
    return r.join(i);
  }
}
class Gt extends k {
  $r(t, e) {
    const r = this.br(e);
    this.Ui(t, r, "text/plain;charset=utf-8");
  }
  br(t) {
    let e = this.ji(t);
    return e === ".txt" || e.length <= 4 ? this.Hi() : e;
  }
}
class Y {
  constructor() {
    c(this, "_r");
    c(this, "gr");
    c(this, "mr");
    this._r = new zt(), this.gr = new Bt(), this.mr = new Gt();
  }
  vr(t) {
    return { preserveTrailingSpaces: t.preserveTrailingSpaces ?? !1, lineEnding: t.lineEnding ?? "lf", emptyCharacter: t.emptyCharacter ?? " ", filename: t.filename || this.mr.Hi() };
  }
  zr(t, e = {}) {
    const r = this.vr(e), i = this._r.yr(this._r.Li(t.pipeline), t.grid, t.font, r.emptyCharacter);
    return this.gr.wr(i, r);
  }
  $r(t, e = {}) {
    this.mr.$r(this.zr(t, e), e.filename);
  }
}
class $t extends W {
  Rr(t, e = 1, r = "transparent") {
    const i = t.canvas;
    if (e === 1 && r === "transparent") return i;
    const s = document.createElement("canvas"), n = s.getContext("2d"), o = Math.round(i.width * e), h = Math.round(i.height * e);
    return s.width = o, s.height = h, r !== "transparent" && (n.fillStyle = r, n.fillRect(0, 0, o, h)), n.imageSmoothingEnabled = !1, n.drawImage(i, 0, 0, i.width, i.height, 0, 0, o, h), s;
  }
}
class Ot {
  Tr(t, e) {
    const r = this.Sr(e.format);
    return e.format === "png" ? t.toDataURL(r) : t.toDataURL(r, e.quality);
  }
  async Mr(t, e) {
    return new Promise((r, i) => {
      const s = this.Sr(e.format), n = (o) => {
        o ? r(o) : i(Error(`Failed to generate ${e.format.toUpperCase()} blob`));
      };
      e.format === "png" ? t.toBlob(n, s) : t.toBlob(n, s, e.quality);
    });
  }
  Sr(t) {
    switch (t) {
      case "png":
        return "image/png";
      case "jpg":
        return "image/jpeg";
      case "webp":
        return "image/webp";
      default:
        throw Error("Unsupported image format: " + t);
    }
  }
}
const Wt = { png: "image/png", jpg: "image/jpeg", webp: "image/webp" }, H = { png: ".png", jpg: ".jpg", webp: ".webp" };
class kt extends k {
  Fr(t, e, r) {
    this.Gr(t, this.ji(e) + H[r]);
  }
  Gr(t, e) {
    const r = URL.createObjectURL(t);
    try {
      const i = document.createElement("a");
      i.href = r, i.download = e, i.style.display = "none", i.rel = "noopener", document.body.appendChild(i), i.click(), document.body.removeChild(i);
    } finally {
      URL.revokeObjectURL(r);
    }
  }
  Dr(t) {
    return t in Wt && t in H;
  }
}
class Nt {
  constructor() {
    c(this, "_r");
    c(this, "gr");
    c(this, "mr");
    this._r = new $t(), this.gr = new Ot(), this.mr = new kt();
  }
  vr(t) {
    return { format: t.format ?? "png", quality: t.quality ?? 1, scale: t.scale ?? 1, backgroundColor: t.backgroundColor ?? "transparent", filename: t.filename || this.mr.Hi() };
  }
  Pr(t) {
    if (!this.mr.Dr(t.format)) throw Error(`Saving '${t.format}' files is not supported`);
    if (t.quality < 0 || t.quality > 1) throw Error("Image quality must be between 0.0 and 1.0");
    if (t.scale <= 0) throw Error("Scale factor must be greater than 0");
    t.format === "jpg" && t.backgroundColor === "transparent" && (t.backgroundColor = "black");
  }
  async Mr(t, e) {
    if (e.scale === 1 && e.backgroundColor === "transparent") return await this.gr.Mr(t.canvas, e);
    const r = this._r.Rr(t, e.scale, e.backgroundColor);
    return await this.gr.Mr(r, e);
  }
  async Fr(t, e = {}) {
    const r = this.vr(e);
    this.Pr(r);
    const i = await this.Mr(t, r);
    this.mr.Fr(i, r.filename, r.format);
  }
}
const Vt = (a) => class extends a {
  Ar() {
    this.Us.ls(this.Br);
  }
  toString(t = {}) {
    return this.Ar(), new Y().zr({ pipeline: this.Ir, grid: this.Lr, font: this.Qs }, t);
  }
  saveStrings(t = {}) {
    this.Ar(), new Y().$r({ pipeline: this.Ir, grid: this.Lr, font: this.Qs }, t);
  }
  toSVG(t = {}) {
    return this.Ar(), new j().Cr({ pipeline: this.Ir, grid: this.Lr, font: this.Qs }, t);
  }
  saveSVG(t = {}) {
    this.Ar(), new j().pr({ pipeline: this.Ir, grid: this.Lr, font: this.Qs }, t);
  }
  async saveCanvas(t = {}) {
    await new Nt().Fr(this.xi, t);
  }
}, Xt = (a) => class extends a {
  async loadFont(t) {
    return this.Qs.di(t).then(() => {
      const e = this.Qs.maxGlyphDimensions;
      this.Lr.wi(e.width, e.height), this.Ir.W(this.Lr.cols, this.Lr.rows), this.Us.cs();
    });
  }
  fontSize(t) {
    if (!I.m(typeof t == "number" && t > 0, "Font size must be a positive number greater than 0.", { method: "fontSize", providedValue: t }) || this.Qs.fontSize === t) return;
    this.Qs.fi(t);
    const e = this.Qs.maxGlyphDimensions;
    this.Lr.wi(e.width, e.height), this.Ir.W(this.Lr.cols, this.Lr.rows), this.Us.cs();
  }
}, jt = (a) => class extends a {
  get frameCount() {
    return this.Er.frameCount;
  }
  set frameCount(t) {
    this.Er.frameCount = t;
  }
  frameRate(t) {
    return t === void 0 ? this.Er.currentFrameRate : this.Er.frameRate(t, () => this.Wr());
  }
  noLoop() {
    this.Er.pause();
  }
  loop() {
    this.Er.resume(() => this.Wr());
  }
  redraw(t = 1) {
    if (I.m(typeof t == "number" && t > 0 && Number.isInteger(t), "Redraw count must be a positive integer.", { method: "redraw", providedValue: t })) for (let e = 0; e < t; e++) this.Wr();
  }
  isLooping() {
    return this.Er.isLooping;
  }
};
class Yt {
  constructor() {
    c(this, "Us");
    c(this, "Qs");
    c(this, "xi");
    c(this, "Lr");
    c(this, "Er");
    c(this, "Br");
    c(this, "Ir");
    c(this, "kr");
  }
  Wr() {
  }
}
class Ht extends function(e, ...r) {
  return r.reduce((i, s) => s(i), e);
}(Yt, Lt, Vt, Xt, jt) {
  constructor(e = {}) {
    super();
    c(this, "Ur", !1);
    c(this, "Vr", () => {
    });
    c(this, "Or", () => {
    });
    c(this, "jr", () => {
    });
    c(this, "Hr");
    this.xi = new Ft(e), this.Us = new xt(this.xi.Ri()), this.Qs = new Tt(this.Us, e.fontSize ?? 16), this.Er = new Ut(e.frameRate ?? 60), this.Br = this.Us.Xe(O, `#version 300 es
precision highp float;in vec2 v_uv;in vec3 v_character;in vec4 v_primaryColor;in vec4 v_secondaryColor;in vec2 v_rotation;in vec3 v_transform;layout(location=0)out vec4 o_character;layout(location=1)out vec4 o_primaryColor;layout(location=2)out vec4 o_secondaryColor;layout(location=3)out vec4 o_rotation;layout(location=4)out vec4 o_transform;void main(){o_character=vec4(v_character,1.0);o_primaryColor=v_primaryColor;o_secondaryColor=v_secondaryColor;o_rotation=vec4(v_rotation,0.0,1.0);o_transform=vec4(v_transform,1.0);}`), this.kr = this.Us.Xe("attribute vec2 a_position;attribute vec2 a_texCoord;varying vec2 v_uv;void main(){v_uv=a_texCoord;gl_Position=vec4(a_position,0.0,1.0);}", "precision mediump float;uniform sampler2D u_characterTexture;uniform vec2 u_charsetDimensions;uniform sampler2D u_primaryColorTexture;uniform sampler2D u_secondaryColorTexture;uniform sampler2D u_transformTexture;uniform sampler2D u_asciiCharacterTexture;uniform sampler2D u_rotationTexture;uniform vec2 u_gridCellDimensions;uniform vec2 u_gridPixelDimensions;uniform vec2 u_gridOffsetPixels;mat2 rotate2D(float angle){float s=sin(angle);float c=cos(angle);return mat2(c,-s,s,c);}void main(){vec2 adjustedCoord=(gl_FragCoord.xy-u_gridOffsetPixels)/u_gridPixelDimensions;vec2 gridCoord=adjustedCoord*u_gridCellDimensions;vec2 cellCoord=floor(gridCoord);vec2 charIndexTexCoord=(cellCoord+0.5)/u_gridCellDimensions;vec4 primaryColor=texture2D(u_primaryColorTexture,charIndexTexCoord);vec4 secondaryColor=texture2D(u_secondaryColorTexture,charIndexTexCoord);vec4 transformColor=texture2D(u_transformTexture,charIndexTexCoord);bool isInverted=transformColor.r>0.5;bool flipHorizontal=transformColor.g>0.5;bool flipVertical=transformColor.b>0.5;vec4 encodedIndexVec=texture2D(u_asciiCharacterTexture,charIndexTexCoord);int charIndex=int(encodedIndexVec.r*255.0+0.5)+int(encodedIndexVec.g*255.0+0.5)*256;int charCol=int(mod(float(charIndex),u_charsetDimensions.x));int charRow=charIndex/int(u_charsetDimensions.x);float flippedRow=(u_charsetDimensions.y-1.0)-float(charRow);vec2 charCoord=vec2(float(charCol),flippedRow)/u_charsetDimensions;vec4 rotationColor=texture2D(u_rotationTexture,charIndexTexCoord);float scaledAngle=rotationColor.r*255.0+rotationColor.g;float rotationAngle=-(scaledAngle*360.0/255.0)*0.017453292;vec2 fractionalPart=fract(gridCoord)-0.5;if(flipHorizontal)fractionalPart.x=-fractionalPart.x;if(flipVertical)fractionalPart.y=-fractionalPart.y;fractionalPart=rotate2D(rotationAngle)*fractionalPart+0.5;vec2 cellSize=1.0/u_charsetDimensions;vec2 texCoord=charCoord+fractionalPart*cellSize;vec2 cellMax=charCoord+cellSize;if(any(lessThan(texCoord,charCoord))||any(greaterThan(texCoord,cellMax))){gl_FragColor=isInverted ? primaryColor : secondaryColor;return;}vec4 charTexel=texture2D(u_characterTexture,texCoord);if(isInverted)charTexel.rgb=1.0-charTexel.rgb;gl_FragColor=mix(secondaryColor,primaryColor,charTexel);}"), this.Xr(e);
  }
  async Xr(e) {
    await this.Qs.ci(e.fontSource);
    const r = this.Qs.maxGlyphDimensions;
    this.Lr = new At(this.xi.canvas, r.width, r.height), this.Ir = this.Us.rs(this.Lr.cols, this.Lr.rows, 5), this.Yr(), this.Vr(), this.Er.start(() => this.Wr());
  }
  Yr() {
    this.Hr = () => {
      this.jr();
    }, window.addEventListener("resize", this.Hr);
  }
  Wr() {
    if (this.Er.measureFrameRate(), this.Er.incrementFrame(), this.Ur) return;
    this.Ir.V(), this.Us.He(this.Br), this.Or(), this.Us.ls(this.Br), this.Ir.O();
    const e = this.Us.state.canvasBackgroundColor;
    this.Us.de(e[0], e[1], e[2], e[3]), this.Us.He(this.kr), this.kr.st({ u_characterTexture: this.Qs.fontFramebuffer, u_charsetDimensions: [this.Qs.textureColumns, this.Qs.textureRows], u_asciiCharacterTexture: this.Ir.textures[0], u_primaryColorTexture: this.Ir.textures[1], u_secondaryColorTexture: this.Ir.textures[2], u_transformTexture: this.Ir.textures[4], u_rotationTexture: this.Ir.textures[3], u_gridCellDimensions: [this.Lr.cols, this.Lr.rows], u_gridPixelDimensions: [this.Lr.width, this.Lr.height], u_gridOffsetPixels: [this.Lr.offsetX, this.Lr.offsetY], u_aspectRatio: this.Lr.width / this.Lr.height }), this.Us.Qe(this.Lr.offsetX, this.Lr.offsetY, this.Lr.width, this.Lr.height);
  }
  setup(e) {
    this.Vr = e;
  }
  draw(e) {
    this.Or = e;
  }
  windowResized(e) {
    this.jr = e;
  }
  resizeCanvas(e, r) {
    this.xi.W(e, r), this.Lr.zt(), this.Ir.W(this.Lr.cols, this.Lr.rows), this.Us.cs(), this.Wr();
  }
  destroy() {
    this.Ur || (this.Er.stop(), window.removeEventListener("resize", this.Hr), this.Qs.j(), this.Us.j(), this.Ur = !0);
  }
  get grid() {
    return this.Lr;
  }
  get font() {
    return this.Qs;
  }
  get width() {
    return this.xi.width;
  }
  get height() {
    return this.xi.height;
  }
  get canvas() {
    return this.xi.canvas;
  }
  get isDisposed() {
    return this.Ur;
  }
  get drawFramebuffer() {
    return this.Ir;
  }
}
class N {
  constructor() {
  }
  static create(t = {}) {
    return new Ht(t);
  }
  static setErrorLevel(t) {
    I.v(t);
  }
  static get version() {
    return "0.2.0";
  }
}
const Zt = Object.freeze(Object.defineProperty({ __proto__: null }, Symbol.toStringTag, { value: "Module" })), Kt = N.create, qt = N.setErrorLevel, Jt = N.version;
export {
  Ft as TextmodeCanvas,
  J as TextmodeErrorLevel,
  Tt as TextmodeFont,
  At as TextmodeGrid,
  Ht as Textmodifier,
  Kt as create,
  Zt as export,
  qt as setErrorLevel,
  N as textmode,
  Jt as version
};
