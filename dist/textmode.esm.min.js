var ct = Object.defineProperty;
var lt = (h, t, e) => t in h ? ct(h, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : h[t] = e;
var a = (h, t, e) => lt(h, typeof t != "symbol" ? t + "" : t, e);
class _ extends Error {
  constructor(t, e = {}) {
    super(_.i(t, e)), this.name = "TextmodeError";
  }
  static i(t, e) {
    return `${t}${e && Object.keys(e).length > 0 ? `

ðŸ“‹ Context:` + Object.entries(e).map(([i, s]) => `
  - ${i}: ${_.o(s)}`).join("") : ""}

${"â†“".repeat(24)}
`;
  }
  static o(t) {
    if (t === null) return "null";
    if (t === void 0) return "undefined";
    if (typeof t == "string") return `"${t}"`;
    if (typeof t == "number" || typeof t == "boolean") return t + "";
    if (Array.isArray(t)) return t.length === 0 ? "[]" : t.length <= 5 ? `[${t.map((e) => _.o(e)).join(", ")}]` : `[${t.slice(0, 3).map((e) => _.o(e)).join(", ")}, ... +${t.length - 3} more]`;
    if (typeof t == "object") {
      const e = Object.keys(t);
      return e.length === 0 ? "{}" : e.length <= 3 ? `{ ${e.map((i) => `${i}: ${_.o(t[i])}`).join(", ")} }` : `{ ${e.slice(0, 2).map((i) => `${i}: ${_.o(t[i])}`).join(", ")}, ... +${e.length - 2} more }`;
    }
    return t + "";
  }
}
var ut = ((h) => (h[h.SILENT = 0] = "SILENT", h[h.WARNING = 1] = "WARNING", h[h.ERROR = 2] = "ERROR", h[h.THROW = 3] = "THROW", h))(ut || {});
const B = class B {
  constructor() {
    a(this, "u", { globalLevel: 3 });
  }
  static _() {
    return B.l || (B.l = new B()), B.l;
  }
  m(t, e) {
    const i = "%c[textmode.js] Oops! (â•¯Â°â–¡Â°)â•¯ï¸µ Something went wrong in your code.", s = "color: #f44336; font-weight: bold; background: #ffebee; padding: 2px 6px; border-radius: 3px;";
    switch (this.u.globalLevel) {
      case 0:
        return !1;
      case 1:
        return console.group(i, s), console.warn(_.i(t, e)), console.groupEnd(), !1;
      case 2:
        return console.group(i, s), console.error(_.i(t, e)), console.groupEnd(), !1;
      default:
        throw new _(t, e);
    }
  }
  v(t, e, i) {
    return !!t || (this.m(e, i), !1);
  }
  C(t) {
    this.u.globalLevel = t;
  }
};
a(B, "l", null);
let K = B;
const $ = K._(), ot = /* @__PURE__ */ new WeakMap();
function W(h, t) {
  ot.set(h, t);
}
function H(h) {
  return ot.get(h);
}
class ht {
  constructor() {
    a(this, "$", 1);
    a(this, "U", 0);
    a(this, "M", 0);
    a(this, "R", 0);
    a(this, "F", [0, 0, 0]);
    a(this, "S", [1, 1, 1, 1]);
    a(this, "A", [0, 0, 0, 1]);
    a(this, "L", !1);
    a(this, "P", !1);
    a(this, "k", !1);
    a(this, "G", [0, 0]);
    a(this, "D", [0, 0, 0, 1]);
    a(this, "I", []);
  }
  W() {
    this.I.push({ O: this.$, H: this.U, V: this.M, K: this.R, G: [...this.G], N: this.L, X: this.P, k: this.k, j: [...this.F], Y: [...this.S], q: [...this.A] });
  }
  Z() {
    const t = this.I.pop();
    t ? (this.$ = t.O, this.U = t.H, this.M = t.V, this.R = t.K, this.G = t.G, this.L = t.N, this.P = t.X, this.k = t.k, this.F = t.j, this.S = t.Y, this.A = t.q) : console.warn("pop() called without matching push()");
  }
  J(t) {
    t.O = this.$, t.H = this.U, t.V = this.M, t.K = this.R, t.j[0] = this.F[0], t.j[1] = this.F[1], t.j[2] = this.F[2], t.Y[0] = this.S[0], t.Y[1] = this.S[1], t.Y[2] = this.S[2], t.Y[3] = this.S[3], t.q[0] = this.A[0], t.q[1] = this.A[1], t.q[2] = this.A[2], t.q[3] = this.A[3], t.N = this.L, t.X = this.P, t.k = this.k, t.G[0] = this.G[0], t.G[1] = this.G[1];
  }
  get lineWeight() {
    return this.$;
  }
  get canvasBackgroundColor() {
    return this.D;
  }
  tt(t) {
    this.$ = Math.abs(t);
  }
  et(t) {
    this.U = t;
  }
  st(t) {
    this.M = t;
  }
  it(t) {
    this.R = t;
  }
  rt(t) {
    this.F = t;
  }
  nt(t, e, i, s = 255) {
    this.S = [t / 255, e / 255, i / 255, s / 255];
  }
  ot(t, e, i, s = 255) {
    this.A = [t / 255, e / 255, i / 255, s / 255];
  }
  ht(t) {
    this.L = t;
  }
  ct(t) {
    this.P = t;
  }
  lt(t) {
    this.k = t;
  }
  ut(t) {
    const e = 255 * t / 360, i = Math.floor(e) / 255, s = Math.round(e - Math.floor(e));
    this.G = [i, s];
  }
  ft(t, e, i, s) {
    this.D = [t / 255, e / 255, i / 255, s / 255];
  }
}
class j {
  constructor(t, e, i = e, s = 1, r = {}, n = null, o = !1) {
    a(this, "dt");
    a(this, "_t");
    a(this, "u");
    a(this, "gt", null);
    a(this, "vt");
    a(this, "yt");
    a(this, "Ct", []);
    a(this, "wt");
    a(this, "$t", null);
    a(this, "bt", []);
    a(this, "xt", null);
    a(this, "Mt", !1);
    a(this, "Rt", null);
    this.dt = e, this._t = i, this.u = { filter: "nearest", wrap: "clamp", format: "rgba", type: "unsigned_byte", ...r }, this.vt = t, this.wt = Math.min(Math.max(1, s), 8), this.xt = n, this.Mt = !!o, this.Rt = this.Mt ? new ht() : null;
    const c = t.getParameter(t.MAX_DRAW_BUFFERS), l = t.getParameter(t.MAX_COLOR_ATTACHMENTS);
    this.wt = Math.min(this.wt, c, l), this.yt = t.createFramebuffer(), this.Ft(), this.St(), this.bt = Array(this.wt).fill(null);
  }
  Ft() {
    const t = this.vt, e = this.u.filter === "linear" ? t.LINEAR : t.NEAREST, i = this.u.wrap === "repeat" ? t.REPEAT : t.CLAMP_TO_EDGE, s = this.u.type === "float" ? t.FLOAT : t.UNSIGNED_BYTE;
    for (let r = 0; r < this.wt; r++) {
      const n = t.createTexture();
      t.bindTexture(t.TEXTURE_2D, n), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, e), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, e), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, i), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, i), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, this.dt, this._t, 0, t.RGBA, s, null), this.Ct.push(n);
    }
    t.bindTexture(t.TEXTURE_2D, null);
  }
  St() {
    const t = this.vt;
    if (t.bindFramebuffer(t.FRAMEBUFFER, this.yt), this.wt === 1) t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, this.Ct[0], 0);
    else {
      const i = [];
      for (let s = 0; s < this.wt; s++) {
        const r = t.COLOR_ATTACHMENT0 + s;
        t.framebufferTexture2D(t.FRAMEBUFFER, r, t.TEXTURE_2D, this.Ct[s], 0), i.push(r);
      }
      t.drawBuffers(i);
    }
    const e = t.checkFramebufferStatus(t.FRAMEBUFFER);
    e !== t.FRAMEBUFFER_COMPLETE && console.error("GLFramebuffer is not complete:", e), t.bindFramebuffer(t.FRAMEBUFFER, null);
  }
  At(t) {
    const e = this.vt;
    e.bindTexture(e.TEXTURE_2D, this.Ct[0]), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, 1), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t), e.bindTexture(e.TEXTURE_2D, null);
  }
  resize(t, e) {
    this.dt = t, this._t = e, this.gt = null, this.bt = Array(this.wt).fill(null);
    const i = this.vt, s = this.u.type === "float" ? i.FLOAT : i.UNSIGNED_BYTE;
    for (const r of this.Ct) i.bindTexture(i.TEXTURE_2D, r), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, this.dt, this._t, 0, i.RGBA, s, null);
    i.bindTexture(i.TEXTURE_2D, null);
  }
  zt(t) {
    const e = this.vt, i = this.bt[t];
    if (i) return i;
    const s = this.dt, r = this._t, n = new Uint8Array(s * r * 4), o = e.getParameter(e.READ_FRAMEBUFFER_BINDING);
    e.bindFramebuffer(e.READ_FRAMEBUFFER, this.yt), e.readBuffer(e.COLOR_ATTACHMENT0 + t), e.readPixels(0, 0, s, r, e.RGBA, e.UNSIGNED_BYTE, n), e.bindFramebuffer(e.READ_FRAMEBUFFER, o);
    const c = 4 * s, l = new Uint8Array(n.length);
    for (let u = 0; u < r; u++) {
      const f = (r - 1 - u) * c, g = u * c;
      l.set(n.subarray(f, f + c), g);
    }
    return this.bt[t] = l, l;
  }
  begin() {
    var e, i, s, r;
    const t = this.vt;
    if (this.xt) {
      const n = ((i = (e = this.xt).Tt) == null ? void 0 : i.call(e)) ?? null;
      n && this.xt.Et(n), this.Mt && this.Rt && ((r = (s = this.xt).Lt) == null || r.call(s, this.Rt));
    }
    this.$t = { framebuffer: t.getParameter(t.FRAMEBUFFER_BINDING), viewport: t.getParameter(t.VIEWPORT) }, t.bindFramebuffer(t.FRAMEBUFFER, this.yt), this.bt = Array(this.wt).fill(null);
    for (let n = 0; n < this.wt; n++) t.clearBufferfv(t.COLOR, n, new Float32Array([0, 0, 0, 0]));
    t.viewport(0, 0, this.dt, this._t), W(t, [0, 0, this.dt, this._t]);
  }
  end() {
    var e, i, s, r;
    if (!this.$t) return;
    const t = this.vt;
    if (this.xt) {
      const n = ((i = (e = this.xt).Tt) == null ? void 0 : i.call(e)) ?? null;
      n && this.xt.Et(n);
    }
    t.bindFramebuffer(t.FRAMEBUFFER, this.$t.framebuffer), t.viewport(...this.$t.viewport), W(t, this.$t.viewport), this.$t = null, this.xt && this.Mt && this.Rt && ((r = (s = this.xt).Pt) == null || r.call(s));
  }
  kt() {
    const t = this.vt;
    t.deleteFramebuffer(this.yt);
    for (const e of this.Ct) t.deleteTexture(e);
  }
  get width() {
    return this.dt;
  }
  get height() {
    return this._t;
  }
  get textures() {
    return [...this.Ct];
  }
}
class I {
  constructor(t, e, i) {
    a(this, "vt");
    a(this, "Gt");
    a(this, "Bt", /* @__PURE__ */ new Map());
    a(this, "Dt", /* @__PURE__ */ new Map());
    a(this, "It", 0);
    this.vt = t, this.Gt = this.Wt(e, i), this.Ot();
  }
  Ot() {
    const t = this.vt.getProgramParameter(this.Gt, this.vt.ACTIVE_UNIFORMS);
    for (let e = 0; e < t; e++) {
      const i = this.vt.getActiveUniform(this.Gt, e);
      if (i) {
        const s = this.vt.getUniformLocation(this.Gt, i.name);
        if (s && (this.Bt.set(i.name, s), this.Dt.set(i.name, { type: i.type, size: i.size }), i.size > 1)) {
          const r = i.name.replace(/\[.*\]$/, "");
          this.Bt.has(r) || (this.Bt.set(r, s), this.Dt.set(r, { type: i.type, size: i.size }));
        }
      }
    }
  }
  Wt(t, e) {
    const i = this.Ht(this.vt.VERTEX_SHADER, t), s = this.Ht(this.vt.FRAGMENT_SHADER, e), r = this.vt.createProgram();
    if (this.vt.attachShader(r, i), this.vt.attachShader(r, s), this.vt.linkProgram(r), !this.vt.getProgramParameter(r, this.vt.LINK_STATUS)) {
      const n = this.vt.getProgramInfoLog(r);
      throw Error("Shader program link error: " + n);
    }
    return this.vt.deleteShader(i), this.vt.deleteShader(s), r;
  }
  Ht(t, e) {
    const i = this.vt.createShader(t);
    if (this.vt.shaderSource(i, e), this.vt.compileShader(i), !this.vt.getShaderParameter(i, this.vt.COMPILE_STATUS)) {
      const s = this.vt.getShaderInfoLog(i);
      throw this.vt.deleteShader(i), Error("Shader compilation error: " + s);
    }
    return i;
  }
  Vt() {
    this.vt.useProgram(this.Gt), this.Kt();
  }
  Kt() {
    this.It = 0;
  }
  Nt(t) {
    for (const [e, i] of Object.entries(t)) this.Xt(e, i);
  }
  jt(t) {
    return this.Bt.has(t);
  }
  Yt(t) {
    return this.Dt.get(t) || null;
  }
  qt() {
    const t = [];
    for (const [e, i] of this.Dt.entries()) t.push({ name: e, ...i });
    return t;
  }
  Xt(t, e) {
    var c;
    const i = this.Bt.get(t);
    if (!i) return;
    const s = this.Dt.get(t);
    if (!s) return void console.warn(`No type information found for uniform '${t}'`);
    const { type: r, size: n } = s, o = this.vt;
    if (typeof e == "number") switch (r) {
      case o.INT:
      case o.BOOL:
        o.uniform1i(i, e);
        break;
      case o.FLOAT:
        o.uniform1f(i, e);
        break;
      default:
        console.warn(`Unexpected uniform type for scalar '${t}': ${r}`), o.uniform1f(i, e);
    }
    else if (typeof e == "boolean") o.uniform1i(i, e ? 1 : 0);
    else if (Array.isArray(e)) if (Array.isArray(e[0])) {
      const l = e, u = ((c = l[0]) == null ? void 0 : c.length) || 0, f = l.flat();
      switch (r) {
        case o.FLOAT_VEC2:
          u === 2 ? o.uniform2fv(i, f) : console.warn(`Vector length mismatch for '${t}': expected 2, got ${u}`);
          break;
        case o.FLOAT_VEC3:
          u === 3 ? o.uniform3fv(i, f) : console.warn(`Vector length mismatch for '${t}': expected 3, got ${u}`);
          break;
        case o.FLOAT_VEC4:
          u === 4 ? o.uniform4fv(i, f) : console.warn(`Vector length mismatch for '${t}': expected 4, got ${u}`);
          break;
        default:
          console.warn(`Unsupported uniform type for vector array '${t}': ${r}`);
      }
    } else switch (r) {
      case o.FLOAT_VEC2:
        e.length === 2 ? o.uniform2f(i, e[0], e[1]) : console.warn(`Vector length mismatch for '${t}': expected 2, got ${e.length}`);
        break;
      case o.FLOAT_VEC3:
        e.length === 3 ? o.uniform3f(i, e[0], e[1], e[2]) : console.warn(`Vector length mismatch for '${t}': expected 3, got ${e.length}`);
        break;
      case o.FLOAT_VEC4:
        e.length === 4 ? o.uniform4f(i, e[0], e[1], e[2], e[3]) : console.warn(`Vector length mismatch for '${t}': expected 4, got ${e.length}`);
        break;
      case o.INT:
        n > 1 ? o.uniform1iv(i, e) : console.warn(`Array provided for scalar uniform '${t}'`);
        break;
      case o.FLOAT:
        n > 1 ? o.uniform1fv(i, e) : console.warn(`Array provided for scalar uniform '${t}'`);
        break;
      default:
        console.warn(`Unsupported uniform type for array '${t}': ${r}`);
    }
    else if (e instanceof WebGLTexture) {
      const l = this.Zt();
      o.uniform1i(i, l), o.activeTexture(o.TEXTURE0 + l), o.bindTexture(o.TEXTURE_2D, e);
    } else if (e instanceof j) {
      const l = this.Zt();
      o.uniform1i(i, l), o.activeTexture(o.TEXTURE0 + l), o.bindTexture(o.TEXTURE_2D, e.textures[0]);
    } else console.warn(`Unsupported uniform type for '${t}':`, typeof e);
  }
  Zt() {
    return this.It++;
  }
  get Jt() {
    return this.Gt;
  }
  kt() {
    this.vt.deleteProgram(this.Gt);
  }
}
const N = `#version 300 es
in vec2 a_position;in vec2 a_texCoord;in vec2 a_instancePosition;in vec2 a_instanceSize;in vec3 a_instanceCharacter;in vec4 a_instancePrimaryColor;in vec4 a_instanceSecondaryColor;in vec2 a_instanceRotation;in vec3 a_instanceTransform;in vec3 a_instanceGlobalRotation;in vec2 a_instanceRotationCenter;in vec2 a_instanceBezierCP1;in vec2 a_instanceBezierCP2;in vec2 a_instanceBezierStart;in vec2 a_instanceBezierEnd;in vec2 a_instanceArcAngles;uniform float U9;uniform vec2 Uy;out vec2 v_uv;out vec3 v_character;out vec4 v_primaryColor;out vec4 v_secondaryColor;out vec2 v_rotation;out vec3 v_transform;mat3 A(float B){float C=sin(B),D=cos(B);return mat3(1,0,0,0,D,-C,0,C,D);}mat3 E(float B){float C=sin(B),D=cos(B);return mat3(D,0,C,0,1,0,-C,0,D);}mat3 F(float B){float C=sin(B),D=cos(B);return mat3(D,-C,0,C,D,0,0,0,1);}vec2 G(float H,vec2 I,vec2 J,vec2 K,vec2 L){float M=1.-H,N=M*M,O=H*H;return N*M*I+3.*N*H*J+3.*M*O*K+O*H*L;}vec2 P(float H,vec2 I,vec2 J,vec2 K,vec2 L){float M=1.-H,N=M*M,O=H*H;return-3.*N*I+3.*N*J-6.*M*H*J+6.*M*H*K-3.*O*K+3.*O*L;}void main(){v_uv=a_texCoord;v_character=a_instanceCharacter;v_primaryColor=a_instancePrimaryColor;v_secondaryColor=a_instanceSecondaryColor;v_rotation=a_instanceRotation;v_transform=a_instanceTransform;vec2 Q;bool R=length(a_instanceBezierCP1)+length(a_instanceBezierCP2)+length(a_instanceBezierStart)+length(a_instanceBezierEnd)>0.;bool S=a_instanceArcAngles.x!=0.||a_instanceArcAngles.y!=0.;if(R){float H=a_position.x;vec2 T=G(H,a_instanceBezierStart,a_instanceBezierCP1,a_instanceBezierCP2,a_instanceBezierEnd);vec2 U=P(H,a_instanceBezierStart,a_instanceBezierCP1,a_instanceBezierCP2,a_instanceBezierEnd);float V=length(U);U=V>0.?U/V:vec2(1,0);Q=T+vec2(-U.y,U.x)*a_position.y*a_instanceSize.y;}else if(S){float C=a_instanceArcAngles.x,W=a_instanceArcAngles.y;C=mod(C,6.28318530718);if(C<0.)C+=6.28318530718;W=mod(W,6.28318530718);if(W<0.)W+=6.28318530718;float X=C-W;if(X<=0.)X+=6.28318530718;float Y=C-a_position.x*X;vec2 Z=vec2(cos(Y),sin(Y))*a_position.y;Q=Z*a_instanceSize*.5+a_instanceSize*.5+a_instancePosition;}else{Q=a_position*a_instanceSize+a_instancePosition;}vec2 a=(Q/Uy)*2.-1.;a.y=-a.y;if(length(a_instanceGlobalRotation)>0.){vec3 b=vec3(a-a_instanceRotationCenter,0);b.x*=U9;if(a_instanceGlobalRotation.x!=0.)b=A(-a_instanceGlobalRotation.x)*b;if(a_instanceGlobalRotation.y!=0.)b=E(-a_instanceGlobalRotation.y)*b;if(a_instanceGlobalRotation.z!=0.)b=F(-a_instanceGlobalRotation.z)*b;b.x/=U9;a=b.xy+a_instanceRotationCenter;}gl_Position=vec4(a,0,1);}`, at = "attribute vec2 a_position;attribute vec2 a_texCoord;varying vec2 v_uv;void main(){v_uv=a_texCoord;gl_Position=vec4(a_position,0.,1.);}";
class ft {
  constructor(t) {
    a(this, "vt");
    a(this, "Qt");
    a(this, "te");
    a(this, "ee");
    a(this, "se");
    this.vt = t, this.te = new I(this.vt, N, `#version 300 es
precision highp float;in vec2 v_uv;in vec3 v_character;in vec4 v_primaryColor;in vec4 v_secondaryColor;in vec2 v_rotation;in vec3 v_transform;layout(location=0)out vec4 o_character;layout(location=1)out vec4 o_primaryColor;layout(location=2)out vec4 o_secondaryColor;layout(location=3)out vec4 o_rotation;layout(location=4)out vec4 o_transform;void main(){o_character=vec4(v_character,1.);o_primaryColor=v_primaryColor;o_secondaryColor=v_secondaryColor;o_rotation=vec4(v_rotation,0.,1.);o_transform=vec4(v_transform,1.);}`), this.Qt = new I(this.vt, N, `#version 300 es
precision highp float;in vec2 v_uv;uniform sampler2D Ue;uniform sampler2D Uf;uniform sampler2D Ug;uniform sampler2D Uh;uniform sampler2D Ui;uniform vec2 Uj;layout(location=0)out vec4 o_character;layout(location=1)out vec4 o_primaryColor;layout(location=2)out vec4 o_secondaryColor;layout(location=3)out vec4 o_rotation;layout(location=4)out vec4 o_transform;void main(){vec2 A=vec2(v_uv.x,1.-v_uv.y);vec2 B=A*Uj;vec2 C=(floor(B)+0.5f)/Uj;vec4 D=texture(Ue,C);vec4 E=texture(Uf,C);if(E.a==0.){discard;}vec4 F=texture(Ug,C);vec4 G=texture(Uh,C);vec4 H=texture(Ui,C);o_character=D;o_primaryColor=E;o_secondaryColor=F;o_rotation=G;o_transform=H;}`), this.ee = new I(this.vt, at, "precision mediump float;uniform sampler2D U0;uniform vec2 U1;uniform sampler2D U3;uniform sampler2D U4;uniform sampler2D U5;uniform sampler2D U2;uniform sampler2D U6;uniform vec2 U7;uniform vec2 U8;mat2 A(float B){float C=sin(B);float D=cos(B);return mat2(D,-C,C,D);}void main(){vec2 E=gl_FragCoord.xy/U8;vec2 F=E*U7;vec2 G=floor(F);vec2 H=(G+0.5)/U7;vec4 I=texture2D(U3,H);vec4 J=texture2D(U4,H);vec4 K=texture2D(U5,H);bool L=K.r>0.5;bool M=K.g>0.5;bool N=K.b>0.5;vec4 O=texture2D(U2,H);int P=int(O.r*255.+0.5)+int(O.g*255.+0.5)*256;int Q=int(mod(float(P),U1.x));int R=P/int(U1.x);float S=(U1.y-1.)-float(R);vec2 T=vec2(float(Q),S)/U1;vec4 U=texture2D(U6,H);float V=U.r*255.+U.g;float W=-(V*360./255.)*0.017453292;vec2 X=fract(F)-0.5;if(M)X.x=-X.x;if(N)X.y=-X.y;X=A(W)*X+0.5;vec2 Y=1./U1;vec2 Z=T+X*Y;vec2 a=T+Y;if(any(lessThan(Z,T))||any(greaterThan(Z,a))){gl_FragColor=L?I:J;return;}vec4 b=texture2D(U0,Z);if(L)b.rgb=1.-b.rgb;gl_FragColor=mix(J,I,b);}"), this.se = new I(this.vt, N, `#version 300 es
precision highp float;in vec2 v_uv;uniform sampler2D Uk;uniform bool Ul;uniform bool Um;uniform bool Un;uniform vec2 Uo;uniform bool Up;uniform vec3 Uq;uniform bool Ur;uniform vec3 Us;uniform vec4 Ut;uniform int Uu;uniform vec3 Uv[64];layout(location=0)out vec4 o_character;layout(location=1)out vec4 o_primaryColor;layout(location=2)out vec4 o_secondaryColor;layout(location=3)out vec4 o_rotation;layout(location=4)out vec4 o_transform;float A(vec3 B){return dot(B,vec3(0.299f,0.587f,0.114f));}void main(){vec2 C=vec2(v_uv.x,1.0f-v_uv.y);vec4 D=texture(Uk,C);float E=A(D.rgb);if(Uu>0){float F=float(Uu);float G=clamp(E*(F-1.0f),0.0f,F-1.0f);int H=int(floor(G+0.5f));vec3 I=Uv[H];o_character=vec4(I,1.0f);}else{o_character=vec4(E,0.0f,0.0f,1.0f);}vec3 J=D.rgb;vec3 K=Up?Uq:J;vec3 L=Ur?Us:J;float M=1.0f;float N=1.0f;if(D.a<0.01f){K=Ut.rgb;L=Ut.rgb;}o_primaryColor=vec4(K,M);o_secondaryColor=vec4(L,N);o_rotation=vec4(Uo.xy,0.0f,1.0f);o_transform=vec4(float(Ul),float(Um),float(Un),1.0f);}`);
  }
  ie() {
    return this.Qt;
  }
  Tt() {
    return this.te;
  }
  re() {
    return this.ee;
  }
  ne() {
    return this.se;
  }
  oe(t) {
    return new I(this.vt, N, t);
  }
  ae(t, e) {
    return new I(this.vt, t, e);
  }
  kt() {
    this.Qt.kt(), this.te.kt(), this.ee.kt(), this.se.kt();
  }
}
var w = ((h) => (h.RECTANGLE = "rectangle", h.LINE = "line", h.ELLIPSE = "ellipse", h.ARC = "arc", h.TRIANGLE = "triangle", h.BEZIER_CURVE = "bezier_curve", h.CUSTOM = "custom", h))(w || {});
class dt {
  constructor(t) {
    a(this, "vt");
    a(this, "he", /* @__PURE__ */ new Map());
    this.vt = t;
  }
  ce(t, e, i, s) {
    const r = this.vt;
    let n = this.he.get(t);
    n || (n = /* @__PURE__ */ new Map(), this.he.set(t, n));
    let o = n.get(e) || null;
    if (!o) {
      o = r.createVertexArray(), n.set(e, o), r.bindVertexArray(o), r.bindBuffer(r.ARRAY_BUFFER, s);
      const c = r.getAttribLocation(t, "a_position");
      c !== -1 && (r.enableVertexAttribArray(c), r.vertexAttribPointer(c, i.ue.le.size, r.FLOAT, !1, i.fe, i.ue.le.offset), r.vertexAttribDivisor(c, 0));
      const l = r.getAttribLocation(t, "a_texCoord");
      l !== -1 && (r.enableVertexAttribArray(l), r.vertexAttribPointer(l, i.ue.de.size, r.FLOAT, !1, i.fe, i.ue.de.offset), r.vertexAttribDivisor(l, 0));
    }
    r.bindVertexArray(o);
  }
  _e() {
    this.vt.bindVertexArray(null);
  }
  kt() {
    for (const [, t] of this.he) for (const [, e] of t) e && this.vt.deleteVertexArray(e);
  }
}
class gt {
  constructor(t, e) {
    a(this, "pe");
    a(this, "vt");
    a(this, "xt");
    a(this, "me", null);
    a(this, "ge", null);
    this.vt = t, this.pe = new dt(t), this.xt = e;
  }
  ve(t, e, i) {
    const { shader: s } = t, r = H(this.vt) || this.vt.getParameter(this.vt.VIEWPORT);
    s.Nt({ U9: r[2] / r[3], Uy: [r[2], r[3]] });
    const n = (l) => {
      if (!l || !l.ye()) return;
      const u = l.unitGeometry, f = l.unitBuffer;
      try {
        this.pe.ce(s.Jt, l.type + "", u, f), l.batch.Ce(s), l.batch.we(u.$e, u.be);
      } finally {
        l.batch.xe(s), this.pe._e(), l.Me();
      }
    };
    let o = null, c = null;
    for (const l of e) {
      if (l.type === w.CUSTOM) {
        c && (n(c), o = null, c = null), this.Re(t, l.params, l.state, i.get(w.RECTANGLE));
        continue;
      }
      o !== null && l.type !== o && (n(c), o = null, c = null);
      let u = c;
      u && l.type === o || (u = i.get(l.type) || null, c = u, o = l.type), u && u.Fe(l.params, l.state);
    }
    n(c);
  }
  Re(t, e, i, s) {
    const { x: r, y: n, width: o, height: c, shader: l, uniforms: u } = e, f = this.Se(Math.max(1, Math.floor(o)), Math.max(1, Math.floor(c)));
    f.begin(), this.Ae(s, l, u, 0, 0, f.width, f.height, {}), f.end();
    const g = this.ze(), v = { Ue: f.textures[0], Uf: f.textures[1], Ug: f.textures[2], Uh: f.textures[3], Ui: f.textures[4], Uj: [f.width, f.height] };
    this.Ae(s, g, v, Math.floor(r), Math.floor(n), Math.max(1, Math.floor(o)), Math.max(1, Math.floor(c)), i), t.shader.Vt();
  }
  Ae(t, e, i, s, r, n, o, c) {
    e.Vt(), e.Nt(i);
    const l = this.vt.getParameter(this.vt.VIEWPORT);
    if (e.Nt({ U9: l[2] / l[3], Uy: [l[2], l[3]] }), t.Me(), t.Fe({ x: s, y: r, width: n, height: o }, c), t.ye()) {
      const u = t.unitGeometry, f = t.unitBuffer;
      try {
        this.pe.ce(e.Jt, t.type + "", u, f), t.batch.Ce(e), t.batch.we(u.$e, u.be);
      } finally {
        t.batch.xe(e), this.pe._e(), t.Me();
      }
    }
  }
  ze() {
    return this.xt.ie();
  }
  Se(t, e) {
    return this.me && this.ge && this.ge.w === t && this.ge.h === e || (this.me && this.me.kt(), this.me = new j(this.vt, t, e, 5), this.ge = { w: t, h: e }), this.me;
  }
  kt() {
    this.pe.kt(), this.me && this.me.kt();
  }
}
class pt {
  constructor() {
    a(this, "Te", []);
    a(this, "Ee", 1);
    a(this, "Le", 0);
  }
  Pe(t) {
    if (this.Le >= this.Te.length) {
      const i = { id: this.Ee++, type: t, params: {}, state: { O: 1, H: 0, V: 0, K: 0, j: [0, 0, 0], Y: [1, 1, 1, 1], q: [0, 0, 0, 1], N: !1, X: !1, k: !1, G: [0, 0] } };
      this.Te.push(i);
    }
    const e = this.Te[this.Le];
    return e.id = this.Ee++, e.type = t, this.Le++, e;
  }
  ke(t, e, i, s, r) {
    const n = this.Pe(w.RECTANGLE);
    return n.params.x = t, n.params.y = e, n.params.width = i, n.params.height = s, r.J(n.state), n.id;
  }
  Ge(t, e, i, s, r, n, o) {
    const c = this.Pe(w.CUSTOM);
    return c.params.x = t, c.params.y = e, c.params.width = i, c.params.height = s, c.params.shader = r, c.params.uniforms = n, o.J(c.state), c.id;
  }
  Be(t, e, i, s, r, n) {
    const o = this.Pe(w.LINE);
    return o.params.x1 = t, o.params.y1 = e, o.params.x2 = i, o.params.y2 = s, o.params.thickness = r, n.J(o.state), o.id;
  }
  De(t, e, i, s, r) {
    const n = this.Pe(w.ELLIPSE);
    return n.params.x = t, n.params.y = e, n.params.width = i, n.params.height = s, r.J(n.state), n.id;
  }
  Ie(t, e, i, s, r, n, o) {
    const c = this.Pe(w.ARC);
    return c.params.x = t, c.params.y = e, c.params.width = i, c.params.height = s, c.params.start = r, c.params.stop = n, o.J(c.state), c.id;
  }
  We(t, e, i, s, r, n, o) {
    const c = this.Pe(w.TRIANGLE);
    return c.params.x1 = t, c.params.y1 = e, c.params.x2 = i, c.params.y2 = s, c.params.x3 = r, c.params.y3 = n, o.J(c.state), c.id;
  }
  Oe(t, e, i, s, r, n, o, c, l, u) {
    const f = this.Pe(w.BEZIER_CURVE);
    return f.params.x1 = t, f.params.y1 = e, f.params.cp1x = i, f.params.cp1y = s, f.params.cp2x = r, f.params.cp2y = n, f.params.x2 = o, f.params.y2 = c, f.params.thickness = l, u.J(f.state), f.id;
  }
  get length() {
    return this.Le;
  }
  get isEmpty() {
    return this.Le === 0;
  }
  He() {
    this.Le = 0;
  }
  [Symbol.iterator]() {
    let t = 0;
    const e = this.Le, i = this.Te;
    return { next: () => t < e ? { value: i[t++], done: !1 } : { value: void 0, done: !0 } };
  }
}
const P = class P {
  static Ve(t, e, i = 0) {
    var n, o, c, l, u, f, g, v, m, d;
    const s = e || new Float32Array(P.FLOATS_PER_INSTANCE);
    let r = i;
    return s[r++] = t.le[0], s[r++] = t.le[1], s[r++] = t.Le[0], s[r++] = t.Le[1], s[r++] = t.j[0], s[r++] = t.j[1], s[r++] = t.j[2], s[r++] = t.Y[0], s[r++] = t.Y[1], s[r++] = t.Y[2], s[r++] = t.Y[3], s[r++] = t.q[0], s[r++] = t.q[1], s[r++] = t.q[2], s[r++] = t.q[3], s[r++] = t.G[0], s[r++] = t.G[1], s[r++] = t.Ke[0], s[r++] = t.Ke[1], s[r++] = t.Ke[2], s[r++] = t.H, s[r++] = t.V, s[r++] = t.K, s[r++] = t.Ne[0], s[r++] = t.Ne[1], s[r++] = ((n = t.Xe) == null ? void 0 : n[0]) || 0, s[r++] = ((o = t.Xe) == null ? void 0 : o[1]) || 0, s[r++] = ((c = t.je) == null ? void 0 : c[0]) || 0, s[r++] = ((l = t.je) == null ? void 0 : l[1]) || 0, s[r++] = ((u = t.Ye) == null ? void 0 : u[0]) || 0, s[r++] = ((f = t.Ye) == null ? void 0 : f[1]) || 0, s[r++] = ((g = t.qe) == null ? void 0 : g[0]) || 0, s[r++] = ((v = t.qe) == null ? void 0 : v[1]) || 0, s[r++] = ((m = t.Ze) == null ? void 0 : m[0]) || 0, s[r++] = ((d = t.Ze) == null ? void 0 : d[1]) || 0, s;
  }
  static Je(t) {
    const e = t.length * P.FLOATS_PER_INSTANCE, i = new Float32Array(e);
    for (let s = 0; s < t.length; s++) {
      const r = s * P.FLOATS_PER_INSTANCE;
      P.Ve(t[s], i, r);
    }
    return i;
  }
};
a(P, "BYTES_PER_INSTANCE", 140), a(P, "FLOATS_PER_INSTANCE", 35);
let M = P;
const A = class A {
};
a(A, "STRIDE", M.BYTES_PER_INSTANCE), a(A, "ATTRIBUTES", { a_instancePosition: { location: -1, size: 2, type: WebGL2RenderingContext.FLOAT, normalized: !1, stride: A.STRIDE, offset: 0, divisor: 1 }, a_instanceSize: { location: -1, size: 2, type: WebGL2RenderingContext.FLOAT, normalized: !1, stride: A.STRIDE, offset: 8, divisor: 1 }, a_instanceCharacter: { location: -1, size: 3, type: WebGL2RenderingContext.FLOAT, normalized: !1, stride: A.STRIDE, offset: 16, divisor: 1 }, a_instancePrimaryColor: { location: -1, size: 4, type: WebGL2RenderingContext.FLOAT, normalized: !1, stride: A.STRIDE, offset: 28, divisor: 1 }, a_instanceSecondaryColor: { location: -1, size: 4, type: WebGL2RenderingContext.FLOAT, normalized: !1, stride: A.STRIDE, offset: 44, divisor: 1 }, a_instanceRotation: { location: -1, size: 2, type: WebGL2RenderingContext.FLOAT, normalized: !1, stride: A.STRIDE, offset: 60, divisor: 1 }, a_instanceTransform: { location: -1, size: 3, type: WebGL2RenderingContext.FLOAT, normalized: !1, stride: A.STRIDE, offset: 68, divisor: 1 }, a_instanceGlobalRotation: { location: -1, size: 3, type: WebGL2RenderingContext.FLOAT, normalized: !1, stride: A.STRIDE, offset: 80, divisor: 1 }, a_instanceRotationCenter: { location: -1, size: 2, type: WebGL2RenderingContext.FLOAT, normalized: !1, stride: A.STRIDE, offset: 92, divisor: 1 }, a_instanceArcAngles: { location: -1, size: 2, type: WebGL2RenderingContext.FLOAT, normalized: !1, stride: A.STRIDE, offset: 100, divisor: 1 }, a_instanceBezierCP1: { location: -1, size: 2, type: WebGL2RenderingContext.FLOAT, normalized: !1, stride: A.STRIDE, offset: 108, divisor: 1 }, a_instanceBezierCP2: { location: -1, size: 2, type: WebGL2RenderingContext.FLOAT, normalized: !1, stride: A.STRIDE, offset: 116, divisor: 1 }, a_instanceBezierStart: { location: -1, size: 2, type: WebGL2RenderingContext.FLOAT, normalized: !1, stride: A.STRIDE, offset: 124, divisor: 1 }, a_instanceBezierEnd: { location: -1, size: 2, type: WebGL2RenderingContext.FLOAT, normalized: !1, stride: A.STRIDE, offset: 132, divisor: 1 } });
let X = A;
class mt {
  constructor(t, e = 1e3, i = 1.5) {
    a(this, "vt");
    a(this, "Qe", []);
    a(this, "ts");
    a(this, "es");
    a(this, "ss", null);
    a(this, "rs", !0);
    a(this, "ns", 0);
    a(this, "hs", /* @__PURE__ */ new Map());
    a(this, "cs", null);
    this.vt = t, this.ts = e, this.es = i, this.ls();
  }
  Fe(t) {
    const e = this.Qe.length;
    return this.Qe.push(t), this.rs = !0, e;
  }
  get count() {
    return this.Qe.length;
  }
  get isEmpty() {
    return this.Qe.length === 0;
  }
  clear() {
    this.Qe.length = 0, this.rs = !0;
  }
  us(t) {
    if (t <= this.ts) return;
    const e = Math.ceil(t * this.es);
    this.ts = e, this.ls();
  }
  ls() {
    const t = this.vt;
    this.ss && t.deleteBuffer(this.ss), this.ss = t.createBuffer();
    const e = this.ts * M.BYTES_PER_INSTANCE;
    t.bindBuffer(t.ARRAY_BUFFER, this.ss), t.bufferData(t.ARRAY_BUFFER, e, t.DYNAMIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, null), this.rs = !0, this.ns = 0;
  }
  fs() {
    if (!this.rs || this.Qe.length === 0) return;
    const t = this.vt, e = this.Qe.length;
    this.us(e), (!this.cs || this.cs.length < e * M.FLOATS_PER_INSTANCE) && (this.cs = new Float32Array(e * M.FLOATS_PER_INSTANCE));
    const i = M.Je(this.Qe);
    t.bindBuffer(t.ARRAY_BUFFER, this.ss), e <= this.ns ? t.bufferSubData(t.ARRAY_BUFFER, 0, i) : t.bufferData(t.ARRAY_BUFFER, i, t.DYNAMIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, null), this.rs = !1, this.ns = e;
  }
  ds(t) {
    let e = this.hs.get(t);
    if (!e) {
      e = /* @__PURE__ */ new Map();
      const i = this.vt;
      for (const s in X.ATTRIBUTES) {
        const r = i.getAttribLocation(t, s);
        r !== -1 && e.set(s, r);
      }
      this.hs.set(t, e);
    }
    return e;
  }
  Ce(t) {
    if (!this.ss || this.Qe.length === 0) return;
    const e = this.vt, i = t.Jt;
    this.fs();
    const s = this.ds(i);
    e.bindBuffer(e.ARRAY_BUFFER, this.ss);
    for (const [r, n] of s) {
      const o = X.ATTRIBUTES[r];
      o && (e.enableVertexAttribArray(n), e.vertexAttribPointer(n, o.size, o.type, o.normalized, o.stride, o.offset), e.vertexAttribDivisor(n, o.divisor));
    }
  }
  xe(t) {
    const e = this.vt, i = this.ds(t.Jt);
    for (const [, s] of i) e.disableVertexAttribArray(s), e.vertexAttribDivisor(s, 0);
  }
  we(t, e) {
    this.Qe.length !== 0 && this.vt.drawArraysInstanced(t, 0, e, this.Qe.length);
  }
  kt() {
    this.ss && this.vt.deleteBuffer(this.ss);
  }
}
class D {
  constructor(t, e, i, s) {
    a(this, "vt");
    a(this, "_s");
    a(this, "ps");
    a(this, "gs");
    a(this, "vs", null);
    this.vt = t, this._s = e, this.ps = i, this.gs = s;
    const r = this.vt.createBuffer();
    if (!r) throw Error("Failed to create unit geometry buffer");
    this.vt.bindBuffer(this.vt.ARRAY_BUFFER, r), this.vt.bufferData(this.vt.ARRAY_BUFFER, this.gs.Cs, this.vt.STATIC_DRAW), this.vt.bindBuffer(this.vt.ARRAY_BUFFER, null), this.vs = r;
  }
  get type() {
    return this.ps;
  }
  get unitGeometry() {
    return this.gs;
  }
  get unitBuffer() {
    return this.vs;
  }
  get batch() {
    return this._s;
  }
  Me() {
    this._s.clear();
  }
  ye() {
    return !this._s.isEmpty;
  }
  kt() {
    this._s.kt(), this.vt.deleteBuffer(this.vs);
  }
  ws(t, e, i, s, r) {
    const n = this.$s(t, e, i, s, r.H || 0, r.V || 0, r.K || 0);
    return { le: [t, e], Le: [i, s], j: r.j || [0, 0, 0], Y: r.Y || [1, 1, 1, 1], q: r.q || [0, 0, 0, 1], G: r.G || [0, 0], Ke: [r.k ? 1 : 0, r.N ? 1 : 0, r.X ? 1 : 0], H: n.radiansX, V: n.radiansY, K: n.radiansZ, Ne: [n.centerX, n.centerY] };
  }
  bs(t, e) {
    const i = H(this.vt) || [0, 0, this.vt.canvas.width, this.vt.canvas.height];
    return { nx: t / i[2] * 2 - 1, ny: 1 - e / i[3] * 2 };
  }
  Ms(t, e, i) {
    const s = this.bs(e, i);
    t.Ne = [s.nx, s.ny];
  }
  $s(t, e, i, s, r, n, o) {
    const c = H(this.vt) || [0, 0, this.vt.canvas.width, this.vt.canvas.height], l = c[2], u = c[3];
    return { centerX: (t + i / 2) / l * 2 - 1, centerY: 1 - (e + s / 2) / u * 2, radiansX: -r * Math.PI / 180, radiansY: -n * Math.PI / 180, radiansZ: -o * Math.PI / 180, aspectRatio: l / u };
  }
}
const vt = { Cs: new Float32Array([0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1]), be: 6, $e: WebGL2RenderingContext.TRIANGLES, fe: 16, ue: { le: { size: 2, offset: 0 }, de: { size: 2, offset: 8 } } };
class xt extends D {
  constructor(t, e) {
    super(t, e, w.RECTANGLE, vt);
  }
  Fe(t, e) {
    const i = this.ws(t.x, t.y, t.width, t.height, e);
    return this._s.Fe(i);
  }
}
const yt = { Cs: new Float32Array([0, -0.5, 0, 0, 1, -0.5, 1, 0, 0, 0.5, 0, 1, 0, 0.5, 0, 1, 1, -0.5, 1, 0, 1, 0.5, 1, 1]), be: 6, $e: WebGL2RenderingContext.TRIANGLES, fe: 16, ue: { le: { size: 2, offset: 0 }, de: { size: 2, offset: 8 } } };
class Et extends D {
  constructor(t, e) {
    super(t, e, w.LINE, yt);
  }
  Fe(t, e) {
    const i = t.x2 - t.x1, s = t.y2 - t.y1, r = Math.hypot(i, s), n = t.thickness || e.O || 1, o = t.x1 + i / 2, c = t.y1 + s / 2, l = o - r / 2, u = c, f = this.ws(l, u, r, n, e);
    return this.Ms(f, o, c), this._s.Fe(f);
  }
}
const wt = { Cs: function(h = 32) {
  const t = [], e = 2 * Math.PI / h;
  for (let i = 0; i < h; i++) {
    const s = i * e, r = (i + 1) % h * e, n = Math.cos(s), o = Math.sin(s), c = 0.5 * (n + 1), l = 0.5 * (o + 1), u = Math.cos(r), f = Math.sin(r), g = 0.5 * (u + 1), v = 0.5 * (f + 1);
    t.push(0, 0, 0.5, 0.5, n, o, c, l, u, f, g, v);
  }
  return new Float32Array(t);
}(32), be: 96, $e: WebGL2RenderingContext.TRIANGLES, fe: 16, ue: { le: { size: 2, offset: 0 }, de: { size: 2, offset: 8 } } };
class Rt extends D {
  constructor(t, e) {
    super(t, e, w.ELLIPSE, wt);
  }
  Fe(t, e) {
    const i = this.ws(t.x, t.y, t.width, t.height, e);
    return this.Ms(i, t.x, t.y), this._s.Fe(i);
  }
}
let bt = { Cs: function(h) {
  const t = [];
  for (let e = 0; e < h; e++) {
    const i = e / h, s = (e + 1) / h;
    t.push(i, 0, i, 0, i, 1, i, 1, s, 1, s, 1);
  }
  return new Float32Array(t);
}(32), be: 96, $e: WebGL2RenderingContext.TRIANGLES, fe: 16, ue: { le: { size: 2, offset: 0 }, de: { size: 2, offset: 8 } } };
class Tt extends D {
  constructor(t, e) {
    super(t, e, w.ARC, bt);
  }
  Fe(t, e) {
    const i = t.x - t.width / 2, s = t.y - t.height / 2, r = t.start * Math.PI / 180, n = t.stop * Math.PI / 180, o = this.ws(i, s, t.width, t.height, e);
    return this.Ms(o, t.x, t.y), o.Xe = [r, n], this._s.Fe(o);
  }
}
const At = { Cs: new Float32Array([0, 0, 0, 0, 1, 0, 1, 0, 0.5, 1, 0.5, 1]), be: 3, $e: WebGL2RenderingContext.TRIANGLES, fe: 16, ue: { le: { size: 2, offset: 0 }, de: { size: 2, offset: 8 } } };
class Ct extends D {
  constructor(t, e) {
    super(t, e, w.TRIANGLE, At);
  }
  Fe(t, e) {
    const i = Math.min(t.x1, t.x2, t.x3), s = Math.max(t.x1, t.x2, t.x3), r = Math.min(t.y1, t.y2, t.y3), n = s - i, o = Math.max(t.y1, t.y2, t.y3) - r, c = this.ws(i, r, n, o, e), l = i + 0.5 * n, u = r + o * (1 / 3);
    return this.Ms(c, l, u), this._s.Fe(c);
  }
}
function et(h, t, e, i, s) {
  const r = 1 - h, n = r * r, o = h * h;
  return n * r * t + 3 * n * h * e + 3 * r * o * i + o * h * s;
}
const _t = { Cs: function(h = 16) {
  const t = [];
  for (let e = 0; e < h; e++) {
    const i = e / h, s = (e + 1) / h;
    t.push(i, -0.5, i, 0), t.push(s, -0.5, s, 0), t.push(i, 0.5, i, 1), t.push(i, 0.5, i, 1), t.push(s, -0.5, s, 0), t.push(s, 0.5, s, 1);
  }
  return new Float32Array(t);
}(16), be: 96, $e: WebGL2RenderingContext.TRIANGLES, fe: 16, ue: { le: { size: 2, offset: 0 }, de: { size: 2, offset: 8 } } };
class Ut extends D {
  constructor(t, e) {
    super(t, e, w.BEZIER_CURVE, _t);
  }
  Fe(t, e) {
    const i = e.O || 1, s = et(0.5, t.x1, t.cp1x, t.cp2x, t.x2), r = et(0.5, t.y1, t.cp1y, t.cp2y, t.y2), n = this.ws(0, 0, 1, i, e);
    return this.Ms(n, s, r), n.qe = [t.x1, t.y1], n.je = [t.cp1x, t.cp1y], n.Ye = [t.cp2x, t.cp2y], n.Ze = [t.x2, t.y2], this._s.Fe(n);
  }
}
class Lt {
  constructor(t) {
    a(this, "vt");
    a(this, "Rs", null);
    a(this, "Fs");
    a(this, "Ss", null);
    a(this, "As", {});
    a(this, "zs", null);
    a(this, "Ts", /* @__PURE__ */ new Map());
    a(this, "Es");
    a(this, "Ls");
    a(this, "Ps");
    a(this, "I", []);
    this.vt = t, this.Fs = new ft(t), this.Ps = new ht(), this.Es = new gt(t, this), this.Ls = new pt(), this.zs = t.createBuffer(), W(this.vt, [0, 0, this.vt.canvas.width, this.vt.canvas.height]);
  }
  ks(t) {
    let e = this.Ts.get(t);
    if (e) return e;
    const i = new mt(this.vt);
    return e = (0, { [w.RECTANGLE]: () => new xt(this.vt, i), [w.LINE]: () => new Et(this.vt, i), [w.ELLIPSE]: () => new Rt(this.vt, i), [w.ARC]: () => new Tt(this.vt, i), [w.TRIANGLE]: () => new Ct(this.vt, i), [w.BEZIER_CURVE]: () => new Ut(this.vt, i) }[t])(), this.Ts.set(t, e), e;
  }
  Gs(t) {
    this.Rs !== t && (this.Rs = t, t.Vt());
  }
  ae(t, e) {
    return this.Fs.ae(t, e);
  }
  ie() {
    return this.Fs.ie();
  }
  Tt() {
    return this.Fs.Tt();
  }
  re() {
    return this.Fs.re();
  }
  ne() {
    return this.Fs.ne();
  }
  Bs(t) {
    this.Ss = t, t && (this.As = {});
  }
  Xt(t, e) {
    this.As[t] = e;
  }
  Ds(t) {
    Object.assign(this.As, t);
  }
  oe(t) {
    return this.Fs.oe(t);
  }
  Is(t, e, i, s, r) {
    const n = this.ie(), o = { Ue: t.textures[0], Uf: t.textures[1], Ug: t.textures[2], Uh: t.textures[3], Ui: t.textures[4], Uj: [t.width, t.height] };
    this.Ls.Ge(e, i, s, r, n, o, this.Ps);
  }
  Ws(t, e, i, s, r) {
    const n = this.ne(), o = t.Os(), c = { Uk: o.texture, Ul: !!o.invert, Um: !!o.flipX, Un: !!o.flipY, Uo: o.charRotation, Up: o.charColorFixed, Uq: o.charColor, Ur: o.cellColorFixed, Us: o.cellColor, Ut: o.backgroundColor, Uu: o.charCount, Uv: o.charList };
    this.Ls.Ge(e, i, s, r, n, c, this.Ps);
  }
  Hs(t, e, i, s) {
    var d;
    const r = this.vt, n = r.canvas.width, o = r.canvas.height, c = t / n * 2 - 1, l = (t + i) / n * 2 - 1, u = 1 - e / o * 2, f = 1 - (e + s) / o * 2, g = new Float32Array([c, f, l, f, c, u, l, f, l, u, c, u]);
    r.bindBuffer(r.ARRAY_BUFFER, this.zs), r.bufferData(r.ARRAY_BUFFER, g, r.DYNAMIC_DRAW);
    const v = ((d = this.Rs) == null ? void 0 : d.Jt) || r.getParameter(r.CURRENT_PROGRAM), m = v ? r.getAttribLocation(v, "a_position") : -1;
    m !== -1 && (r.enableVertexAttribArray(m), r.vertexAttribPointer(m, 2, r.FLOAT, !1, 8, 0)), r.drawArrays(r.TRIANGLES, 0, 6), m !== -1 && r.disableVertexAttribArray(m);
  }
  Vs(t, e, i, s) {
    this.Ss ? (this.Ls.Ge(t, e, i, s, this.Ss, { ...this.As }, this.Ps), this.Ss = null, this.As = {}) : this.Ls.ke(t, e, i, s, this.Ps);
  }
  Ks(t, e, i, s) {
    this.Ls.Be(t, e, i, s, this.Ps.lineWeight, this.Ps);
  }
  Ns(t, e, i, s) {
    this.Ls.De(t, e, i, s, this.Ps);
  }
  Xs(t, e, i, s, r, n) {
    this.Ls.We(t, e, i, s, r, n, this.Ps);
  }
  js(t, e, i, s, r, n, o, c) {
    const l = this.Ps.lineWeight;
    this.Ls.Oe(t, e, i, s, r, n, o, c, l, this.Ps);
  }
  Ys(t, e, i = 1, s = {}) {
    return new j(this.vt, t, e, i, s, this, !0);
  }
  qs(t, e, i, s, r, n) {
    this.Ls.Ie(t, e, i, s, r, n, this.Ps);
  }
  Zs(t, e = t, i = t, s = 255) {
    this.state.ft(t, e, i, s), this.He(t / 255, e / 255, i / 255, s / 255);
  }
  He(t = 0, e = 0, i = 0, s = 0) {
    this.vt.clearColor(t, e, i, s), this.vt.clear(this.vt.COLOR_BUFFER_BIT);
  }
  Js() {
    this.vt.viewport(0, 0, this.vt.canvas.width, this.vt.canvas.height), W(this.vt, [0, 0, this.vt.canvas.width, this.vt.canvas.height]);
  }
  get context() {
    return this.vt;
  }
  get state() {
    return this.Ps;
  }
  Lt(t) {
    this.I.push(this.Ps), this.Ps = t;
  }
  Pt() {
    const t = this.I.pop();
    t && (this.Ps = t);
  }
  Et(t) {
    const e = t, i = H(this.vt) ?? this.vt.getParameter(this.vt.VIEWPORT), s = { shader: e, gl: this.vt, viewport: i };
    this.Gs(e);
    const r = /* @__PURE__ */ new Set();
    for (const n of this.Ls) n.type === w.CUSTOM ? r.add(w.RECTANGLE) : r.add(n.type);
    for (const n of r) n !== w.CUSTOM && this.ks(n);
    this.Es.ve(s, this.Ls, this.Ts), this.Ls.He();
  }
  kt() {
    this.vt.deleteBuffer(this.zs), this.Ls.He();
    for (const t of this.Ts.values()) t.kt();
    this.Fs.kt(), this.Es.kt();
  }
}
const R = { readShort: (h, t) => (R.t.uint16[0] = h[t] << 8 | h[t + 1], R.t.int16[0]), readUshort: (h, t) => h[t] << 8 | h[t + 1], readUshorts(h, t, e) {
  const i = [];
  for (let s = 0; s < e; s++) i.push(R.readUshort(h, t + 2 * s));
  return i;
}, readUint(h, t) {
  const e = R.t.uint8;
  return e[3] = h[t], e[2] = h[t + 1], e[1] = h[t + 2], e[0] = h[t + 3], R.t.uint32[0];
}, readASCII(h, t, e) {
  let i = "";
  for (let s = 0; s < e; s++) i += String.fromCharCode(h[t + s]);
  return i;
}, writeUshort(h, t, e) {
  h[t] = e >>> 8 & 255, h[t + 1] = 255 & e;
}, writeUint(h, t, e) {
  h[t] = e >>> 24 & 255, h[t + 1] = e >>> 16 & 255, h[t + 2] = e >>> 8 & 255, h[t + 3] = 255 & e;
}, writeASCII(h, t, e) {
  for (let i = 0; i < e.length; i++) h[t + i] = 255 & e.charCodeAt(i);
}, t: (() => {
  const h = new ArrayBuffer(8);
  return { uint8: new Uint8Array(h), int16: new Int16Array(h), uint16: new Uint16Array(h), uint32: new Uint32Array(h) };
})() };
function z(h) {
  return h + 3 & -4;
}
function Y(h, t, e) {
  const i = t + e;
  let s = 0;
  const r = R.t;
  for (let n = t; n < i; n += 4) r.uint8[3] = h[n] || 0, r.uint8[2] = h[n + 1] || 0, r.uint8[1] = h[n + 2] || 0, r.uint8[0] = h[n + 3] || 0, s = s + (r.uint32[0] >>> 0) >>> 0;
  return s >>> 0;
}
class Ft {
  constructor(t) {
    a(this, "b");
    a(this, "p", 0);
    a(this, "bitbuf", 0);
    a(this, "bitcnt", 0);
    this.b = t;
  }
  readBits(t) {
    for (; this.bitcnt < t; ) {
      const i = this.b[this.p++] || 0;
      this.bitbuf |= i << this.bitcnt, this.bitcnt += 8;
    }
    const e = this.bitbuf & (1 << t) - 1;
    return this.bitbuf >>>= t, this.bitcnt -= t, e;
  }
  alignToByte() {
    this.bitbuf = 0, this.bitcnt = 0;
  }
  get offset() {
    return this.p;
  }
}
function O(h) {
  let t = 32, e = 0;
  for (const o of h) o && (o < t && (t = o), o > e && (e = o));
  if (e === 0) return { min: 0, max: 0, table: /* @__PURE__ */ new Map() };
  const i = new Uint32Array(e + 1);
  for (const o of h) o && i[o]++;
  const s = new Uint32Array(e + 1);
  let r = 0;
  i[0] = 0;
  for (let o = 1; o <= e; o++) r = r + i[o - 1] << 1, s[o] = r;
  const n = /* @__PURE__ */ new Map();
  for (let o = 0; o < h.length; o++) {
    const c = h[o];
    if (!c) continue;
    const l = s[c]++;
    let u = n.get(c);
    u || (u = [], n.set(c, u)), u[Pt(l, c)] = o;
  }
  return { min: t, max: e, table: n };
}
function V(h, t) {
  let e = 0;
  for (let i = 1; i <= t.max; i++) {
    e |= h.readBits(1) << i - 1;
    const s = t.table.get(i);
    if (s && e < s.length) {
      const r = s[e];
      if (r !== void 0) return r;
    }
  }
  throw Error("Invalid Huffman code");
}
function Pt(h, t) {
  let e = 0;
  for (let i = 0; i < t; i++) e = e << 1 | 1 & h, h >>>= 1;
  return e >>> 0;
}
function St(h) {
  if (h.length < 2) throw Error("ZLIB data too short");
  const t = h[0], e = h[1];
  if ((15 & t) != 8) throw Error("Unsupported ZLIB compression method");
  if (((t << 8) + e) % 31 != 0) throw Error("Bad ZLIB header check");
  let i = 2;
  32 & e && (i += 4);
  const s = [];
  return function(r, n) {
    const o = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258], c = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], l = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577], u = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    let f = 0;
    for (; !f; ) {
      f = r.readBits(1);
      const g = r.readBits(2);
      if (g === 0) {
        r.alignToByte();
        const v = r.readBits(16);
        if ((65535 & (65535 ^ v)) !== r.readBits(16)) throw Error("DEFLATE uncompressed LEN/NLEN mismatch");
        for (let m = 0; m < v; m++) n.push(r.readBits(8));
      } else {
        if (g !== 1 && g !== 2) throw Error("Unsupported DEFLATE type");
        {
          let v, m;
          if (g === 1) {
            const d = Array(288).fill(0);
            for (let x = 0; x <= 143; x++) d[x] = 8;
            for (let x = 144; x <= 255; x++) d[x] = 9;
            for (let x = 256; x <= 279; x++) d[x] = 7;
            for (let x = 280; x <= 287; x++) d[x] = 8;
            v = O(d), m = O(Array(32).fill(5));
          } else {
            const d = r.readBits(5) + 257, x = r.readBits(5) + 1, p = r.readBits(4) + 4, E = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], y = Array(19).fill(0);
            for (let U = 0; U < p; U++) y[E[U]] = r.readBits(3);
            const C = O(y), b = [];
            for (; b.length < d + x; ) {
              const U = V(r, C);
              if (U <= 15) b.push(U);
              else if (U === 16) {
                const G = r.readBits(2) + 3, S = b[b.length - 1] || 0;
                for (let tt = 0; tt < G; tt++) b.push(S);
              } else if (U === 17) {
                const G = r.readBits(3) + 3;
                for (let S = 0; S < G; S++) b.push(0);
              } else {
                if (U !== 18) throw Error("Invalid code length symbol");
                {
                  const G = r.readBits(7) + 11;
                  for (let S = 0; S < G; S++) b.push(0);
                }
              }
            }
            const T = b.slice(0, d), L = b.slice(d, d + x);
            v = O(T), m = O(L);
          }
          for (; ; ) {
            const d = V(r, v);
            if (d < 256) n.push(d);
            else {
              if (d === 256) break;
              if (d > 256 && d < 286) {
                const x = d - 257;
                let p = o[x];
                const E = c[x];
                E && (p += r.readBits(E));
                const y = V(r, m);
                if (y >= 30) throw Error("Invalid distance symbol");
                let C = l[y];
                const b = u[y];
                b && (C += r.readBits(b));
                const T = n.length - C;
                if (T < 0) throw Error("Invalid distance");
                for (let L = 0; L < p; L++) n.push(n[T + L] || 0);
              } else if (d === 286 || d === 287) throw Error("Reserved length symbol");
            }
          }
        }
      }
    }
  }(new Ft(h.subarray(i)), s), new Uint8Array(s);
}
function Bt(h) {
  const t = R, e = new Uint8Array(h);
  if (t.readASCII(e, 0, 4) !== "wOFF") throw Error("Invalid WOFF signature");
  const i = t.readUint(e, 4), s = t.readUshort(e, 12), r = t.readUint(e, 16), n = [];
  let o = 44;
  for (let p = 0; p < s; p++) {
    const E = t.readASCII(e, o, 4), y = t.readUint(e, o + 4), C = t.readUint(e, o + 8), b = t.readUint(e, o + 12), T = t.readUint(e, o + 16);
    n.push({ tag: E, offset: y, compLength: C, origLength: b, checksum: T }), o += 20;
  }
  for (const p of n) {
    const E = new Uint8Array(e.buffer, p.offset, p.compLength);
    if (p.compLength === p.origLength) p.data = new Uint8Array(E);
    else if (p.data = St(E), p.data.length !== p.origLength) if (p.data.length < p.origLength) {
      const y = new Uint8Array(p.origLength);
      y.set(p.data), p.data = y;
    } else p.data = p.data.subarray(0, p.origLength);
  }
  const c = s;
  let l = 1, u = 0;
  for (; l << 1 <= c; ) l <<= 1, u++;
  const f = 16 * l, g = 16 * c - f;
  let v = 12 + 16 * c;
  const m = {};
  for (const p of n) m[p.tag] = v, v = z(v + p.data.length);
  const d = new Uint8Array(Math.max(r || 0, v));
  t.writeUint(d, 0, i), t.writeUshort(d, 4, c), t.writeUshort(d, 6, f), t.writeUshort(d, 8, u), t.writeUshort(d, 10, g);
  let x = 12;
  for (const p of n) {
    t.writeASCII(d, x, p.tag), x += 4;
    let E = p.data;
    if (p.tag === "head" && E.length >= 12) {
      const y = new Uint8Array(E);
      t.writeUint(y, 8, 0);
      const C = Y(y, 0, z(y.length));
      t.writeUint(d, x, C), x += 4;
    } else {
      const y = Y(E, 0, z(E.length));
      t.writeUint(d, x, y), x += 4;
    }
    t.writeUint(d, x, m[p.tag]), x += 4, t.writeUint(d, x, p.data.length), x += 4;
  }
  for (const p of n) {
    const E = m[p.tag];
    d.set(p.data, E);
  }
  if (n.find((p) => p.tag === "head")) {
    const p = m.head, E = function(y, C) {
      const b = R, T = C + 8, L = [y[T], y[T + 1], y[T + 2], y[T + 3]];
      b.writeUint(y, T, 0);
      const U = 2981146554 - (Y(y, 0, z(y.length)) >>> 0) >>> 0;
      return y[T] = L[0], y[T + 1] = L[1], y[T + 2] = L[2], y[T + 3] = L[3], U >>> 0;
    }(d, p);
    t.writeUint(d, p + 8, E);
  }
  return d.buffer;
}
const Mt = { parseTab(h, t, e) {
  const i = { tables: [], ids: {}, off: t };
  h = new Uint8Array(h.buffer, t, e), t = 0;
  const s = R, r = s.readUshort, n = r(h, t += 2);
  t += 2;
  const o = [];
  for (let c = 0; c < n; c++) {
    const l = r(h, t), u = r(h, t += 2);
    t += 2;
    const f = s.readUint(h, t);
    t += 4;
    const g = `p${l}e${u}`;
    let v = o.indexOf(f);
    if (v === -1) {
      let m;
      v = i.tables.length, o.push(f);
      const d = r(h, f);
      m = d === 4 ? this.parse4(h, f) : d === 12 ? this.parse12(h, f) : { format: d }, i.tables.push(m);
    }
    i.ids[g] = v;
  }
  return i;
}, parse4(h, t) {
  const e = R, i = e.readUshort, s = e.readUshorts, r = t, n = i(h, t += 2);
  t += 2;
  const o = i(h, t += 2) >>> 1, c = { format: 4, searchRange: i(h, t += 2), entrySelector: 0, rangeShift: 0, endCount: [], startCount: [], idDelta: [], idRangeOffset: [], glyphIdArray: [] };
  t += 2, c.entrySelector = i(h, t), t += 2, c.rangeShift = i(h, t), t += 2, c.endCount = s(h, t, o), t += 2 * o, t += 2, c.startCount = s(h, t, o), t += 2 * o;
  for (let l = 0; l < o; l++) c.idDelta.push(e.readShort(h, t)), t += 2;
  return c.idRangeOffset = s(h, t, o), t += 2 * o, c.glyphIdArray = s(h, t, r + n - t >> 1), c;
}, parse12(h, t) {
  const e = R.readUint;
  e(h, t += 4), e(h, t += 4);
  const i = e(h, t += 4);
  t += 4;
  const s = new Uint32Array(3 * i);
  for (let r = 0; r < 3 * i; r += 3) s[r] = e(h, t + (r << 2)), s[r + 1] = e(h, t + (r << 2) + 4), s[r + 2] = e(h, t + (r << 2) + 8);
  return { format: 12, groups: s };
} }, It = { parseTab(h, t, e) {
  const i = R;
  t += 18;
  const s = i.readUshort(h, t);
  t += 2, t += 16;
  const r = i.readShort(h, t);
  t += 2;
  const n = i.readShort(h, t);
  t += 2;
  const o = i.readShort(h, t);
  t += 2;
  const c = i.readShort(h, t);
  return t += 2, t += 6, { unitsPerEm: s, xMin: r, yMin: n, xMax: o, yMax: c, indexToLocFormat: i.readShort(h, t) };
} }, Dt = { parseTab(h, t, e) {
  const i = R;
  t += 4;
  const s = ["ascender", "descender", "lineGap", "advanceWidthMax", "minLeftSideBearing", "minRightSideBearing", "xMaxExtent", "caretSlopeRise", "caretSlopeRun", "caretOffset", "res0", "res1", "res2", "res3", "metricDataFormat", "numberOfHMetrics"], r = {};
  for (let n = 0; n < s.length; n++) {
    const o = s[n], c = o === "advanceWidthMax" || o === "numberOfHMetrics" ? i.readUshort : i.readShort;
    r[o] = c(h, t + 2 * n);
  }
  return r;
} }, Gt = { parseTab(h, t, e, i) {
  const s = R, r = [], n = [], o = i.maxp.numGlyphs, c = i.hhea.numberOfHMetrics;
  let l = 0, u = 0, f = 0;
  for (; f < c; ) l = s.readUshort(h, t + (f << 2)), u = s.readShort(h, t + (f << 2) + 2), r.push(l), n.push(u), f++;
  for (; f < o; ) r.push(l), n.push(u), f++;
  return { aWidth: r, lsBearing: n };
} }, it = { cmap: Mt, head: It, hhea: Dt, maxp: { parseTab(h, t, e) {
  const i = R;
  return i.readUint(h, t), t += 4, { numGlyphs: i.readUshort(h, t) };
} }, hmtx: Gt, loca: { parseTab(h, t, e, i) {
  const s = R, r = [], n = i.head.indexToLocFormat, o = i.maxp.numGlyphs + 1;
  if (n === 0) for (let c = 0; c < o; c++) r.push(s.readUshort(h, t + (c << 1)) << 1);
  else if (n === 1) for (let c = 0; c < o; c++) r.push(s.readUint(h, t + (c << 2)));
  return r;
} }, glyf: { parseTab(h, t, e, i) {
  const s = [], r = i.maxp.numGlyphs;
  for (let n = 0; n < r; n++) s.push(null);
  return s;
}, Qs(h, t) {
  const e = R, i = h.ti, s = h.loca;
  if (s[t] === s[t + 1]) return null;
  const r = F.findTable(i, "glyf", h.ei);
  if (!r) return null;
  let n = r[0] + s[t];
  const o = {};
  if (o.noc = e.readShort(i, n), n += 2, o.xMin = e.readShort(i, n), n += 2, o.yMin = e.readShort(i, n), n += 2, o.xMax = e.readShort(i, n), n += 2, o.yMax = e.readShort(i, n), n += 2, o.xMin >= o.xMax || o.yMin >= o.yMax) return null;
  if (o.noc > 0) {
    o.endPts = [];
    for (let g = 0; g < o.noc; g++) o.endPts.push(e.readUshort(i, n)), n += 2;
    const c = e.readUshort(i, n);
    if (n += 2, i.length - n < c) return null;
    n += c;
    const l = o.endPts[o.noc - 1] + 1;
    o.flags = [];
    for (let g = 0; g < l; g++) {
      const v = i[n];
      if (n++, o.flags.push(v), 8 & v) {
        const m = i[n];
        n++;
        for (let d = 0; d < m; d++) o.flags.push(v), g++;
      }
    }
    o.xs = [];
    for (let g = 0; g < l; g++) {
      const v = o.flags[g], m = !!(16 & v);
      2 & v ? (o.xs.push(m ? i[n] : -i[n]), n++) : m ? o.xs.push(0) : (o.xs.push(e.readShort(i, n)), n += 2);
    }
    o.ys = [];
    for (let g = 0; g < l; g++) {
      const v = o.flags[g], m = !!(32 & v);
      4 & v ? (o.ys.push(m ? i[n] : -i[n]), n++) : m ? o.ys.push(0) : (o.ys.push(e.readShort(i, n)), n += 2);
    }
    let u = 0, f = 0;
    for (let g = 0; g < l; g++) u += o.xs[g], f += o.ys[g], o.xs[g] = u, o.ys[g] = f;
  } else o.parts = [], o.endPts = [], o.flags = [], o.xs = [], o.ys = [];
  return o;
} } }, F = { parse(h) {
  const t = new Uint8Array(h), e = R.readASCII(t, 0, 4);
  if (e === "wOFF") h = Bt(h);
  else if (e === "wOF2") throw Error("WOFF2 is not supported in this build (Brotli + WOFF2 transforms required)");
  return [((i, s, r, n) => {
    const o = it, c = { ti: i, si: s, ei: r };
    for (const l in o) {
      const u = l, f = F.findTable(i, u, r);
      if (f) {
        const [g, v] = f;
        let m = n[g];
        m == null && (m = o[u].parseTab(i, g, v, c), n[g] = m), c[u] = m;
      }
    }
    return c;
  })(new Uint8Array(h), 0, 0, {})];
}, findTable(h, t, e) {
  const i = R, s = i.readUshort(h, e + 4);
  let r = e + 12;
  for (let n = 0; n < s; n++) {
    const o = i.readASCII(h, r, 4);
    i.readUint(h, r + 4);
    const c = i.readUint(h, r + 8), l = i.readUint(h, r + 12);
    if (o === t) return [c, l];
    r += 16;
  }
  return null;
}, T: it, B: R };
class Ot {
  ii(t) {
    var i;
    const e = [];
    return (i = t.cmap) != null && i.tables ? (t.cmap.tables.forEach((s) => {
      if (s.format === 4) {
        const r = this.ri(s);
        e.push(...r);
      } else if (s.format === 12) {
        const r = this.ni(s);
        e.push(...r);
      }
    }), [...new Set(e)]) : [];
  }
  oi(t) {
    return t.filter((e) => this.ai(e));
  }
  ri(t) {
    const e = [];
    if (!(t.startCount && t.endCount && t.idRangeOffset && t.idDelta)) return e;
    for (let i = 0; i < t.startCount.length; i++) {
      const s = t.startCount[i], r = t.endCount[i];
      if (s !== 65535 || r !== 65535) {
        for (let n = s; n <= r; n++)
          if (this.hi(t, n, i) > 0) try {
            const o = String.fromCodePoint(n);
            e.push(o);
          } catch {
          }
      }
    }
    return e;
  }
  ni(t) {
    const e = [];
    if (!t.groups) return e;
    for (let i = 0; i < t.groups.length; i += 3) {
      const s = t.groups[i], r = t.groups[i + 1], n = t.groups[i + 2];
      for (let o = s; o <= r; o++)
        if (n + (o - s) > 0) try {
          const c = String.fromCodePoint(o);
          e.push(c);
        } catch {
        }
    }
    return e;
  }
  hi(t, e, i) {
    if (t.idRangeOffset[i] === 0) return e + t.idDelta[i] & 65535;
    {
      const s = t.idRangeOffset[i] / 2 + (e - t.startCount[i]) - (t.startCount.length - i);
      if (s >= 0 && t.glyphIdArray && s < t.glyphIdArray.length) {
        const r = t.glyphIdArray[s];
        if (r !== 0) return r + t.idDelta[i] & 65535;
      }
    }
    return 0;
  }
  ai(t) {
    const e = t.codePointAt(0) || 0;
    return !(e >= 0 && e <= 31 && e !== 9 && e !== 10 && e !== 13 || e >= 127 && e <= 159);
  }
}
class q {
  constructor() {
    a(this, "ci", /* @__PURE__ */ new Map());
    a(this, "li", /* @__PURE__ */ new Map());
  }
  ui(t, e) {
    const i = `${this.fi(t)}_${e}`;
    if (this.ci.has(i)) return this.ci.get(i);
    const s = t.cmap;
    if (!s || !s.tables) return this.ci.set(i, 0), 0;
    let r = 0;
    for (const n of s.tables) if (n.format === 4 ? r = this.di(e, n) : n.format === 12 && (r = this._i(e, n)), r > 0) break;
    return this.ci.set(i, r), r;
  }
  pi(t, e) {
    const i = e.codePointAt(0);
    return i === void 0 ? 0 : this.ui(t, i);
  }
  mi(t, e) {
    const i = t.hmtx;
    return i && i.aWidth && i.aWidth.length !== 0 ? e < i.aWidth.length ? i.aWidth[e] : i.aWidth[i.aWidth.length - 1] : 0;
  }
  gi(t, e) {
    const i = e / t.head.unitsPerEm, s = t.hhea.ascender * i, r = t.hhea.descender * i, n = t.hhea.lineGap * i;
    return { ascender: s, descender: r, lineGap: n, lineHeight: s - r + n, unitsPerEm: t.head.unitsPerEm, scale: i };
  }
  yi() {
    this.ci.clear(), this.li.clear();
  }
  fi(t) {
    return `${t.ei}_${t.ti.length}`;
  }
  di(t, e) {
    const i = e.endCount.length;
    let s = -1;
    for (let r = 0; r < i; r++) if (t <= e.endCount[r]) {
      s = r;
      break;
    }
    if (s === -1 || t < e.startCount[s]) return 0;
    if (e.idRangeOffset[s] === 0) return t + e.idDelta[s] & 65535;
    {
      const r = e.idRangeOffset[s] / 2 + (t - e.startCount[s]) - (i - s);
      if (r >= 0 && r < e.glyphIdArray.length) {
        const n = e.glyphIdArray[r];
        return n === 0 ? 0 : n + e.idDelta[s] & 65535;
      }
    }
    return 0;
  }
  _i(t, e) {
    const i = e.groups.length / 3;
    for (let s = 0; s < i; s++) {
      const r = e.groups[3 * s], n = e.groups[3 * s + 1], o = e.groups[3 * s + 2];
      if (t >= r && t <= n) return o + (t - r);
    }
    return 0;
  }
}
class $t {
  constructor(t) {
    a(this, "Ci");
    a(this, "wi");
    a(this, "xt");
    a(this, "$i");
    this.xt = t, this.$i = new q(), this.Ci = document.createElement("canvas"), this.wi = this.Ci.getContext("2d", { willReadFrequently: !0, alpha: !1 });
  }
  createTextureAtlas(t, e, i, s) {
    const r = t.length, n = Math.ceil(Math.sqrt(r)), o = Math.ceil(r / n), c = e.width * n, l = e.height * o, u = typeof s == "object" ? s : null;
    this.bi(c, l), this.xi(t, e, n, i, u);
    const f = this.xt.Ys(c, l, 1, { filter: "nearest" });
    return f.At(this.Ci), { framebuffer: f, columns: n, rows: o };
  }
  bi(t, e) {
    this.Ci.width = t, this.Ci.height = e, this.Ci.style.width = t + "px", this.Ci.style.height = t + "px", this.wi.imageSmoothingEnabled = !1, this.Ci.style.imageRendering = "pixelated", this.wi.fillStyle = "black", this.wi.fillRect(0, 0, t, e), this.wi.textBaseline = "top", this.wi.textAlign = "left", this.wi.fillStyle = "white";
  }
  xi(t, e, i, s, r) {
    const n = s / r.head.unitsPerEm;
    for (let o = 0; o < t.length; o++) {
      const c = o % i, l = Math.floor(o / i), u = t[o].character, f = this.Mi(r, u);
      if (!f) continue;
      const g = u.codePointAt(0) || 0, v = this.$i.ui(r, g), m = this.Ri(r, v) * n, d = c * e.width, x = l * e.height, p = d + 0.5 * e.width, E = x + 0.5 * e.height, y = Math.round(p - 0.5 * e.width), C = Math.round(E - 0.5 * s), b = y + 0.5 * (e.width - m), T = C + r.hhea.ascender * n;
      this.Fi(f, b, T, n);
    }
  }
  Mi(t, e) {
    const i = e.codePointAt(0) || 0, s = this.$i.ui(t, i);
    if (s === 0) return null;
    if (t.glyf && t.glyf[s] !== null) return t.glyf[s];
    if (F && F.T && F.T.glyf) {
      const r = F.T.glyf.Qs(t, s);
      return t.glyf && r && (t.glyf[s] = r), r;
    }
    return null;
  }
  Ri(t, e) {
    const i = t.hmtx;
    return i && i.aWidth ? e < i.aWidth.length ? i.aWidth[e] : i.aWidth[i.aWidth.length - 1] : 0;
  }
  Fi(t, e, i, s) {
    if (!t || !t.xs || t.noc === 0) return;
    const { xs: r, ys: n, endPts: o, flags: c } = t;
    if (!(r && n && o && c)) return;
    this.wi.beginPath();
    let l = 0;
    for (let u = 0; u < o.length; u++) {
      const f = o[u];
      if (!(f < l)) {
        if (f >= l) {
          const g = e + r[l] * s, v = i - n[l] * s;
          this.wi.moveTo(g, v);
          let m = l + 1;
          for (; m <= f; )
            if (1 & c[m]) {
              const d = e + r[m] * s, x = i - n[m] * s;
              this.wi.lineTo(d, x), m++;
            } else {
              const d = e + r[m] * s, x = i - n[m] * s;
              let p = m + 1 > f ? l : m + 1;
              if (1 & c[p]) {
                const E = e + r[p] * s, y = i - n[p] * s;
                this.wi.quadraticCurveTo(d, x, E, y), m = p + 1;
              } else {
                const E = (d + (e + r[p] * s)) / 2, y = (x + (i - n[p] * s)) / 2;
                this.wi.quadraticCurveTo(d, x, E, y), m = p;
              }
            }
          this.wi.closePath();
        }
        l = f + 1;
      }
    }
    this.wi.fill();
  }
}
class kt {
  constructor() {
    a(this, "Si");
    this.Si = new q();
  }
  Ai(t, e, i) {
    let s = 0;
    const r = this.Si.gi(i, e), n = r.lineHeight;
    for (const o of t) {
      const c = this.Si.pi(i, o);
      if (c === 0) continue;
      const l = this.Si.mi(i, c) * r.scale;
      s = Math.max(s, l);
    }
    return { width: Math.ceil(s), height: Math.ceil(n) };
  }
  yi() {
    this.Si.yi();
  }
}
class Nt {
  constructor() {
    a(this, "$i");
    this.$i = new q();
  }
  createCharacterObjects(t, e) {
    return t.map((i, s) => {
      const r = i.codePointAt(0) || 0, n = this.zi(s);
      let o = 0;
      if (e.hmtx && e.hmtx.aWidth) {
        const c = this.$i.ui(e, r);
        c > 0 && e.hmtx.aWidth[c] !== void 0 && (o = e.hmtx.aWidth[c]);
      }
      return { character: i, unicode: r, color: n, advanceWidth: o };
    });
  }
  zi(t) {
    return [t % 256 / 255, Math.floor(t / 256) % 256 / 255, Math.floor(t / 65536) % 256 / 255];
  }
  Ti(t, e) {
    if (!$.v(typeof t == "string", "Character must be a string.", { method: "getCharacterColor", providedValue: t })) return [0, 0, 0];
    const i = e.find((s) => s.character === t);
    return i ? i.color : [0, 0, 0];
  }
  Ei(t, e) {
    return $.v(typeof t == "string" && t.length > 0, "Characters must be a string with at least one character.", { method: "getCharacterColors", providedValue: t }) ? Array.from(t).map((i) => this.Ti(i, e) || [0, 0, 0]) : [[0, 0, 0]];
  }
}
class zt {
  constructor(t, e = 16) {
    a(this, "Li");
    a(this, "Pi", []);
    a(this, "ki");
    a(this, "Gi", 16);
    a(this, "Bi", 0);
    a(this, "Di", 0);
    a(this, "Ii", { width: 0, height: 0 });
    a(this, "Wi");
    a(this, "Oi");
    a(this, "Hi");
    a(this, "Vi");
    a(this, "Ki");
    this.Gi = e, this.Oi = new Ot(), this.Hi = new $t(t), this.Vi = new kt(), this.Ki = new Nt();
  }
  async Ni(t) {
    let e;
    if (!t) throw new _("Embedded font not available. This appears to be a minified build - please provide `fontSource`.");
    {
      const i = await fetch(t);
      if (!i.ok) throw new _(`Failed to load font file: ${i.status} ${i.statusText}`);
      e = await i.arrayBuffer();
    }
    await this.Xi(e), this.Li = F.parse(e)[0], await this.ji();
  }
  Yi(t) {
    if (t === void 0) return this.Gi;
    this.Gi = t, this.Ii = this.Vi.Ai(this.Pi.map((i) => i.character), this.Gi, this.Li);
    const e = this.Hi.createTextureAtlas(this.Pi, this.Ii, this.Gi, this.Li);
    this.ki = e.framebuffer, this.Bi = e.columns, this.Di = e.rows;
  }
  async qi(t) {
    try {
      const e = await fetch(t);
      if (!e.ok) throw new _(`Failed to load font file: ${e.status} ${e.statusText}`);
      const i = await e.arrayBuffer();
      await this.Xi(i);
      const s = F.parse(i);
      if (!s || s.length === 0) throw Error("Failed to parse font file");
      this.Li = s[0], await this.ji();
    } catch (e) {
      throw new _("Failed to load font: " + (e instanceof Error ? e.message : "Unknown error"), e);
    }
  }
  async Xi(t) {
    const e = Date.now();
    this.Wi = new FontFace("CustomFont_" + e, t), await this.Wi.load(), document.fonts.add(this.Wi);
  }
  async ji() {
    const t = this.Oi.ii(this.Li), e = this.Oi.oi(t);
    this.Pi = this.Ki.createCharacterObjects(e, this.Li), this.Ii = this.Vi.Ai(e, this.Gi, this.Li);
    const i = this.Hi.createTextureAtlas(this.Pi, this.Ii, this.Gi, this.Li);
    this.ki = i.framebuffer, this.Bi = i.columns, this.Di = i.rows;
  }
  Ti(t) {
    return this.Ki.Ti(t, this.Pi);
  }
  Ei(t) {
    return this.Ki.Ei(t, this.Pi);
  }
  kt() {
    this.ki.kt(), document.fonts.delete(this.Wi);
  }
  get fontFramebuffer() {
    return this.ki;
  }
  get characters() {
    return this.Pi;
  }
  get textureColumns() {
    return this.Bi;
  }
  get textureRows() {
    return this.Di;
  }
  get maxGlyphDimensions() {
    return this.Ii;
  }
  get fontSize() {
    return this.Gi;
  }
  get font() {
    return this.Li;
  }
}
class Wt {
  constructor(t, e, i) {
    a(this, "Zi");
    a(this, "Ji");
    a(this, "dt");
    a(this, "_t");
    a(this, "Qi");
    a(this, "tr");
    a(this, "er");
    a(this, "sr");
    a(this, "ir");
    this.er = t, this.sr = e, this.ir = i, this.rr();
  }
  rr() {
    this.Zi = Math.floor(this.er.width / this.sr), this.Ji = Math.floor(this.er.height / this.ir), this.dt = this.Zi * this.sr, this._t = this.Ji * this.ir, this.Qi = Math.floor((this.er.width - this.dt) / 2), this.tr = Math.floor((this.er.height - this._t) / 2);
  }
  nr(t, e) {
    this.sr = t, this.ir = e, this.rr();
  }
  get cellWidth() {
    return this.sr;
  }
  get cellHeight() {
    return this.ir;
  }
  get cols() {
    return this.Zi;
  }
  get rows() {
    return this.Ji;
  }
  get width() {
    return this.dt;
  }
  get height() {
    return this._t;
  }
  get offsetX() {
    return this.Qi;
  }
  get offsetY() {
    return this.tr;
  }
}
class Ht {
  constructor(t = {}) {
    a(this, "er");
    a(this, "ar", null);
    a(this, "hr", !1);
    a(this, "cr");
    a(this, "lr");
    this.hr = t.overlay ?? !1, this.hr && t.canvas ? (this.ar = t.canvas, this.er = this.ur(), this.lr = !0, this.dr()) : t.canvas ? (this.er = t.canvas, this.lr = !1) : (this.er = this._r(t.width, t.height), this.lr = !0), this.er.style.imageRendering = "pixelated";
  }
  _r(t, e) {
    const i = document.createElement("canvas");
    return i.className = "textmodeCanvas", i.style.imageRendering = "pixelated", i.width = t || 800, i.height = e || 600, document.body.appendChild(i), i;
  }
  ur() {
    const t = document.createElement("canvas");
    t.className = "textmodeCanvas", t.style.imageRendering = "pixelated";
    const e = this.ar.getBoundingClientRect();
    let i = Math.round(e.width), s = Math.round(e.height);
    if (this.ar instanceof HTMLVideoElement) {
      const o = this.ar;
      (i === 0 || s === 0) && o.videoWidth > 0 && o.videoHeight > 0 && (i = o.videoWidth, s = o.videoHeight);
    }
    t.width = i, t.height = s, t.style.position = "absolute", t.style.pointerEvents = "none";
    const r = window.getComputedStyle(this.ar);
    let n = parseInt(r.zIndex || "0", 10);
    return isNaN(n) && (n = 0), t.style.zIndex = "" + (n + 1), t;
  }
  dr() {
    var t;
    this.pr(), (t = this.ar.parentNode) == null || t.insertBefore(this.er, this.ar.nextSibling), window.ResizeObserver && (this.cr = new ResizeObserver(() => {
      this.mr();
    }), this.cr.observe(this.ar)), window.addEventListener("resize", () => {
      this.mr();
    });
  }
  pr() {
    if (!this.ar) return;
    const t = this.ar.getBoundingClientRect();
    let e = this.ar.offsetParent;
    if (e && e !== document.body) {
      const i = e.getBoundingClientRect();
      this.er.style.top = t.top - i.top + "px", this.er.style.left = t.left - i.left + "px";
    } else this.er.style.top = t.top + window.scrollY + "px", this.er.style.left = t.left + window.scrollX + "px";
  }
  mr(t, e) {
    if (this.hr) {
      const i = this.ar.getBoundingClientRect();
      let s = Math.round(i.width), r = Math.round(i.height);
      if (this.ar instanceof HTMLVideoElement) {
        const n = this.ar;
        (s === 0 || r === 0) && n.videoWidth > 0 && n.videoHeight > 0 && (s = n.videoWidth, r = n.videoHeight);
      }
      this.er.width = s, this.er.height = r, this.pr();
    } else this.er.width = t ?? this.er.width, this.er.height = e ?? this.er.height;
  }
  gr() {
    const t = this.er.getContext("webgl2", { alpha: !0, premultipliedAlpha: !1, preserveDrawingBuffer: !0, antialias: !1, depth: !1, stencil: !1, powerPreference: "high-performance" });
    if (!t) throw new _("`textmode.js` requires WebGL2 support.");
    return t;
  }
  kt() {
    this.cr && this.cr.disconnect();
    const t = this.er.getContext("webgl") || this.er.getContext("webgl2");
    if (t) {
      const e = t.getExtension("WEBGL_lose_context");
      e && e.loseContext();
    }
    this.lr && this.er.parentNode && this.er.parentNode.removeChild(this.er);
  }
  get canvas() {
    return this.er;
  }
  get targetCanvas() {
    return this.ar;
  }
  get width() {
    return this.er.width;
  }
  get height() {
    return this.er.height;
  }
}
class k {
  constructor(t, e, i, s) {
    a(this, "vr");
    a(this, "dt");
    a(this, "_t");
    a(this, "vt");
    a(this, "k", 0);
    a(this, "N", 0);
    a(this, "X", 0);
    a(this, "G", [0, 0]);
    a(this, "yr", "sampled");
    a(this, "Cr", "fixed");
    a(this, "Y", [1, 1, 1]);
    a(this, "q", [0, 0, 0]);
    a(this, "wr", [0, 0, 0, 1]);
    a(this, "$r", [[0.1, 0, 0]]);
    a(this, "br");
    this.vt = t, this.vr = e, this.dt = i, this._t = s;
  }
  kt() {
    this.vt.deleteTexture(this.vr);
  }
  Mr(t) {
    return typeof t == "boolean" ? t ? 1 : 0 : (t == null ? 0 : Number(t)) > 0 ? 1 : 0;
  }
  invert(t = !0) {
    return this.k = this.Mr(t), this;
  }
  flipX(t = !0) {
    return this.N = this.Mr(t), this;
  }
  flipY(t = !0) {
    return this.X = this.Mr(t), this;
  }
  charRotation(t) {
    const e = 255 * t / 360, i = Math.floor(e) / 255, s = Math.round(e - Math.floor(e));
    return this.G = [i, s], this;
  }
  Os() {
    return { texture: this.vr, invert: this.k, flipX: this.N, flipY: this.X, charRotation: this.G, charColorFixed: this.yr === "fixed", charColor: this.Y, cellColorFixed: this.Cr === "fixed", cellColor: this.q, backgroundColor: this.wr, charCount: this.$r.length, charList: this.$r };
  }
  charColorMode(t) {
    return this.yr = t, this;
  }
  cellColorMode(t) {
    return this.Cr = t, this;
  }
  charColor(t, e, i) {
    return this.Y = [(t ?? 0) / 255, (e ?? t ?? 0) / 255, (i ?? t ?? 0) / 255], this;
  }
  cellColor(t, e, i) {
    return this.q = [(t ?? 0) / 255, (e ?? t ?? 0) / 255, (i ?? t ?? 0) / 255], this;
  }
  background(t, e, i, s) {
    return this.wr = [(t ?? 0) / 255, (e ?? t ?? 0) / 255, (i ?? t ?? 0) / 255, (s ?? 255) / 255], this;
  }
  characters(t) {
    const e = this.br(t).filter((i) => Array.isArray(i)).slice(0, 64);
    return this.$r = e, this;
  }
  static Rr(t, e, i) {
    const s = t.context, r = s.createTexture();
    s.bindTexture(s.TEXTURE_2D, r), s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, 1), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.NEAREST), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, s.NEAREST), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), s.texImage2D(s.TEXTURE_2D, 0, s.RGBA, s.RGBA, s.UNSIGNED_BYTE, e), s.bindTexture(s.TEXTURE_2D, null);
    const n = e.naturalWidth ?? e.width ?? e.videoWidth ?? 0, o = e.naturalHeight ?? e.height ?? e.videoHeight ?? 0, c = new k(s, r, n, o);
    return c.br = i, c;
  }
  get texture() {
    return this.vr;
  }
  get width() {
    return this.dt;
  }
  get height() {
    return this._t;
  }
}
class Xt {
  constructor(t = 60) {
    a(this, "Fr");
    a(this, "Sr");
    a(this, "Ar", null);
    a(this, "zr", 0);
    a(this, "Tr", !0);
    a(this, "Er", 0);
    a(this, "Lr", 0);
    a(this, "Pr", []);
    a(this, "kr", 10);
    a(this, "Gr", 0);
    this.Fr = t, this.Sr = 1e3 / t;
  }
  start(t) {
    if (!this.Tr) return;
    this.zr = performance.now();
    const e = (i) => {
      if (!this.Tr) return void (this.Ar = null);
      const s = i - this.zr;
      s >= this.Sr && (t(), this.zr = i - s % this.Sr), this.Tr && (this.Ar = requestAnimationFrame(e));
    };
    this.Ar = requestAnimationFrame(e);
  }
  stop() {
    this.Ar && (cancelAnimationFrame(this.Ar), this.Ar = null);
  }
  pause() {
    this.Tr && (this.Tr = !1, this.stop());
  }
  resume(t) {
    this.Tr || (this.Tr = !0, this.start(t));
  }
  frameRate(t, e) {
    if (t === void 0) return this.Er;
    this.Fr = t, this.Sr = 1e3 / t, this.Tr && e && (this.stop(), this.start(e));
  }
  measureFrameRate() {
    const t = performance.now();
    if (this.Lr > 0) {
      const e = t - this.Lr;
      this.Pr.push(e), this.Pr.length > this.kr && this.Pr.shift();
      const i = this.Pr.reduce((s, r) => s + r, 0) / this.Pr.length;
      this.Er = 1e3 / i;
    }
    this.Lr = t;
  }
  get isLooping() {
    return this.Tr;
  }
  get frameRateLimit() {
    return this.Fr;
  }
  get currentFrameRate() {
    return this.Er;
  }
  get frameCount() {
    return this.Gr;
  }
  set frameCount(t) {
    this.Gr = t;
  }
  incrementFrame() {
    this.Gr++;
  }
  resetFrameCount() {
    this.Gr = 0;
  }
}
class Yt {
  constructor() {
    a(this, "Br", /* @__PURE__ */ new Map());
    a(this, "Dr", null);
    a(this, "Ir", null);
    a(this, "Wr");
    a(this, "Or");
    a(this, "Hr", !1);
    a(this, "Vr");
    a(this, "Kr");
    a(this, "Nr", { ArrowUp: "UP_ARROW", ArrowDown: "DOWN_ARROW", ArrowLeft: "LEFT_ARROW", ArrowRight: "RIGHT_ARROW", F1: "F1", F2: "F2", F3: "F3", F4: "F4", F5: "F5", F6: "F6", F7: "F7", F8: "F8", F9: "F9", F10: "F10", F11: "F11", F12: "F12", Enter: "ENTER", Return: "RETURN", Tab: "TAB", Escape: "ESCAPE", Backspace: "BACKSPACE", Delete: "DELETE", Insert: "INSERT", Home: "HOME", End: "END", PageUp: "PAGE_UP", PageDown: "PAGE_DOWN", Shift: "SHIFT", Control: "CONTROL", Alt: "ALT", Meta: "META", " ": "SPACE" });
  }
  Xr() {
    this.Hr || (this.Wr = (t) => {
      this.jr(t);
    }, this.Or = (t) => {
      this.Yr(t);
    }, window.addEventListener("keydown", this.Wr, { passive: !1 }), window.addEventListener("keyup", this.Or, { passive: !1 }), this.Hr = !0);
  }
  qr() {
    this.Hr && (window.removeEventListener("keydown", this.Wr), window.removeEventListener("keyup", this.Or), this.Hr = !1, this.Br.clear(), this.Dr = null, this.Ir = null);
  }
  Zr(t) {
    this.Vr = t;
  }
  Jr(t) {
    this.Kr = t;
  }
  Qr(t) {
    const e = this.tn(t), i = this.Br.get(t) || this.Br.get(e);
    return (i == null ? void 0 : i.isPressed) || !1;
  }
  en() {
    return this.Dr;
  }
  sn() {
    return this.Ir;
  }
  rn() {
    const t = [];
    for (const [e, i] of this.Br) i.isPressed && t.push(e);
    return t;
  }
  nn() {
    return { ctrl: this.Qr("Control"), shift: this.Qr("Shift"), alt: this.Qr("Alt"), meta: this.Qr("Meta") };
  }
  an() {
    this.Br.clear(), this.Dr = null, this.Ir = null;
  }
  jr(t) {
    const e = t.key, i = Date.now();
    this.Br.has(e) || this.Br.set(e, { isPressed: !1, lastPressTime: 0, lastReleaseTime: 0 });
    const s = this.Br.get(e);
    if (!s.isPressed && (s.isPressed = !0, s.lastPressTime = i, this.Dr = e, this.Vr)) {
      const r = { key: e, keyCode: t.keyCode, ctrlKey: t.ctrlKey, shiftKey: t.shiftKey, altKey: t.altKey, metaKey: t.metaKey, isPressed: !0, originalEvent: t };
      this.Vr(r);
    }
  }
  Yr(t) {
    const e = t.key, i = Date.now();
    this.Br.has(e) || this.Br.set(e, { isPressed: !1, lastPressTime: 0, lastReleaseTime: 0 });
    const s = this.Br.get(e);
    if (s.isPressed = !1, s.lastReleaseTime = i, this.Ir = e, this.Kr) {
      const r = { key: e, keyCode: t.keyCode, ctrlKey: t.ctrlKey, shiftKey: t.shiftKey, altKey: t.altKey, metaKey: t.metaKey, isPressed: !1, originalEvent: t };
      this.Kr(r);
    }
  }
  tn(t) {
    return this.Nr[t] || t.toLowerCase();
  }
}
class Vt {
  constructor(t) {
    a(this, "er");
    a(this, "hn");
    a(this, "cn", { x: -1, y: -1 });
    a(this, "ln", { x: -1, y: -1 });
    a(this, "un", null);
    a(this, "fn");
    a(this, "dn");
    a(this, "_n");
    a(this, "pn");
    a(this, "mn");
    a(this, "gn");
    a(this, "Hr", !1);
    a(this, "vn");
    a(this, "yn");
    a(this, "Cn");
    a(this, "wn");
    a(this, "$n");
    this.er = t;
  }
  Ni(t) {
    this.hn = t, this.bn();
  }
  Xr() {
    if (this.Hr) return;
    const t = this.er.canvas;
    this.fn = (e) => {
      this.xn(e), this.Mn(e);
    }, this.dn = () => {
      this.ln = { ...this.cn }, this.cn.x = -1, this.cn.y = -1, this.un = null;
    }, this._n = (e) => {
      this.xn(e), this.Rn(e);
    }, this.pn = (e) => {
      this.xn(e), this.Fn(e);
    }, this.mn = (e) => {
      this.xn(e), this.Sn(e);
    }, this.gn = (e) => {
      this.xn(e), this.An(e);
    }, t.addEventListener("mousemove", this.fn, { passive: !0 }), t.addEventListener("mouseleave", this.dn, { passive: !0 }), t.addEventListener("mousedown", this._n, { passive: !0 }), t.addEventListener("mouseup", this.pn, { passive: !0 }), t.addEventListener("click", this.mn, { passive: !0 }), t.addEventListener("wheel", this.gn, { passive: !1 }), this.Hr = !0;
  }
  qr() {
    if (!this.Hr) return;
    const t = this.er.canvas;
    t.removeEventListener("mousemove", this.fn), t.removeEventListener("mouseleave", this.dn), t.removeEventListener("mousedown", this._n), t.removeEventListener("mouseup", this.pn), t.removeEventListener("click", this.mn), t.removeEventListener("wheel", this.gn), this.Hr = !1;
  }
  bn() {
    if (this.Hr) try {
      if (this.un) {
        const t = new MouseEvent("mousemove", { clientX: this.un.x, clientY: this.un.y, bubbles: !1, cancelable: !1 });
        this.xn(t);
      } else this.cn.x !== -1 && this.cn.y !== -1 && (this.cn.x >= this.hn.cols || this.cn.y >= this.hn.rows) && (this.cn.x = -1, this.cn.y = -1);
    } catch {
      this.cn.x = -1, this.cn.y = -1;
    }
  }
  zn(t) {
    this.vn = t;
  }
  Zr(t) {
    this.yn = t;
  }
  Jr(t) {
    this.Cn = t;
  }
  Tn(t) {
    this.wn = t;
  }
  En(t) {
    this.$n = t;
  }
  Ln() {
    return { x: this.cn.x, y: this.cn.y };
  }
  Mn(t) {
    if (this.wn) {
      const e = { position: { ...this.cn }, previousPosition: { ...this.ln }, originalEvent: t };
      this.wn(e);
    }
  }
  Rn(t) {
    if (this.yn) {
      const e = { position: { ...this.cn }, previousPosition: { ...this.ln }, button: t.button, originalEvent: t };
      this.yn(e);
    }
  }
  Fn(t) {
    if (this.Cn) {
      const e = { position: { ...this.cn }, previousPosition: { ...this.ln }, button: t.button, originalEvent: t };
      this.Cn(e);
    }
  }
  Sn(t) {
    if (this.vn) {
      const e = { position: { ...this.cn }, previousPosition: { ...this.ln }, button: t.button, originalEvent: t };
      this.vn(e);
    }
  }
  An(t) {
    if (this.$n) {
      const e = { position: { ...this.cn }, previousPosition: { ...this.ln }, delta: { x: t.deltaX, y: t.deltaY }, originalEvent: t };
      this.$n(e);
    }
  }
  xn(t) {
    const e = this.er.canvas;
    this.ln = { ...this.cn }, this.un = { x: t.clientX, y: t.clientY };
    const i = e.getBoundingClientRect(), s = t.clientX - i.left, r = t.clientY - i.top, n = e.width / i.width, o = r * (e.height / i.height), c = s * n - this.hn.offsetX, l = o - this.hn.offsetY, u = Math.floor(c / this.hn.cellWidth), f = Math.floor(l / this.hn.cellHeight);
    u >= 0 && u < this.hn.cols && f >= 0 && f < this.hn.rows ? (this.cn.x = u, this.cn.y = f) : (this.cn.x = -1, this.cn.y = -1);
  }
}
const Kt = (h) => class extends h {
  rotate(t = 0, e = 0, i = 0) {
    this.xt.state.et(t), this.xt.state.st(e), this.xt.state.it(i);
  }
  rotateX(t) {
    this.xt.state.et(t);
  }
  rotateY(t) {
    this.xt.state.st(t);
  }
  rotateZ(t) {
    this.xt.state.it(t);
  }
  push() {
    this.xt.state.W();
  }
  pop() {
    this.xt.state.Z();
  }
  rect(t, e, i = 1, s = 1) {
    this.xt.Vs(t, e, i, s);
  }
  point(t, e) {
    this.xt.Vs(t, e, 1, 1);
  }
  line(t, e, i, s) {
    this.xt.Ks(t, e, i, s);
  }
  lineWeight(t) {
    this.xt.state.tt(t);
  }
  background(t, e = t, i = t, s = 255) {
    this.xt.Zs(t, e, i, s);
  }
  char(t) {
    this.xt.state.rt(this.Li.Ti(t));
  }
  charColor(t, e, i) {
    this.xt.state.nt(t, e, i);
  }
  cellColor(t, e, i) {
    this.xt.state.ot(t, e, i);
  }
  flipX(t) {
    this.xt.state.ht(t);
  }
  flipY(t) {
    this.xt.state.ct(t);
  }
  charRotation(t) {
    this.xt.state.ut(t);
  }
  invert(t) {
    this.xt.state.lt(t);
  }
  clear() {
    this.xt.Zs(0, 0, 0, 0);
  }
  ellipse(t, e, i, s) {
    this.xt.Ns(t, e, i / 2, s / 2);
  }
  triangle(t, e, i, s, r, n) {
    this.xt.Xs(t, e, i, s, r, n);
  }
  bezierCurve(t, e, i, s, r, n, o, c) {
    this.xt.js(t, e, i, s, r, n, o, c);
  }
  arc(t, e, i, s, r, n) {
    this.xt.qs(t, e, i, s, r, n);
  }
  shader(t) {
    this.xt.Bs(t);
  }
  setUniform(t, e) {
    this.xt.Xt(t, e);
  }
  setUniforms(t) {
    this.xt.Ds(t);
  }
  createFilterShader(t) {
    return this.xt.oe(t);
  }
  createFramebuffer(t) {
    return this.xt.Ys(t.width, t.height, 5, { filter: "nearest", wrap: "clamp", format: "rgba", type: "unsigned_byte" });
  }
  image(t, e, i, s, r) {
    if (t.textures) {
      const n = t;
      this.xt.Is(n, e, i, s ?? n.width, r ?? n.height);
    } else {
      const n = t;
      this.xt.Ws(n, e, i, s ?? Math.floor(this.hn.cols / 2), r ?? Math.floor(this.hn.rows / 2));
    }
  }
  async loadImage(t) {
    if (typeof t != "string") return k.Rr(this.xt, t, (s) => this.Li.Ei(s));
    const e = t, i = await new Promise((s, r) => {
      const n = new Image();
      n.crossOrigin = "anonymous", n.onload = () => s(n), n.onerror = (o) => r(o), n.src = e;
    });
    return k.Rr(this.xt, i, (s) => this.Li.Ei(s));
  }
};
class J {
  Pn(t) {
    const e = t.zt(0), i = t.zt(1), s = t.zt(2), r = t.zt(3);
    return { characterPixels: e, primaryColorPixels: i, secondaryColorPixels: s, transformPixels: t.zt(4), rotationPixels: r };
  }
  kn(t, e) {
    return t[e] + (t[e + 1] << 8);
  }
  Gn(t, e) {
    return { r: t[e], g: t[e + 1], b: t[e + 2], a: t[e + 3] };
  }
}
class Q {
  Bn(t, e) {
    return new Blob([t], { type: e });
  }
  Dn(t, e, i) {
    try {
      const s = this.Bn(t, i), r = URL.createObjectURL(s), n = document.createElement("a");
      n.href = r, n.download = e, n.style.display = "none", n.rel = "noopener", document.body.appendChild(n), n.click(), document.body.removeChild(n), URL.revokeObjectURL(r);
    } catch (s) {
      console.error("Failed to download file:", s);
    }
  }
  In() {
    return (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace(/:/g, "-");
  }
  Wn() {
    const t = /* @__PURE__ */ new Date();
    return { date: t.toISOString().split("T")[0], time: t.toTimeString().split(" ")[0].replace(/:/g, "-") };
  }
  On(t) {
    return t.replace(/[<>:"/\\|?*]/g, "_").replace(/\s+/g, "_").replace(/_{2,}/g, "_").replace(/^_+|_+$/g, "").substring(0, 255);
  }
  Hn() {
    return "textmode-export-" + this.In();
  }
}
class jt extends J {
  Vn(t, e, i) {
    const s = t[i] === 255, r = t[i + 1] === 255, n = t[i + 2] === 255, o = e[i], c = e[i + 1];
    return { isInverted: s, flipHorizontal: r, flipVertical: n, rotation: Math.round(360 * (o + c / 255) / 255 * 100) / 100 };
  }
  Kn(t, e, i) {
    return { x: t, y: e, cellX: t * i.cellWidth, cellY: e * i.cellHeight };
  }
  Nn(t, e) {
    const i = [];
    let s = 0;
    for (let r = 0; r < e.rows; r++) for (let n = 0; n < e.cols; n++) {
      const o = 4 * s, c = this.kn(t.characterPixels, o);
      let l = this.Gn(t.primaryColorPixels, o), u = this.Gn(t.secondaryColorPixels, o);
      const f = this.Vn(t.transformPixels, t.rotationPixels, o);
      if (f.isInverted) {
        const v = l;
        l = u, u = v;
      }
      const g = this.Kn(n, r, e);
      i.push({ charIndex: c, primaryColor: l, secondaryColor: u, transform: f, position: g }), s++;
    }
    return i;
  }
}
class qt {
  Xn(t, e) {
    const i = t.cmap;
    for (const s of i.tables) if (s.format === 4) {
      const r = s;
      for (let n = 0; n < r.startCount.length; n++) if (e >= r.startCount[n] && e <= r.endCount[n]) {
        if (r.idRangeOffset[n] === 0) return e + r.idDelta[n] & 65535;
        {
          const o = r.idRangeOffset[n] / 2 + (e - r.startCount[n]) - (r.startCount.length - n);
          if (o >= 0 && o < r.glyphIdArray.length) {
            const c = r.glyphIdArray[o];
            if (c !== 0) return c + r.idDelta[n] & 65535;
          }
        }
      }
    } else if (s.format === 12) {
      const r = s;
      for (let n = 0; n < r.groups.length; n += 3) {
        const o = r.groups[n], c = r.groups[n + 1], l = r.groups[n + 2];
        if (e >= o && e <= c) return l + (e - o);
      }
    }
    return 0;
  }
  jn(t, e, i, s, r) {
    const n = r / t.head.unitsPerEm;
    return { getBoundingBox: () => ({ x1: i + e.xMin * n, y1: s + -e.yMax * n, x2: i + e.xMax * n, y2: s + -e.yMin * n }), toSVG: () => this.Yn(e, i, s, n) };
  }
  Yn(t, e, i, s) {
    if (!t || !t.xs) return "";
    const { xs: r, ys: n, endPts: o, flags: c } = t;
    if (!(r && n && o && c)) return "";
    let l = "", u = 0;
    for (let f = 0; f < o.length; f++) {
      const g = o[f];
      if (!(g < u)) {
        if (g >= u) {
          const v = e + r[u] * s, m = i - n[u] * s;
          l += `M${v.toFixed(2)},${m.toFixed(2)}`;
          let d = u + 1;
          for (; d <= g; )
            if (1 & c[d]) {
              const x = e + r[d] * s, p = i - n[d] * s;
              l += `L${x.toFixed(2)},${p.toFixed(2)}`, d++;
            } else {
              const x = e + r[d] * s, p = i - n[d] * s;
              let E = d + 1 > g ? u : d + 1;
              if (1 & c[E]) {
                const y = e + r[E] * s, C = i - n[E] * s;
                l += `Q${x.toFixed(2)},${p.toFixed(2)} ${y.toFixed(2)},${C.toFixed(2)}`, d = E + 1;
              } else {
                const y = (x + (e + r[E] * s)) / 2, C = (p + (i - n[E] * s)) / 2;
                l += `Q${x.toFixed(2)},${p.toFixed(2)} ${y.toFixed(2)},${C.toFixed(2)}`, d = E;
              }
            }
          l += "Z";
        }
        u = g + 1;
      }
    }
    return l;
  }
  qn(t, e, i, s, r) {
    const n = t.codePointAt(0) || 0, o = this.Xn(e, n);
    let c = null;
    return e.glyf && e.glyf[o] !== null ? c = e.glyf[o] : (c = F.T.glyf.Qs(e, o), e.glyf[o] = c), this.jn(e, c, i, s, r);
  }
  Zn(t, e, i, s, r, n, o, c) {
    const l = i + (r - c * (o / e.head.unitsPerEm)) / 2, u = s + (n + 0.7 * o) / 2;
    return this.qn(t, e, l, u, o).toSVG() || null;
  }
}
class Jt {
  constructor() {
    a(this, "Jn");
    this.Jn = new qt();
  }
  Qn(t) {
    const { width: e, height: i } = t;
    return `<?xml version="1.0" encoding="UTF-8"?><svg width="${e}" height="${i}" viewBox="0 0 ${e} ${i}" xmlns="http://www.w3.org/2000/svg"><title>textmode.js sketch</title>`;
  }
  eo() {
    return "</g></svg>";
  }
  so(t, e) {
    if (!e.includeBackgroundRectangles) return "";
    const [i, s, r, n] = e.backgroundColor;
    return `<rect width="${t.width}" height="${t.height}" fill="rgba(${i},${s},${r},${n / 255})"/>`;
  }
  io(t, e) {
    const { transform: i, position: s } = t;
    if (!i.flipHorizontal && !i.flipVertical && !i.rotation) return "";
    const r = s.cellX + e.cellWidth / 2, n = s.cellY + e.cellHeight / 2, o = [];
    if (i.flipHorizontal || i.flipVertical) {
      const c = i.flipHorizontal ? -1 : 1, l = i.flipVertical ? -1 : 1;
      o.push(`translate(${r} ${n})scale(${c} ${l})translate(${-r} ${-n})`);
    }
    return i.rotation && o.push(`rotate(${i.rotation} ${r} ${n})`), ` transform="${o.join(" ")}"`;
  }
  ro(t, e, i) {
    if (!i.includeBackgroundRectangles || t.secondaryColor.a === 0) return "";
    const { position: s } = t, { r, g: n, b: o, a: c } = t.secondaryColor, l = `rgba(${r},${n},${o},${c / 255})`;
    return i.drawMode === "stroke" ? `<rect x="${s.cellX}" y="${s.cellY}" width="${e.cellWidth}" height="${e.cellHeight}" stroke="${l}" fill="none" stroke-width="${i.strokeWidth}"/>` : `<rect x="${s.cellX}" y="${s.cellY}" width="${e.cellWidth}" height="${e.cellHeight}" fill="${l}"/>`;
  }
  qn(t, e, i, s) {
    const r = i.characters[t.charIndex];
    if (!r) return "";
    const n = this.Jn.Zn(r.character, i.font, t.position.cellX, t.position.cellY, e.cellWidth, e.cellHeight, i.fontSize, r.advanceWidth);
    if (!n) return "";
    const { r: o, g: c, b: l, a: u } = t.primaryColor, f = `rgba(${o},${c},${l},${u / 255})`;
    return s.drawMode === "stroke" ? `<path d="${n}" stroke="${f}" stroke-width="${s.strokeWidth}" fill="none"/>` : `<path d="${n}" fill="${f}"/>`;
  }
  no(t, e, i, s) {
    const r = [], n = this.ro(t, e, s);
    n && r.push(n);
    const o = this.qn(t, e, i, s);
    if (o) {
      const c = this.io(t, e);
      r.push(c ? `<g${c}>${o}</g>` : o);
    }
    return r.join("");
  }
  oo(t, e, i, s) {
    const r = [this.Qn(e), this.so(e, s), '<g id="ascii-cells">'];
    for (const n of t) r.push(this.no(n, e, i, s));
    return r.push(this.eo()), r.join("");
  }
  ao(t) {
    return t.replace(/<path[^>]*d=""[^>]*\/>/g, "").replace(/\s+/g, " ").replace(/> </g, "><");
  }
}
class Qt extends Q {
  ho(t) {
    return this.Bn(t, "image/svg+xml;charset=utf-8");
  }
  co(t, e) {
    this.Dn(t, this.On(e) + ".svg", "image/svg+xml;charset=utf-8");
  }
  lo(t, e) {
    this.co(t, e || this.Hn());
  }
}
class st {
  constructor() {
    a(this, "uo");
    a(this, "fo");
    a(this, "do");
    this.uo = new jt(), this.fo = new Jt(), this.do = new Qt();
  }
  _o(t) {
    return { includeBackgroundRectangles: t.includeBackgroundRectangles ?? !0, drawMode: t.drawMode ?? "fill", strokeWidth: t.strokeWidth ?? 1, backgroundColor: t.backgroundColor ?? [0, 0, 0, 0], filename: t.filename || this.do.Hn() };
  }
  po(t, e = {}) {
    const i = this.uo.Nn(this.uo.Pn(t.pipeline), t.grid), s = this.fo.oo(i, t.grid, t.font, this._o(e));
    return this.fo.ao(s);
  }
  lo(t, e = {}) {
    this.do.lo(this.po(t, e), e.filename);
  }
}
class Zt extends J {
  mo(t, e, i, s = " ") {
    var o;
    const r = [];
    let n = 0;
    for (let c = 0; c < e.rows; c++) {
      const l = [];
      for (let u = 0; u < e.cols; u++) {
        const f = 4 * n, g = this.kn(t.characterPixels, f), v = ((o = i.characters[g]) == null ? void 0 : o.character) || s;
        l.push(v), n++;
      }
      r.push(l);
    }
    return r;
  }
}
class te {
  vo(t, e) {
    const i = [];
    for (const r of t) {
      let n = r.join("");
      e.preserveTrailingSpaces || (n = n.replace(/\s+$/, "")), i.push(n);
    }
    const s = e.lineEnding === "crlf" ? `\r
` : `
`;
    return i.join(s);
  }
}
class ee extends Q {
  yo(t, e) {
    const i = this.Co(e);
    this.Dn(t, i, "text/plain;charset=utf-8");
  }
  Co(t) {
    let e = this.On(t);
    return e === ".txt" || e.length <= 4 ? this.Hn() : e;
  }
}
class rt {
  constructor() {
    a(this, "uo");
    a(this, "fo");
    a(this, "do");
    this.uo = new Zt(), this.fo = new te(), this.do = new ee();
  }
  _o(t) {
    return { preserveTrailingSpaces: t.preserveTrailingSpaces ?? !1, lineEnding: t.lineEnding ?? "lf", emptyCharacter: t.emptyCharacter ?? " ", filename: t.filename || this.do.Hn() };
  }
  wo(t, e = {}) {
    const i = this._o(e), s = this.uo.mo(this.uo.Pn(t.pipeline), t.grid, t.font, i.emptyCharacter);
    return this.fo.vo(s, i);
  }
  yo(t, e = {}) {
    this.do.yo(this.wo(t, e), e.filename);
  }
}
class ie extends J {
  $o(t, e = 1, i = "transparent") {
    const s = t.canvas;
    if (e === 1 && i === "transparent") return s;
    const r = document.createElement("canvas"), n = r.getContext("2d"), o = Math.round(s.width * e), c = Math.round(s.height * e);
    return r.width = o, r.height = c, i !== "transparent" && (n.fillStyle = i, n.fillRect(0, 0, o, c)), n.imageSmoothingEnabled = !1, n.drawImage(s, 0, 0, s.width, s.height, 0, 0, o, c), r;
  }
}
class se {
  bo(t, e) {
    const i = this.xo(e.format);
    return e.format === "png" ? t.toDataURL(i) : t.toDataURL(i, e.quality);
  }
  async Mo(t, e) {
    return new Promise((i, s) => {
      const r = this.xo(e.format), n = (o) => {
        o ? i(o) : s(Error(`Failed to generate ${e.format.toUpperCase()} blob`));
      };
      e.format === "png" ? t.toBlob(n, r) : t.toBlob(n, r, e.quality);
    });
  }
  xo(t) {
    switch (t) {
      case "png":
        return "image/png";
      case "jpg":
        return "image/jpeg";
      case "webp":
        return "image/webp";
      default:
        throw Error("Unsupported image format: " + t);
    }
  }
}
const re = { png: "image/png", jpg: "image/jpeg", webp: "image/webp" }, nt = { png: ".png", jpg: ".jpg", webp: ".webp" };
class ne extends Q {
  Ro(t, e, i) {
    this.Fo(t, this.On(e) + nt[i]);
  }
  Fo(t, e) {
    const i = URL.createObjectURL(t);
    try {
      const s = document.createElement("a");
      s.href = i, s.download = e, s.style.display = "none", s.rel = "noopener", document.body.appendChild(s), s.click(), document.body.removeChild(s);
    } finally {
      URL.revokeObjectURL(i);
    }
  }
  So(t) {
    return t in re && t in nt;
  }
}
class oe {
  constructor() {
    a(this, "uo");
    a(this, "fo");
    a(this, "do");
    this.uo = new ie(), this.fo = new se(), this.do = new ne();
  }
  _o(t) {
    return { format: t.format ?? "png", quality: t.quality ?? 1, scale: t.scale ?? 1, backgroundColor: t.backgroundColor ?? "transparent", filename: t.filename || this.do.Hn() };
  }
  Ao(t) {
    if (!this.do.So(t.format)) throw Error(`Saving '${t.format}' files is not supported`);
    if (t.quality < 0 || t.quality > 1) throw Error("Image quality must be between 0.0 and 1.0");
    if (t.scale <= 0) throw Error("Scale factor must be greater than 0");
    t.format === "jpg" && t.backgroundColor === "transparent" && (t.backgroundColor = "black");
  }
  async Mo(t, e) {
    if (e.scale === 1 && e.backgroundColor === "transparent") return await this.fo.Mo(t.canvas, e);
    const i = this.uo.$o(t, e.scale, e.backgroundColor);
    return await this.fo.Mo(i, e);
  }
  async Ro(t, e = {}) {
    const i = this._o(e);
    this.Ao(i);
    const s = await this.Mo(t, i);
    this.do.Ro(s, i.filename, i.format);
  }
}
const he = (h) => class extends h {
  zo() {
    this.xt.Et(this.To);
  }
  toString(t = {}) {
    return this.zo(), new rt().wo({ pipeline: this.Eo, grid: this.hn, font: this.Li }, t);
  }
  saveStrings(t = {}) {
    this.zo(), new rt().yo({ pipeline: this.Eo, grid: this.hn, font: this.Li }, t);
  }
  toSVG(t = {}) {
    return this.zo(), new st().po({ pipeline: this.Eo, grid: this.hn, font: this.Li }, t);
  }
  saveSVG(t = {}) {
    this.zo(), new st().lo({ pipeline: this.Eo, grid: this.hn, font: this.Li }, t);
  }
  async saveCanvas(t = {}) {
    await new oe().Ro(this.er, t);
  }
}, ae = (h) => class extends h {
  async loadFont(t) {
    return this.Li.qi(t).then(() => {
      const e = this.Li.maxGlyphDimensions;
      this.hn.nr(e.width, e.height), this.Eo.resize(this.hn.cols, this.hn.rows), this.xt.Js(), this.Lo.bn();
    });
  }
  fontSize(t) {
    if (!$.v(typeof t == "number" && t > 0, "Font size must be a positive number greater than 0.", { method: "fontSize", providedValue: t }) || this.Li.fontSize === t) return;
    this.Li.Yi(t);
    const e = this.Li.maxGlyphDimensions;
    this.hn.nr(e.width, e.height), this.Eo.resize(this.hn.cols, this.hn.rows), this.xt.Js(), this.Lo.bn();
  }
  glyphColor(t) {
    return this.Li.Ti(t);
  }
  glyphColors(t) {
    return this.Li.Ei(t);
  }
}, ce = (h) => class extends h {
  get frameCount() {
    return this.Po.frameCount;
  }
  set frameCount(t) {
    this.Po.frameCount = t;
  }
  frameRate(t) {
    return t === void 0 ? this.Po.currentFrameRate : this.Po.frameRate(t, () => this.ko());
  }
  noLoop() {
    this.Po.pause();
  }
  loop() {
    this.Po.resume(() => this.ko());
  }
  redraw(t = 1) {
    if ($.v(typeof t == "number" && t > 0 && Number.isInteger(t), "Redraw count must be a positive integer.", { method: "redraw", providedValue: t })) for (let e = 0; e < t; e++) this.ko();
  }
  isLooping() {
    return this.Po.isLooping;
  }
}, le = (h) => class extends h {
  constructor(...t) {
    super(...t);
  }
  mouseClicked(t) {
    this.Lo.zn(t);
  }
  mousePressed(t) {
    this.Lo.Zr(t);
  }
  mouseReleased(t) {
    this.Lo.Jr(t);
  }
  mouseMoved(t) {
    this.Lo.Tn(t);
  }
  mouseScrolled(t) {
    this.Lo.En(t);
  }
  get mouse() {
    return this.Lo.Ln();
  }
}, ue = (h) => class extends h {
  constructor(...t) {
    super(...t);
  }
  keyPressed(t) {
    this.Go.Zr(t);
  }
  keyReleased(t) {
    this.Go.Jr(t);
  }
  isKeyPressed(t) {
    return this.Go.Qr(t);
  }
  get lastKeyPressed() {
    return this.Go.en();
  }
  get lastKeyReleased() {
    return this.Go.sn();
  }
  get pressedKeys() {
    return this.Go.rn();
  }
  get modifierState() {
    return this.Go.nn();
  }
};
class fe {
  constructor() {
    a(this, "xt");
    a(this, "Li");
    a(this, "er");
    a(this, "hn");
    a(this, "Po");
    a(this, "Lo");
    a(this, "Go");
    a(this, "To");
    a(this, "Eo");
    a(this, "Bo");
    a(this, "Do");
    a(this, "Io");
  }
  ko() {
  }
}
class de extends function(e, ...i) {
  return i.reduce((s, r) => r(s), e);
}(fe, Kt, he, ae, ce, le, ue) {
  constructor(e = {}) {
    super();
    a(this, "Wo", !1);
    a(this, "Oo", () => {
    });
    a(this, "Ho", () => {
    });
    a(this, "Vo", () => {
    });
    a(this, "Ko");
    a(this, "cr");
    a(this, "hr", !1);
    a(this, "No");
    this.hr = e.overlay ?? !1, this.er = new Ht(e), this.xt = new Lt(this.er.gr()), this.Li = new zt(this.xt, e.fontSize ?? 16), this.Po = new Xt(e.frameRate ?? 60), this.Lo = new Vt(this.er), this.Go = new Yt(), this.To = this.xt.Tt(), this.Bo = this.xt.re(), this.Xo(e);
  }
  async Xo(e) {
    await this.Li.Ni(e.fontSource);
    const i = this.Li.maxGlyphDimensions;
    this.hn = new Wt(this.er.canvas, i.width, i.height), this.Lo.Ni(this.hn), this.Eo = this.xt.Ys(this.hn.cols, this.hn.rows, 5), this.Do = this.xt.Ys(this.hn.width, this.hn.height, 1), this.hr && (this.No = k.Rr(this.xt, this.er.targetCanvas, (s) => this.Li.Ei(s))), this.Io = this.xt.ae(at, "precision mediump float;uniform sampler2D Ua;uniform vec2 Ub;uniform vec2 Uc;uniform vec2 Ud;void main(){vec2 A=gl_FragCoord.xy-Uc;vec2 B=A*(Ub/Ud);vec2 C=(floor(B)+0.5)/Ub;gl_FragColor=texture2D(Ua,C);}"), this.jo(), this.Oo(), this.Po.start(() => this.ko());
  }
  jo() {
    this.Ko = () => {
      this.hr && this.resizeCanvas(this.er.targetCanvas.width, this.er.targetCanvas.height), this.Vo();
    }, window.addEventListener("resize", this.Ko), this.Lo.Xr(), this.Go.Xr(), window.addEventListener("blur", () => {
      this.Go.an();
    }), window.ResizeObserver && this.hr && (this.cr = new ResizeObserver(() => {
      this.resizeCanvas(this.er.targetCanvas.width, this.er.targetCanvas.height);
    }), this.cr.observe(this.er.targetCanvas));
  }
  ko() {
    if (this.Po.measureFrameRate(), this.Po.incrementFrame(), this.Wo) return;
    if (this.hr) {
      const i = this.xt.context;
      i.bindTexture(i.TEXTURE_2D, this.No.texture), i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, 1), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, i.RGBA, i.UNSIGNED_BYTE, this.er.targetCanvas), i.bindTexture(i.TEXTURE_2D, null);
    }
    this.Eo.begin(), this.xt.Gs(this.To), this.Ho(), this.xt.Et(this.To), this.Eo.end(), this.Do.begin(), this.xt.Gs(this.Bo), this.Bo.Nt({ U0: this.Li.fontFramebuffer, U1: [this.Li.textureColumns, this.Li.textureRows], U2: this.Eo.textures[0], U3: this.Eo.textures[1], U4: this.Eo.textures[2], U5: this.Eo.textures[4], U6: this.Eo.textures[3], U7: [this.hn.cols, this.hn.rows], U8: [this.Do.width, this.Do.height], U9: this.Do.width / this.Do.height }), this.xt.Hs(0, 0, this.er.width, this.er.height), this.Do.end();
    const e = this.xt.state.canvasBackgroundColor;
    this.xt.He(e[0], e[1], e[2], e[3]), this.xt.Gs(this.Io), this.Io.Nt({ Ua: this.Do.textures[0], Ub: [this.Do.width, this.Do.height], Uc: [this.hn.offsetX, this.hn.offsetY], Ud: [this.hn.width, this.hn.height] }), this.xt.Hs(this.hn.offsetX, this.hn.offsetY, this.hn.width, this.hn.height);
  }
  setup(e) {
    this.Oo = e;
  }
  draw(e) {
    this.Ho = e;
  }
  windowResized(e) {
    this.Vo = e;
  }
  resizeCanvas(e, i) {
    this.er.mr(e, i), this.hn.rr(), this.Eo.resize(this.hn.cols, this.hn.rows), this.Do.resize(this.hn.width, this.hn.height), this.xt.Js(), this.Lo.bn(), this.ko();
  }
  destroy() {
    this.Wo || (this.Po.stop(), window.removeEventListener("resize", this.Ko), this.Lo.qr(), this.Go.qr(), this.Li.kt(), this.xt.kt(), this.Do.kt(), this.Io.kt(), this.No && this.No.kt(), this.Wo = !0);
  }
  get grid() {
    return this.hn;
  }
  get font() {
    return this.Li;
  }
  get width() {
    return this.er.width;
  }
  get height() {
    return this.er.height;
  }
  get canvas() {
    return this.er.canvas;
  }
  get isDisposed() {
    return this.Wo;
  }
  get overlay() {
    return this.No;
  }
}
class Z {
  constructor() {
  }
  static create(t = {}) {
    return new de(t);
  }
  static setErrorLevel(t) {
    $.C(t);
  }
  static get version() {
    return "0.3.0";
  }
}
const pe = Object.freeze(Object.defineProperty({ __proto__: null }, Symbol.toStringTag, { value: "Module" })), me = Z.create, ve = Z.setErrorLevel, xe = Z.version;
export {
  Ht as TextmodeCanvas,
  ut as TextmodeErrorLevel,
  zt as TextmodeFont,
  j as TextmodeFramebuffer,
  Wt as TextmodeGrid,
  k as TextmodeImage,
  de as Textmodifier,
  me as create,
  pe as export,
  ve as setErrorLevel,
  Z as textmode,
  xe as version
};
